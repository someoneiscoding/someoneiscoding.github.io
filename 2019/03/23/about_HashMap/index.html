<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/Keyboard-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/Keyboard-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/Keyboard-16x16.png">
  <link rel="mask-icon" href="/images/Keyboard.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"www.someoneiscoding.com","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.17.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Context关于 HashMap, 有一件事儿一直很困惑，，在『Redis 核心历险』中是这样被提到的:  Redis 的字典相当于 Java 语言中的 HashMap，它是无序字典，内部存储了很多键值对。实现结构上与 Java 的 HashMap 也是一样的，都是”数组 + 链表”二维结构。第一维的 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。  嗯，第一句没啥问题，，然而”">
<meta property="og:type" content="article">
<meta property="og:title" content="关于 HashMap">
<meta property="og:url" content="https://www.someoneiscoding.com/2019/03/23/about_HashMap/index.html">
<meta property="og:site_name" content="程序员的自我修养">
<meta property="og:description" content="Context关于 HashMap, 有一件事儿一直很困惑，，在『Redis 核心历险』中是这样被提到的:  Redis 的字典相当于 Java 语言中的 HashMap，它是无序字典，内部存储了很多键值对。实现结构上与 Java 的 HashMap 也是一样的，都是”数组 + 链表”二维结构。第一维的 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。  嗯，第一句没啥问题，，然而”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">
<meta property="article:published_time" content="2019-03-23T09:22:42.000Z">
<meta property="article:modified_time" content="2023-12-16T02:43:36.754Z">
<meta property="article:author" content="小哪吒">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">


<link rel="canonical" href="https://www.someoneiscoding.com/2019/03/23/about_HashMap/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://www.someoneiscoding.com/2019/03/23/about_HashMap/","path":"2019/03/23/about_HashMap/","title":"关于 HashMap"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>关于 HashMap | 程序员的自我修养</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">程序员的自我修养</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#Context"><span class="nav-number">1.</span> <span class="nav-text">Context</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash"><span class="nav-number">2.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap"><span class="nav-number">3.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap-%E7%9A%84-DOC-%E6%B3%A8%E9%87%8A"><span class="nav-number">4.</span> <span class="nav-text">HashMap 的 DOC 注释</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#put-%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">put() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#get-%E6%96%B9%E6%B3%95%F0%9F%91%87"><span class="nav-number">4.2.</span> <span class="nav-text">get() 方法👇</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#remove-%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">remove() 方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#entrySet-%E6%96%B9%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">entrySet() 方法</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="小哪吒"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">小哪吒</p>
  <div class="site-description" itemprop="description">呓语</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">67</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">73</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.someoneiscoding.com/2019/03/23/about_HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="小哪吒">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员的自我修养">
      <meta itemprop="description" content="呓语">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="关于 HashMap | 程序员的自我修养">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          关于 HashMap
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-23 17:22:42" itemprop="dateCreated datePublished" datetime="2019-03-23T17:22:42+08:00">2019-03-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-12-16 10:43:36" itemprop="dateModified" datetime="2023-12-16T10:43:36+08:00">2023-12-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%90%8E%E6%97%B6%E4%BB%A3/" itemprop="url" rel="index"><span itemprop="name">Java后时代</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>关于 HashMap, 有一件事儿一直很困惑，，在『Redis 核心历险』中是这样被提到的:</p>
<blockquote>
<p>Redis 的字典相当于 Java 语言中的 HashMap，它是无序字典，内部存储了很多键值对。实现结构上<strong>与 Java 的 HashMap 也是一样的，都是”数组 + 链表”二维结构。第一维的 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来</strong>。</p>
</blockquote>
<p>嗯，第一句没啥问题，，然而”数组 + 链表”什么鬼？还有 hash 碰撞。。作者并没有详细解释这儿，应该默认是每个 Java 开发者都知道的知识点了。然而我却在这儿卡壳了，心慌慌。。趁着周末赶紧补补课。事实证明，这波补课是很有效果的，在这本书后边的内容中，hash 还将会一直出现。</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>在 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">Wiki</a> 中的定义为:</p>
<blockquote>
<p>散列函数（英语：Hash function）又称散列算法、哈希函数，<strong>是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来</strong>。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。<strong>在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到</strong>。</p>
</blockquote>
<p>用我自己的话来说就是，，为数据创建指纹摘要，通过该摘要就可以找到原始数据。我觉得更多的场景是为相对大的数据创建摘要。假如有个 hash()，可以为任意数据生成一个32位的摘要。那么我们在互联网下载文件的时候，有的网站会在下来链接处给出该文件的 hash 值，等用户下载完成之后，通过 hash() 对该文件提取摘要，将两个 hash 值，进行对比。如果结果一样，说明文件在下载过程中没有被篡改。</p>
<p>那倘若我们对数字 1 进行 hash()，那应该也会得到一个长度为 32 位的摘要，但这时候还能叫『摘要』么？我感觉是不太合适的。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>-Basic JDK7</p>
<p>OK，back to the point..关于 Hash 我们需要知道👇</p>
<blockquote>
<p>所有散列函数都有如下一个基本特性：<strong>如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的</strong>。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，<strong>如果两个散列值相同，两个输入值很可能是相同的，但也可能不同</strong>，这种情况称为“<strong>散列碰撞</strong>（collision）”。</p>
</blockquote>
<p>按我之前不成熟的想法，，HashMap 中为什么要放链表？直接放数据对象不就够了么。。原因就是当我们通过 get(key) 方法从 HashMap 中获取对象的时候，理论上这个 key 对应的 hash 值和某个 whateverKey 对应的 hash 值是一样的(即，散列碰撞)，，因为『如果两个散列值相同，两个输入值很可能是相同的，但也可能不同(即，key 和 whateverKey)』。此时我们可以通过 key 和 whateverKey 都可以获取到对应的数据对象。如此，为了解决散列碰撞带来的问题，我们需要在 HashMap 中将两个‘key’都指向同一个数据对象，而在 HashMap 中的链表就是用来维护这些‘key’的。下面，我们试着读读 HashMap 源码。</p>
<h4 id="HashMap-的-DOC-注释"><a href="#HashMap-的-DOC-注释" class="headerlink" title="HashMap 的 DOC 注释"></a>HashMap 的 DOC 注释</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This</span><br><span class="hljs-comment"> * implementation provides all of the optional map operations, and permits</span><br><span class="hljs-comment"> * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;</span><br><span class="hljs-comment"> * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is</span><br><span class="hljs-comment"> * unsynchronized and permits nulls.)  This class makes no guarantees as to</span><br><span class="hljs-comment"> * the order of the map; in particular, it does not guarantee that the order</span><br><span class="hljs-comment"> * will remain constant over time.</span><br><span class="hljs-comment"> * 👆散列表也基于对 Map 接口的实现。HashMap 也是对是 Map 接口的实现，提供了所有对 Map 的可选操作(的方法)，并且允许 null 值和 null 键。HashMap 大致相当与 HashTable 相同，除了 HashMap 是非同步的，且接受 null。该类不保证数据对象在内部的顺序，同时也不保证内部的顺序是一成不变的。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * &lt;p&gt;This implementation provides constant-time performance for the basic</span><br><span class="hljs-comment"> * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</span><br><span class="hljs-comment"> * disperses the elements properly among the buckets.  Iteration over</span><br><span class="hljs-comment"> * collection views requires time proportional to the &quot;capacity&quot; of the</span><br><span class="hljs-comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number</span><br><span class="hljs-comment"> * of key-value mappings).  Thus, it&#x27;s very important not to set the initial</span><br><span class="hljs-comment"> * capacity too high (or the load factor too low) if iteration performance </span><br><span class="hljs-comment"> * is important.</span><br><span class="hljs-comment"> * 👆HashMap 中 get 和 put 这两项基本操作提供复杂度为常数级别的性能表现，假定 hash 方法把元素均匀的分配到桶中。对整个集合视图进行迭代所需的时间与 HashMap 实例(桶的数量)乘以它的容量(键值对的数量)之积。所以，如果迭代性能很重要的话，不要在初始化 HashMap 的时候设置过高的容量，及太小的负载系数(负载因子)</span><br><span class="hljs-comment"> * * &lt;p&gt;As a general rule, the default load factor (.75) offers a good tradeoff</span><br><span class="hljs-comment"> * between time and space costs.  Higher values decrease the space overhead</span><br><span class="hljs-comment"> * but increase the lookup cost (reflected in most of the operations of the</span><br><span class="hljs-comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; class, including &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The</span><br><span class="hljs-comment"> * expected number of entries in the map and its load factor should be taken</span><br><span class="hljs-comment"> * into account when setting its initial capacity, so as to minimize the</span><br><span class="hljs-comment"> * number of rehash operations.  If the initial capacity is greater</span><br><span class="hljs-comment"> * than the maximum number of entries divided by the load factor, no</span><br><span class="hljs-comment"> * rehash operations will ever occur.</span><br><span class="hljs-comment"> * 👆一般，默认的负载系数（0.75）在时间和空间成本之间提供了很好的平衡。更高的值会减少了空间开销，但同时会增加查找成本（反映在 Hashmap 的大多数操作中，包括 get 和 put）。在设置初始容量时，应考虑到 Map 中预期的条目数量及其负载系数，以尽量减少 rehash 的次数。如果初始容量大于最大条目数除以负载系数的值，则不会发生 rehash 操作。</span><br><span class="hljs-comment"> * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt; instance,</span><br><span class="hljs-comment"> * creating it with a sufficiently large capacity will allow the mappings to</span><br><span class="hljs-comment"> * be stored more efficiently than letting it perform automatic rehashing as</span><br><span class="hljs-comment"> * needed to grow the table.</span><br><span class="hljs-comment"> * 👆如果要在一个 HashMap 实例中存储多个键值对，那么创建实例时指定足够大的容量将比让它根据需要 rehash 以扩充容量的效率更高。</span><br><span class="hljs-comment"> * &lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span><br><span class="hljs-comment"> * If multiple threads access a hash map concurrently, and at least one of</span><br><span class="hljs-comment"> * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be</span><br><span class="hljs-comment"> * synchronized externally.  (A structural modification is any operation</span><br><span class="hljs-comment"> * that adds or deletes one or more mappings; merely changing the value</span><br><span class="hljs-comment"> * associated with a key that an instance already contains is not a</span><br><span class="hljs-comment"> * structural modification.)  This is typically accomplished by</span><br><span class="hljs-comment"> * synchronizing on some object that naturally encapsulates the map.</span><br><span class="hljs-comment"> * 👆需要注意的是，HashMap 是非线程安全的。如果多线程同时请求访问 HashMap，并且有至少一条线程改变了 HashMap 实例的结构，那么必须在 HashMap 外层对它添加 synchronized 修饰。（结构修改是指任何添加或删除一个或多个键值对的操作；仅更改实例已包含的键关联的值不是结构修改。）（这一句不太懂诶。。。）</span><br><span class="hljs-comment"> * If no such object exists, the map should be &quot;wrapped&quot; using the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Collections#synchronizedMap Collections.synchronizedMap&#125;</span><br><span class="hljs-comment"> * method.  This is best done at creation time, to prevent accidental</span><br><span class="hljs-comment"> * unsynchronized access to the map:&lt;pre&gt;</span><br><span class="hljs-comment"> *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;</span><br><span class="hljs-comment"> * 👆如果这样的对象不存在，则该 HashMap 应该被Collections.synchronizedMap()方法包裹起来。最好在对象初创建的时候就这样做，以免发生不可预知的对 HashMap 的访问。</span><br><span class="hljs-comment"> * &lt;p&gt;The iterators returned by all of this class&#x27;s &quot;collection view methods&quot;</span><br><span class="hljs-comment"> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after</span><br><span class="hljs-comment"> * the iterator is created, in any way except through the iterator&#x27;s own</span><br><span class="hljs-comment"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span><br><span class="hljs-comment"> * modification, the iterator fails quickly and cleanly, rather than risking</span><br><span class="hljs-comment"> * arbitrary, non-deterministic behavior at an undetermined time in the</span><br><span class="hljs-comment"> * future.</span><br><span class="hljs-comment"> * 👆HashMap 的迭代器返回的这个类的所有集合视图方法都是‘快速失效’的: 所有在迭代器创建之后对 HashMap 进行结构性修改，除了迭代器自己的 remove()方法外，会抛出 ConcurrentModificationException。在面对并发对 HashMap 的修改时，迭代器会快速彻底的失效，而不会选择在之后冒不确定的、未知的风险。</span><br><span class="hljs-comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span><br><span class="hljs-comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span><br><span class="hljs-comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span><br><span class="hljs-comment"> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span><br><span class="hljs-comment"> * Therefore, it would be wrong to write a program that depended on this</span><br><span class="hljs-comment"> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators</span><br><span class="hljs-comment"> * should be used only to detect bugs.&lt;/i&gt;</span><br><span class="hljs-comment"> * 👆需要注意的是，迭代器的快速失效并不能被保证(一定发生)，，通常来讲，在非同步并发修改 HashMap 的情况下，无法(对快速失效)做出硬性保证。迭代器快速失效后会尽最大努力抛出 ConcurrentModificationException 异常。因此，不能依靠是否抛出该异常来确定写的程序是否是正确的：迭代器的快速失效行为只能被用来查明bug。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment"> * HashMap 的默认初始容量--必须是 2 的 N 次方</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16 (Also Known As, 即初始值为 16)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="hljs-comment"> * by either of the constructors with arguments.</span><br><span class="hljs-comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="hljs-comment"> * 最大容量，在带参构造函数中隐式判断指定的容量是否超出最大容量时使用。</span><br><span class="hljs-comment"> * 必须是 2 的 N 次方，且不大于 2^30</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor used when none specified in constructor.</span><br><span class="hljs-comment"> * 构造器未指定负载系数时，使用该默认值</span><br><span class="hljs-comment"> * (当 HashMap 的 size 大于 HashMap 的 capacity * loadFactor 时，HashMap 扩容，即 capacity *= 2，并 rehash())</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * An empty table instance to share when the table is not inflated.</span><br><span class="hljs-comment"> * 在表还没有扩容之前，共享该空数组实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="hljs-comment"> * 整个表的容量，如果有必要的话(键值对条数/负载系数 &gt;= table.length)会进行扩容。容量大小必须是 2 的幂次方</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The number of key-value mappings contained in this map.</span><br><span class="hljs-comment"> * map 中键值对的条数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The next size value at which to resize (capacity * load factor).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> * 下一次扩容后的大小(容量*负载系数)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> threshold;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor for the hash table.</span><br><span class="hljs-comment"> * table 的负载系数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 无参构造方法，使用默认初始容量(16)，默认负载系数(.75)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 带参构造方法，指定初始容量为initialCapacity</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 带参构造方法，指定初始容量和负载系数</span><br><span class="hljs-comment"> * 最终所有构造函数都指向该构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-comment">// 如果指定的初始容量 &lt;0，则抛出不合法参数异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>    <span class="hljs-comment">// 如果指定的容量大于最大容量，则使用最大容量为初始容量</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-comment">// 如果指定的负载系数不大于零或不是浮点数，则抛出不合法参数异常</span><br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br><br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    threshold = initialCapacity;<br>    init();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组建一个与指定 map 相同的 HashMap，使用默认负载系数，初始容量足以盛下该 Map。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>    <span class="hljs-comment">// 如果初始容量大于允许的最大容量，则使用最大容量；否则初始容量为指定 Map 的大小除以负载系数后加一</span><br>    <span class="hljs-built_in">this</span>(Math.max((<span class="hljs-type">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="hljs-number">1</span>,<br>                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);<br>    <span class="hljs-comment">// HashMap扩容到指定容量</span><br>    inflateTable(threshold);<br><br>    putAllForCreate(m);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inflates the table.</span><br><span class="hljs-comment"> * 表扩容</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inflateTable</span><span class="hljs-params">(<span class="hljs-type">int</span> toSize)</span> &#123;<br>    <span class="hljs-comment">// Find a power of 2 &gt;= toSize</span><br>    <span class="hljs-comment">// 找到大于 toSize 的最小的2的幂次方的值(因为容量只能为2的幂次方)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> roundUpToPowerOf2(toSize);<br>    <span class="hljs-comment">// 下次扩容时创建表的初始大小</span><br>    threshold = (<span class="hljs-type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[capacity];<br>    initHashSeedAsNeeded(capacity);<br>&#125;<br><span class="hljs-comment">// 寻找大于某个非负数的的最小的2的幂次方的值(eg. roundUpToPowerOf2(5)=8)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">roundUpToPowerOf2</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>    <span class="hljs-comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br>    <span class="hljs-comment">// 断言 number 为非负数</span><br>    <span class="hljs-keyword">return</span> number &gt;= MAXIMUM_CAPACITY<br>            ? MAXIMUM_CAPACITY<br>            : (number &gt; <span class="hljs-number">1</span>) ? Integer.highestOneBit((number - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>) : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 当 number 不小于允许的最大容量时，直接返回最大值；</span><br>    <span class="hljs-comment">// 当 number = 1 时，直接返回 1。</span><br>    <span class="hljs-comment">// 否则返回 Integer.highestOneBit((number - 1) &lt;&lt; 1)：</span><br>    <span class="hljs-comment">// (number - 1) &lt;&lt; 1) = (number - 1)*2</span><br>    <span class="hljs-comment">// Integer.highestOneBit(i): 取 i 这个数的二进制形式最左边的最高一位且高位后面全部补零，最后返回int型的结果。</span><br><br>    <span class="hljs-comment">// 假设 number 值为 5；那么十进制 5 减去 1 之后得 4，4 的二进制带符号左移一位，得十进制 8；8 的二进制为：1000；经过 Integer.highestOneBit 处理后值还是 8。</span><br>    <span class="hljs-comment">// 假设 number 值为 6，那么十进制 6 减去 1 之后得 5，5 的二进制带符号左移一位，得十进制 10；10 的二进制为 1010；取最高位 1，其余 3 位补零，得 1000，即十进制 8。</span><br>&#125;<br><br><span class="hljs-comment">// 再看看 HashMap 的静态内部类 Entry&lt;K,V&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    <span class="hljs-comment">// 只有 next，没有 prev，即单向链</span><br>    Entry&lt;K,V&gt; next;<br>    <span class="hljs-type">int</span> hash;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates new entry.</span><br><span class="hljs-comment">     */</span><br>    Entry(<span class="hljs-type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;<br>        value = v;<br>        next = n;<br>        key = k;<br>        hash = h;<br>    &#125;<br><br>    <span class="hljs-comment">// key 的 getter 方法..略</span><br>    <span class="hljs-comment">// value 的 getter 方法..略</span><br>    <span class="hljs-comment">// value 的 setter 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V newValue)</span> &#123;<br>        <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> value;<br>        value = newValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">// Entry 的 key 和 value 与 o 的 key 和 value 都相等，则return true，否则return false</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (Map.Entry)o;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">k1</span> <span class="hljs-operator">=</span> getKey();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">k2</span> <span class="hljs-operator">=</span> e.getKey();<br>        <span class="hljs-keyword">if</span> (k1 == k2 || (k1 != <span class="hljs-literal">null</span> &amp;&amp; k1.equals(k2))) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> getValue();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> e.getValue();<br>            <span class="hljs-keyword">if</span> (v1 == v2 || (v1 != <span class="hljs-literal">null</span> &amp;&amp; v1.equals(v2)))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getKey() + <span class="hljs-string">&quot;=&quot;</span> + getValue();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is invoked whenever the value in an entry is</span><br><span class="hljs-comment">     * overwritten by an invocation of put(k,v) for a key k that&#x27;s already</span><br><span class="hljs-comment">     * in the HashMap.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordAccess</span><span class="hljs-params">(HashMap&lt;K,V&gt; m)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is invoked whenever the entry is</span><br><span class="hljs-comment">     * removed from the table.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordRemoval</span><span class="hljs-params">(HashMap&lt;K,V&gt; m)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// 如果这是空表，则首先为表进行扩容，threshold 初始值为 DEFAULT_INITIAL_CAPACITY，即 16</span><br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>        inflateTable(threshold);<br>    &#125;<br>    <span class="hljs-comment">// 如果 key 为 null</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 该方法进行的操作与下面对非 null key值的操作逻辑基本一致，只不过是在 for 循环中的 判断条件改为了 e.key == null</span><br>        <span class="hljs-keyword">return</span> putForNullKey(value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-comment">// 通过 Hash 值找到在数组中的索引值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>    <span class="hljs-comment">// 遍历索引指向的单向链表，查看 key 在当前 Map 中是否存在</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        Object k;<br>        <span class="hljs-comment">// 如果 当前 Entry 对象 e 的 hash 值与 key 的 hash 值相等，且 e.key 与 key 相等，则覆盖原有 e.value</span><br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果要插入的 key 在 map 中不存在，，</span><br>    <span class="hljs-comment">// 结构修改次数 ++</span><br>    modCount++;<br>    <span class="hljs-comment">// 在 HashMap 的 Entry 数组中添加新的 Entry 对象</span><br>    addEntry(hash, key, value, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns index for hash code h.</span><br><span class="hljs-comment"> * 找到 hash 值在 table 中的索引值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br>    <span class="hljs-comment">//Integer.bitCount(length) 用于计算十进制 length 值的二进制值中 &#x27;1&#x27; 的个数；Integer.bitCount(length) == 1，即断言 length 值(HashMap 中Entry&lt;?,?&gt;[]的length，即 HashMap capacity)为 2 的幂次方。</span><br>    <br>    <span class="hljs-comment">// 刚开始是没有看明白这行代码的，求助搜索引擎之后，才有些眉目。</span><br>    <span class="hljs-comment">// 首先，这是按位与操作，，因为 length 值为 2 的幂次方，所以 length - 1后，其二进制的值除高位外全为1(eg. 假设length 值为 8(二进制表现为 1000)， 减 1 得 7；7 的二进制为 0111)</span><br>    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds a new entry with the specified key, value and hash code to</span><br><span class="hljs-comment"> * the specified bucket.  It is the responsibility of this</span><br><span class="hljs-comment"> * method to resize the table if appropriate.</span><br><span class="hljs-comment"> * 通过指定的 key、value、hash code 向指定的 bucket 添加一个新的 entry 对象。在适当的时候扩容 table 也是该方法的主要责任。</span><br><span class="hljs-comment"> * Subclass overrides this to alter the behavior of put method.</span><br><span class="hljs-comment"> * 子类重写该方法可以修改 put() 方法的行为。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">addEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>    <span class="hljs-comment">// 如果当前 HashMap 的 size 大于等于扩容临界值，且当前 Entry 不为 null 的时候</span><br>    <span class="hljs-comment">// 当 table 的 capacity 等于 Integer.MAX_VALUE时，int 类型的 size 最多与 threshold(此时 threshold = Integer.MAX_VALUE)相等，而且 null != table[bucketIndex] 肯定为 true。所以，当 table 达到最大容量后，再调用 put() 会一直覆盖原有的值。</span><br>    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-literal">null</span> != table[bucketIndex])) &#123;<br>        <span class="hljs-comment">// 2 倍扩容</span><br>        resize(<span class="hljs-number">2</span> * table.length);<br>        <span class="hljs-comment">// key 为 null，则 hash 值为 0；否则 通过 hash() 方法计算 hash 值</span><br>        hash = (<span class="hljs-literal">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算扩容之后 entry 将要被放在的 bucket 索引</span><br>        bucketIndex = indexFor(hash, table.length);<br>    &#125;<br>    <span class="hljs-comment">// 实际添加 entry 对象的方法</span><br>    createEntry(hash, key, value, bucketIndex);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rehashes the contents of this map into a new array with a</span><br><span class="hljs-comment"> * larger capacity.  This method is called automatically when the</span><br><span class="hljs-comment"> * number of keys in this map reaches its threshold.</span><br><span class="hljs-comment"> * Rehash 当前 map 对象到一个新的更大的数组中去；该方法在 map.size() 达到临界值时自动调用</span><br><span class="hljs-comment"> * If current capacity is MAXIMUM_CAPACITY, this method does not</span><br><span class="hljs-comment"> * resize the map, but sets threshold to Integer.MAX_VALUE.</span><br><span class="hljs-comment"> * This has the effect of preventing future calls.</span><br><span class="hljs-comment"> * 如果当前容量达到允许的最大容量时，该方法不会再进行扩容操作，而是直接将临界值设置为 Integer.MAX_VALUE。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span><br><span class="hljs-comment"> *        must be greater than current capacity unless current</span><br><span class="hljs-comment"> *        capacity is MAXIMUM_CAPACITY (in which case value</span><br><span class="hljs-comment"> *        is irrelevant).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;<br>    Entry[] oldTable = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-comment">// MAXIMUM_CAPACITY = 2^30，即 oldCapacity 最大值为 2^30</span><br>    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<br>        <span class="hljs-comment">// Integer.MAX_VALUE = 2^31 - 1，之后不可能再进行扩容操作了</span><br>        threshold = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newCapacity];<br>    transfer(newTable, initHashSeedAsNeeded(newCapacity));<br>    table = newTable;<br>    threshold = (<span class="hljs-type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Like addEntry except that this version is used when creating entries</span><br><span class="hljs-comment"> * as part of Map construction or &quot;pseudo-construction&quot; (cloning,</span><br><span class="hljs-comment"> * deserialization).  This version needn&#x27;t worry about resizing the table.</span><br><span class="hljs-comment"> * 本方法与 addEntry() 类似，只不过是用于&#x27;伪构造方法时&#x27;(克隆、反序列化)，而且该方法不用担心扩容的问题~</span><br><span class="hljs-comment"> * Subclass overrides this to alter the behavior of HashMap(Map),</span><br><span class="hljs-comment"> * clone, and readObject.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>    <span class="hljs-comment">// 在未发生散列碰撞时，e 为 null；否则 e 为 entry 实例</span><br>    Entry&lt;K,V&gt; e = table[bucketIndex];<br>    <span class="hljs-comment">// 构建新的Entry对象，并其属性 next 指向 e，，即在发生散列碰撞的情况下，每次添加 entry 实例时，都是 insert(添加到单向链开始位置)，而非 append。</span><br>    table[bucketIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<br>    size++;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transfers all entries from current table to newTable.</span><br><span class="hljs-comment"> * 将现在的 table 转移到新的 table中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-type">boolean</span> rehash)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-comment">// 遍历原 Entry 数组中所有对象</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<br>        <span class="hljs-comment">// 遍历每个槽位的 entry 单向链</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123;<br>            <span class="hljs-comment">// ① 👉 记录下 e.next 先</span><br>            Entry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-keyword">if</span> (rehash) &#123;<br>                e.hash = <span class="hljs-literal">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);<br>            &#125;<br>            <span class="hljs-comment">// 计算 e.hash 在新 entry 数组中 bucket 索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity);<br>            <span class="hljs-comment">// ② 👉 将原槽位的 entry 单向链添加到当前 e 的 next 属性中。</span><br>            e.next = newTable[i];<br>            <span class="hljs-comment">// ③ 👉 将 新数组的指定索引的值 指向 拼接过的新的 entry 单向链。</span><br>            newTable[i] = e;<br>            <span class="hljs-comment">// ④ 👉 将之前记录下来的 e.next 值重新赋给 e，开始下一轮循环(类似 for 循环中的 i++)。</span><br>            e = next;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 👆 transfer() 方法中 将while 循环转成 for 循环，①、④ 处可能会更好理解一点； ②、③ 位置不太好理解，我也是反复咀嚼了好多遍才大概明白一点。</span><br><span class="hljs-comment">// eg. 我们假设在索引为 i 的槽位处有个 entry 对象 e0，它链接的 entry 对象结构大概为：e0 -&gt; e1 -&gt; e2 -&gt; e3；现在有个 entry 对象 e，e 的 hash 值在新数组中计算得到的索引值同样为 i(即，散列碰撞)；此时需将 e 添加到 e0 的单向链中，③、④ 操作执行过后，该槽位的单向链结构变为：e -&gt; e0 -&gt; e1 -&gt; e2 -&gt; e3。</span><br></code></pre></td></tr></table></figure>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="@加张图片会不会更容易理解些~"></p>
<h5 id="get-方法👇"><a href="#get-方法👇" class="headerlink" title="get() 方法👇"></a>get() 方法👇</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br> <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> getForNullKey();<br>    Entry&lt;K,V&gt; entry = getEntry(key);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> == entry ? <span class="hljs-literal">null</span> : entry.getValue();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Offloaded version of get() to look up null keys.  Null keys map</span><br><span class="hljs-comment"> * to index 0.  This null case is split out into separate methods</span><br><span class="hljs-comment"> * for the sake of performance in the two most commonly used</span><br><span class="hljs-comment"> * operations (get and put), but incorporated with conditionals in</span><br><span class="hljs-comment"> * others.</span><br><span class="hljs-comment"> * key 值为 null 的指向 map 中 Entry 数组 index 为 0 的 entry 对象。为了更高的性能表现，在 get 和 put 请求中，key 为 null 的情况被分支出单独的方法来处理，但在其他方法中并没有这样去做。</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">private</span> V <span class="hljs-title function_">getForNullKey</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="hljs-number">0</span>]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        <span class="hljs-keyword">if</span> (e.key == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> e.value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">getEntry</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : hash(key);<br>    <span class="hljs-comment">// 遍历指定 index 位置的的单项链</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];<br>         e != <span class="hljs-literal">null</span>;<br>         e = e.next) &#123;<br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove() 方法"></a>remove() 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-comment">// 直接看关键方法</span><br>    Entry&lt;K,V&gt; e = removeEntryForKey(key);<br>    <span class="hljs-keyword">return</span> (e == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value);<br>&#125;<br><br><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">removeEntryForKey</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : hash(key);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>    <span class="hljs-comment">// ①看到这儿时候我是有些懵哔的..</span><br>    Entry&lt;K,V&gt; prev = table[i];<br>    Entry&lt;K,V&gt; e = prev;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        Entry&lt;K,V&gt; next = e.next;<br>        Object k;<br>        <span class="hljs-comment">// ③ 关键在这儿</span><br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;<br>            modCount++;<br>            size--;<br>            <span class="hljs-comment">// ②直到看到了这儿，我意识到我刚才懵逼早了...</span><br>            <span class="hljs-comment">// 由 ① 很容易得出结论啊，妥妥相等</span><br>            <span class="hljs-keyword">if</span> (prev == e)<br>                table[i] = next;<br>            <span class="hljs-keyword">else</span><br>                prev.next = next;<br>            e.recordRemoval(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> e;<br>        &#125;<br>        ④<br>        prev = e;<br>        e = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br><span class="hljs-comment">// 👆在上面的代码中，如果只看①②，会蒙圈的，，关键在③的分支判断。</span><br><span class="hljs-comment">// 在发生散列碰撞(由不同的 key，生成了相同的 hash 值)情况下，e.hash == hash 是成立的，但 (k = e.key) == key 或 key.equals(k)就不成立了。</span><br><span class="hljs-comment">// eg. 如果要删除的单向链节点在链的开头，则直接走 (prev == e) 分支，将 table[i] 指向 其 next 属性的节点；如果要删除的单向链节点位于第二，则在直接将第一个节点的 next 属性指向第 3 个节点即可。</span><br></code></pre></td></tr></table></figure>
<h5 id="entrySet-方法"><a href="#entrySet-方法" class="headerlink" title="entrySet() 方法"></a>entrySet() 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a &#123;<span class="hljs-doctag">@link</span> Set&#125; view of the mappings contained in this map.</span><br><span class="hljs-comment"> * The set is backed by the map, so changes to the map are</span><br><span class="hljs-comment"> * reflected in the set, and vice-versa.  If the map is modified</span><br><span class="hljs-comment"> * while an iteration over the set is in progress (except through</span><br><span class="hljs-comment"> * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span><br><span class="hljs-comment"> * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span><br><span class="hljs-comment"> * iterator) the results of the iteration are undefined.  The set</span><br><span class="hljs-comment"> * supports element removal, which removes the corresponding</span><br><span class="hljs-comment"> * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span><br><span class="hljs-comment"> * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span><br><span class="hljs-comment"> * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span><br><span class="hljs-comment"> * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span><br><span class="hljs-comment"> * 返回当前 map 键值对映射的 set 快照(??)。该集合由 map 支持，所以对 map 的修改会反映到 set中，反之亦然。</span><br><span class="hljs-comment"> * 如果 map 在 set 迭代的过程中被修改(除了迭代器本身的remove()和迭代器返回的 map entry的 setValue()操作)话，其结果是未知(??)的。</span><br><span class="hljs-comment"> * set 支持移除元素， Set.remove(),removeAll(), retainAll() 和 clear() 会直接影响到相关的 map。set 不知道 add()和 addAll() 操作。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a set view of the mappings contained in this map</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;<br>    <span class="hljs-keyword">return</span> entrySet0();<br>&#125;<br>(实测，在 <span class="hljs-keyword">for</span>(Map.Entry&lt;String,String&gt; m:map.entrySet()) 循环中，通过 map.put() 方法放入新的值，会抛出 ConcurrentModificationException：👇<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.ConcurrentModificationException<br>    at java.util.HashMap$HashIterator.nextEntry(HashMap.java:<span class="hljs-number">922</span>)<br>    at java.util.HashMap$EntryIterator.next(HashMap.java:<span class="hljs-number">962</span>)<br>    at java.util.HashMap$EntryIterator.next(HashMap.java:<span class="hljs-number">960</span>)<br>    at Test.main(Test.java:<span class="hljs-number">12</span>)<br>如果放入 map 中已存在的 key，不会抛出 ConcurrentModificationException。)<br><br> <span class="hljs-keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;<br>    Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;<br>    <span class="hljs-keyword">return</span> es != <span class="hljs-literal">null</span> ? es : (entrySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntrySet</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里之后是有点儿懵的，，因为 entrySet0() 方法中第一行代码，<code>entrySet</code>在 HashMap 中是这样<span id="entrySetAnnounce">声明</span>的：👇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>
<p>之后在其他地方没有明确对其进行赋值的代码，然鹅我们在 <code>Test</code> 类进行 <code>for(Map.Entry&lt;String,String&gt; m: map.entrySet())</code> 循环时，<code>entrySet</code>明明是有值的。那么 <code>map.entrySet()</code> 到底是在什么时候进行赋值的呢？！这个问题困扰了我很久，在 HashMap 显式继承的 AbstractMap 类和实现的 Map&lt;K,V&gt; 接口中，也没有找到答案。出门遛了一圈，突然想到了 <code>Test</code> 类被编译之后的 class 文件！！然后用 JD-JUI 反编译之后，终于有些发现了：👇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// class 文件反编译之后的 forEach 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">Iterator</span> <span class="hljs-variable">i$</span> <span class="hljs-operator">=</span> map.entrySet().iterator(); i$.hasNext(); localEntry = (Map.Entry)i$.next())<br></code></pre></td></tr></table></figure>
<p>👆我们可以看到，虽说用的是 forEach 循环，但在编译之后还是通过 Iterator 迭代器进行遍历的。首先初始条件 <code>Iterator i$ = map.entrySet().iterator()</code>，我们可以看到  <code>map.entrySet()</code> 返回的是一个 <code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code>，所以其 <code>iterator()</code> 是 <code>Set</code> 接口实现类的 <code>iterator()</code> 方法。我们继续看 <code>entrySet0()</code> 方法的第二行代码，在 <code>entrySet</code> 为空的情况下，会初始化一个新的 <code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code> 对象，即 <code>new EntrySet()</code>，我们看看 <code>EntrySet</code> 类：👇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntrySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;<br>        <span class="hljs-keyword">return</span> newEntryIterator();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;<br>        Entry&lt;K,V&gt; candidate = getEntry(e.getKey());<br>        <span class="hljs-keyword">return</span> candidate != <span class="hljs-literal">null</span> &amp;&amp; candidate.equals(e);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> removeMapping(o) != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        HashMap.<span class="hljs-built_in">this</span>.clear();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// EntrySet 类集成了 AbstractSet 类，而 AbstractSet 类又实现了 Set&lt;E&gt; 接口，那么 EntrySet 类中的 iterator() 方法就是我们要找的。我们继续顺着往下看 newEntryIterator ：👇</span><br>Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntryIterator</span>();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;<br>    <span class="hljs-keyword">public</span> Map.Entry&lt;K,V&gt; <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextEntry();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 形式渐渐明朗，，再看 nextEntry()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    Entry&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span><br>    <span class="hljs-type">int</span> expectedModCount;   <span class="hljs-comment">// For fast-fail</span><br>    <span class="hljs-type">int</span> index;              <span class="hljs-comment">// current slot</span><br>    Entry&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span><br><br>    HashIterator() &#123;<br>        expectedModCount = modCount;<br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span><br>            Entry[] t = table;<br>            <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>)<br>                ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> next != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">nextEntry</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        Entry&lt;K,V&gt; e = next;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br><br>        <span class="hljs-keyword">if</span> ((next = e.next) == <span class="hljs-literal">null</span>) &#123;<br>            Entry[] t = table;<br>            <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>)<br>                ;<br>        &#125;<br>        current = e;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> current.key;<br>        current = <span class="hljs-literal">null</span>;<br>        HashMap.<span class="hljs-built_in">this</span>.removeEntryForKey(k);<br>        expectedModCount = modCount;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 至此，所有问题解决~ 在 Iterator i$ = map.entrySet().iterator() 中，i$ 为 HashIterator，i$.hasNext() 调用的是 HashIterator.hasNext()，(Map.Entry)i$.next() 调用的是 EntryIterator.next()，而 EntryIterator.next() 最终还是调用了 HashIterator.nextEntry()。</span><br></code></pre></td></tr></table></figure>

<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 2019-04-02.update</p>
<p>上个月末的时候，花了一个晚上更新了下简历，但并没有到处去投，只是对外可见。陆陆续续开始有公司接触，其中还接到一个电话面试，，是某外包公司的。突如其来的电话面试，有点仓促，但好在前端时间也一直在看书恶补。其中有个很基础的问题，，『简单说下 Java 集合框架各容器类之间的关系』。多亏了学习 『Redis 核心历险』时，对 <a target="_blank" rel="noopener" href="https://someoneiscoding.com/2019/03/17/about_LinkedList/">LinkedList</a> 多看了一眼，也经受住了超越妹妹的考验。当中面试官特地提到 <code>Map</code> 和 <code>Collection</code> 有没有关系? 可以确定是肯定有关系，但有什么关系呢？没有答上来。。那时还没有整理 HashMap 这篇文章，只有 LinkedList。其实在整理这篇文章时也没找到两者之间的关系，因为 <code>interface Map&lt;K,V&gt;</code> 与 <code>interface Collection&lt;E&gt;</code>并没有直接的继承关系。。这时候需要感谢的是『码出高效 Java 开发手册』了，平时把这本书放在了床头，睡前会翻一翻<del>从此再无失眠</del>，并没有从第一张开始读，而是直接挑了最薄弱的数据结构与集合这一章。</p>
<p>OK，下面来说说 <code>Map</code> 和 <code>Collection</code> 的关系！在书中是这样描述的: 👇</p>
<blockquote>
<p>在数据元素的存储、查找、修改和遍历中，Java 中的 Map 类集合都与 Collection 类集合存在很大的不同。它是与 Collection 类平级的一个接口，在集合框架图上，它有一条微弱的依赖线月 Collection 类产生联系，那是因为<strong>部分方法返回 Collection 视图，比如 values() 方法返回的所有 values 的列表</strong></p>
</blockquote>
<p>我们先看 <code>Map</code> 接口的 <code>values()</code> 方法：👇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Map 接口类</span><br>Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p>非常明显，，说到<code>values()</code>方法，肯定会想到 <code>keySet()</code> 和 <code>entrySet()</code> ，毕竟这三个方法在 <code>HashMap</code> 迭代的时候可是肩并肩的~👇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Map 接口类</span><br>Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span>;<br>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();<br></code></pre></td></tr></table></figure>
<p>我们再看看，这三个方法在 <code>HashMap</code> 中的实现~ 👇</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// values 方法</span><br><span class="hljs-keyword">public</span> Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span> &#123;<br>    Collection&lt;V&gt; vs = values;<br>    <span class="hljs-keyword">return</span> (vs != <span class="hljs-literal">null</span> ? vs : (values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Values</span>()));<br>&#125;<br><span class="hljs-comment">// Values 类，AbstractCollection 类实现类了 Collection 接口</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Values</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;V&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> newValueIterator();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> containsValue(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        HashMap.<span class="hljs-built_in">this</span>.clear();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// keySet 方法</span><br><span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span> &#123;<br>    Set&lt;K&gt; ks = keySet;<br>    <span class="hljs-keyword">return</span> (ks != <span class="hljs-literal">null</span> ? ks : (keySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeySet</span>()));<br>&#125;<br><span class="hljs-comment">// KeySet 类，abstract class AbstractSet&lt;E&gt; 继承了 AbstractCollection&lt;E&gt; 实现了 Set&lt;E&gt;，而抽象类 AbstractCollection 和 Set 接口 都继承了 Collection 接口。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;K&gt; &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;K&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> newKeyIterator();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> containsKey(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> HashMap.<span class="hljs-built_in">this</span>.removeEntryForKey(o) != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        HashMap.<span class="hljs-built_in">this</span>.clear();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 至于 entrySet() 方法，我们在分析 HashMap 的 forEach 循环时已经挖过源码了。EntrySet 类与 KeySet 类一样，都继承了 AbstractSet 抽象类。</span><br></code></pre></td></tr></table></figure>



<ol>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/30543726">米一–Hash表的前世今生</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/j1231230/article/details/78072115">追逐盛夏流年–HashMap中的indexFor方法分析</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/strivenoend/article/details/80397825">March@dhyin.top--hashmap的实现原理 数组 entry</a></li>
<li><a target="_blank" rel="noopener" href="http://www.cnblogs.com/sanjianghuiliu/p/6524895.html">哈希拉链法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Capricorn-HCL/articles/5039123.html">贝壳风铃–Java遍历HashMap并修改(remove)</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>请我一杯咖啡吧！</div>
  <button>
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="小哪吒 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="小哪吒 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/%E6%BA%90%E7%A0%81/" rel="tag"># 源码</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/HashMap/" rel="tag"># HashMap</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/03/17/2018_12_week_1st/" rel="prev" title="2018_12_week_1st">
                  <i class="fa fa-chevron-left"></i> 2018_12_week_1st
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/04/03/about_ArrayList/" rel="next" title="关于 ArrayList">
                  关于 ArrayList <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">冀ICP备18000816号 </a>
      <img src="/images/beian_icon.png" alt="">
  </div>
  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">小哪吒</span>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
