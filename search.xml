<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2017_12—第一周</title>
    <url>/2017/12/10/2017_12_week_1st/</url>
    <content><![CDATA[<h4 id="2017-12-04"><a href="#2017-12-04" class="headerlink" title="2017-12-04"></a>2017-12-04</h4><ul>
<li><p><strong>幂等</strong>：<em>idempotent idempotence</em> 是一个数学与计算机学概念，常见于抽象代数中。<br><strong>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同</strong>。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.</p>
</li>
<li><p><strong>scaffold</strong> 英[ˈskæfəʊld]   美[ˈskæfoʊld]<br>n.  脚手架; &lt;史&gt;断头台;<br>[例句]Moore ascended the scaffold and addressed the executioner.<br>穆尔走上断头台，和刽子手说话。</p>
</li>
</ul>
<h4 id="2017-12-05"><a href="#2017-12-05" class="headerlink" title="2017-12-05"></a>2017-12-05</h4><ul>
<li><p><strong>stumbled</strong>	英 [ˈstʌmbl]   美 [ˈstʌmbəl]<br>v.	（不顺畅地） 说( stumble的过去式和过去分词 ); 跌跌撞撞地走; 绊脚; （说话、演奏等） 出错;<br>[例句]She stumbled and fell, scraping her palms and knees.<br>她绊了一下摔倒了，手掌和膝盖都蹭破了。</p>
</li>
<li><p>*<em>reserved</em>  英[rɪˈzɜ:vd]   美[rɪˈzɜ:rvd]<br>adj.    预订的; 矜持的; 储藏着的;<br>v.  保留[储备]某物( reserve的过去式);<br>[例句]He was unemotional, quite quiet, and reserved<br>他感情淡漠，沉默寡言，性格内敛。</p>
</li>
<li><p>keyword 关键字<br>reserved word 保留字</p>
</li>
<li><p><strong>literal</strong>  英[ˈlɪtərəl]   美[ˈlɪtərəl]<br>adj.    照字面的; 原义的; 逐字的; 平实的，避免夸张;<br>n.  [印] 错排，文字上的错误;<br>[例句]In many cases, the people there are fighting, in a literal sense, for their homes.<br>很多情况下，那里的人们是真刀真枪地在为家园而抗争。</p>
</li>
<li><p><strong>anonymous</strong>  英[əˈnɒnɪməs]   美[əˈnɑ:nɪməs]<br>adj.    匿名的; 无名的; 假名的; 没有特色的;<br>[例句]You can remain anonymous if you wish<br>你愿意的话可以不透露姓名。</p>
</li>
</ul>
<h4 id="2017-12-07"><a href="#2017-12-07" class="headerlink" title="2017-12-07"></a>2017-12-07</h4><ul>
<li><strong>categories</strong>  英[‘kætɪɡərɪz]   美[‘kætɪɡərɪz]<br>n.	种类，类别( category的名词复数 ); 派别;<br>[例句]The verbs were subdivided into transitive and intransitive categories.<br>动词可细分为及物动词和不及物动词。</li>
</ul>
<h4 id="2017-12-08"><a href="#2017-12-08" class="headerlink" title="2017-12-08"></a>2017-12-08</h4><ul>
<li><strong>favicon</strong>  英[‘fævɪkən]   美[‘fævɪkən]<br>abbr.	偏爱图标; 网站图标(favorites icon);</li>
</ul>
<h4 id="2017-12-10"><a href="#2017-12-10" class="headerlink" title="2017-12-10"></a>2017-12-10</h4><ul>
<li><p><strong>anchor</strong>  英[ˈæŋkə(r)]   美[ˈæŋkɚ]<br>n.  锚; 锚状物; 靠山; 压阵队员;<br>vt. 抛锚，抛锚泊船; 使固定，使稳固; 使稳定; 在…任节目主持人;<br>vi. 固定; 抛锚，停泊; [体] 任主要运动员; 主持节目;<br>[例句]We could anchor off the pier<br>我们可以在码头附近下锚停泊。</p>
</li>
<li><p><strong>stickler</strong>	英[ˈstɪklə(r)]   美[‘stɪklər]<br>n.	坚持…的人;<br>[例句]I’m a bit of a stickler for accuracy<br>我总是要求精确。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>幂等</tag>
        <tag>单词</tag>
      </tags>
  </entry>
  <entry>
    <title>2017_12-第二周</title>
    <url>/2017/12/13/2017_12_week_2nd/</url>
    <content><![CDATA[<h4 id="2017-12-第二周"><a href="#2017-12-第二周" class="headerlink" title="2017_12-第二周"></a>2017_12-第二周</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var a = a || &#123;&#125;<br></code></pre></td></tr></table></figure>
<p>👆等价于👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var a;<br>function(a)&#123;<br>    if(a === 0 || a === &quot;&quot; || a === false || a === null || a === undefined) a = &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在之前固有的印象中，逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>都是出现在<code>if</code>条件语句中，一般用来做判断条件使用，<code>if()</code>括号中会依据<code>a==1 || b!=1</code>表达式的返回值<code>true</code>or<code>false</code>来做判断。👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">if(a==1 || b!=1)&#123;<br>    //do something;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>猛然间看到<code>var a = a || &#123;&#125;</code>有些无措，，后来得知，**<code>||</code>返回的不是<code>boolean</code>值<code>true</code>or<code>false</code>，而是两边的表达式**！比如<code>a==1</code>和<code>b!=1</code>,因为双目运算符的运算优先级高于逻辑或，所以最终返回的是表达的值。</p>
<hr>
<p>TTFB:Time To First Byte<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131849-TTFB.png" alt="TTFB"></p>
<p><code>请求发送：本机——&gt;运营商路由——&gt;服务器</code><br><code>收到响应：服务器——&gt;运营商路由——&gt;本机</code></p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>逻辑或</tag>
        <tag>TTFB</tag>
      </tags>
  </entry>
  <entry>
    <title>2017_12-第三周</title>
    <url>/2017/12/19/2017_12_week_3rd/</url>
    <content><![CDATA[<h3 id="2017-12-第三周"><a href="#2017-12-第三周" class="headerlink" title="2017_12-第三周"></a>2017_12-第三周</h3><h4 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a><code>const</code>关键字</h4><p><strong><code>const</code></strong>:此声明创建一个常量，其作用域可以是全局或本地声明的块。 与<code>var</code>变量不同，全局常量不会变为窗口对象(widows)的属性。需要一个常数的初始化器；也就是说，您<strong>必须在声明的同一语句中指定它的值</strong>（这是有道理的，因为以后不能更改）。</p>
<p><strong>const声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。</strong>例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const">^1</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// 注意: 常量在声明的时候可以使用大小写，但通常情况下全部用大写字母。 <br><br>// 定义常量MY_FAV并赋值7<br>const MY_FAV = 7;<br><br>// 报错<br>MY_FAV = 20;<br><br>// 输出 7<br>console.log(&quot;my favorite number is: &quot; + MY_FAV);<br><br>// 尝试重新声明会报错 <br>const MY_FAV = 20;<br><br>//  MY_FAV 保留给上面的常量，这个操作会失败<br>var MY_FAV = 20; <br><br>// 也会报错<br>let MY_FAV = 20;<br><br>// 注意块范围的性质很重要<br>if (MY_FAV === 7) &#123; <br>    // 没问题，并且创建了一个块作用域变量 MY_FAV<br>    // (works equally well with let to declare a block scoped non const variable)<br>    let MY_FAV = 20;<br><br>    // MY_FAV 现在为 20<br>    console.log(&#x27;my favorite number is &#x27; + MY_FAV);<br><br>    // 这被提升到全局上下文并引发错误<br>    var MY_FAV = 20;<br>&#125;<br><br>// MY_FAV 依旧为7<br>console.log(&quot;my favorite number is &quot; + MY_FAV);<br><br>// 常量要求一个初始值<br>const FOO; // SyntaxError: missing = in const declaration<br><br>// 常量可以定义成对象<br>const MY_OBJECT = &#123;&quot;key&quot;: &quot;value&quot;&#125;;<br><br>// 重写对象和上面一样会失败<br>MY_OBJECT = &#123;&quot;OTHER_KEY&quot;: &quot;value&quot;&#125;;<br><br>// 对象属性并不在保护的范围内，下面这个声明会成功执行<br>MY_OBJECT.key = &quot;otherValue&quot;;<br><br>// 也可以用来定义数组<br>const MY_ARRAY = [];<br>// It&#x27;s possible to push items into the array<br>// 可以向数组填充数据<br>MY_ARRAY.push(&#x27;A&#x27;); // [&quot;A&quot;]<br>// 但是，将一个新数组赋给变量会引发错误<br>MY_ARRAY = [&#x27;B&#x27;]<br></code></pre></td></tr></table></figure>
<hr>
<h4 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a><code>let</code>关键字</h4><p><code>let</code>语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let">^2</a></p>
<h5 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h5><p><code>let</code>声明的变量只在其声明的块或子块中可用，这一点，与<code>var</code>相似。二者之间最主要的区别在于<code>var</code>声明的变量的作用域是整个封闭函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function varTest() &#123;<br>    var x = 1;<br>    if (true) &#123;<br>      var x = 2;  // 同样的变量!<br>      console.log(x);  // 2<br>    &#125;<br>    console.log(x);  // 2<br>&#125;<br><br>function letTest() &#123;<br>    let x = 1;<br>    if (true) &#123;<br>        let x = 2;  // 不同的变量<br>        console.log(x);  // 2<br>    &#125;<br>    console.log(x);  // 1<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="简化内部函数代码"><a href="#简化内部函数代码" class="headerlink" title="简化内部函数代码"></a>简化内部函数代码</h5><p>当用到内部函数的时候，let会让你的代码更加简洁，，对比之前[立即执行函数表达式(IIFE)]。(<a href="https://someoneiscoding.github.io/2017/12/10/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%28IIFE%29/#iife">https://someoneiscoding.github.io/2017/12/10/%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%28IIFE%29/#iife</a>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var list = document.getElementById(&#x27;list&#x27;);<br><br>for (let i = 1; i &lt;= 5; i++) &#123;<br>    let item = document.createElement(&#x27;li&#x27;);<br>    item.appendChild(document.createTextNode(&#x27;Item &#x27; + i));<br><br>    item.onclick = function(ev) &#123;<br>        console.log(&#x27;Item &#x27; + i + &#x27; is clicked.&#x27;);<br>     &#125;;<br>     list.appendChild(item);<br>&#125;<br><br>// to achieve the same effect with &#x27;var&#x27;<br>// you have to create a different context<br>// using a closure to preserve the value<br>// 要用var关键字实现同样的功能，你不得不使用闭包来维护不同的上下文环境以保护值(不被改变)。<br>for (var i = 1; i &lt;= 5; i++) &#123;<br>    var item = document.createElement(&#x27;li&#x27;);<br>    item.appendChild(document.createTextNode(&#x27;Item &#x27; + i));<br><br>    (function(i)&#123;<br>        item.onclick = function(ev) &#123;<br>            console.log(&#x27;Item &#x27; + i + &#x27; is clicked.&#x27;);<br>        &#125;;<br>    &#125;)(i);<br>    list.appendChild(item);<br>&#125;<br></code></pre></td></tr></table></figure>
<p> ↑ 以上示例的工作原理是因为（匿名）内部函数的五个实例引用了变量i的五个不同实例。注意，如果你将<code>let</code>替换为<code>var</code>，则它将无法正常工作，因为所有内部函数都将返回相同的<code>i=6</code>的最终值。此外，我们可以通过将创建新元素的代码移动到每个循环的作用域来保持循环更清晰。</p>
<p>在程序或者函数的顶层，<code>let</code>并不会像<code>var</code>一样在全局对象上创造一个属性，比如：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var x = &#x27;global&#x27;;<br>let y = &#x27;global&#x27;;<br>console.log(this.x); // &quot;global&quot;<br>console.log(this.y); // undefined<br></code></pre></td></tr></table></figure>
<h5 id="let暂存死区的错误"><a href="#let暂存死区的错误" class="headerlink" title="let暂存死区的错误"></a><code>let</code>暂存死区的错误</h5><p>在 ECMAScript 2015 中，<code>let</code>绑定不受变量提升的约束，这意味着<code>let</code>声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致<code>ReferenceError</code>（而使用<code>var</code>声明变量则恰恰相反，该变量的值是<code>undefined</code>）。该变量处于从块开始到初始化处理的“暂存死区”。👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function do_something() &#123;<br>    console.log(bar); // undefined<br>    console.log(foo); // ReferenceError: foo is not defined<br>    var bar = 1;<br>    let foo = 2;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于词法作用域，表达式<code>(foo + 55)</code>内的标识符<code>foo</code>会解析为<code>if</code>块的<code>foo</code>，而不是覆盖值为33的<code>foo</code>。在这一行中，<code>if</code>块的<code>foo</code>已经在词法环境中创建，但尚未达到（并终止）其初始化（这是语句本身的一部分）：它仍处于暂存死区。👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function test()&#123;<br>     var foo = 33;<br>     if (true) &#123;<br>        let foo = (foo + 55); // ReferenceError<br>     &#125;<br>&#125;<br>test();<br></code></pre></td></tr></table></figure>

<h4 id="字面量-Literals"><a href="#字面量-Literals" class="headerlink" title="字面量 (Literals)"></a>字面量 (Literals)</h4><p>(译注：字面量是由语法表达式定义的常量；或，通过由一定字词组成的语词表达式定义的常量)<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types">^3</a></p>
<p>在JavaScript中，你可以使用各种字面量。这些字面量是脚本中按字面意思给出的固定的值，而不是变量。（译注：字面量是常量，其值是固定的，而且在程序脚本运行中不可更改，比如false，3.1415，thisIsStringOfHelloworld ，invokedFunction:myFunction(“myArgument”)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fish = [&quot;Lion&quot;, , &quot;Angel&quot;];<br></code></pre></td></tr></table></figure>
<p>👆在这个数组中，有两个已被赋值的元素，和一个空元素（fish[0]是”Lion”，fish[1]是undefined，而fish[2]是”Angel”；译注：此时数组的长度属性fish.length是3)。</p>
<p>如果你在元素列表的尾部添加了一个逗号，它将会被忽略。在下面的例子中，数组的长度是3，并不存在myList[3]这个元素（译注：这是指数组的第4个元素噢，作者是在帮大家复习数组元素的排序命名方法）。元素列表中其它所有的逗号都表示一个新元素（的开始）。👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var myList = [&#x27;home&#x27;, , &#x27;school&#x27;, ];<br>// 尾部的逗号在早期版本的浏览器中会产生错误，因而编程时的最佳实践方式就是移除它们。<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="2017-12-20"><a href="#2017-12-20" class="headerlink" title="2017-12-20"></a>2017-12-20</h4><p>ci:Case Insensitive, 即 “大小写不敏感”, a 和 A 会在字符判断中会被当做一样的。<br>utf8_unicode_ci和utf8_general_ci对中、英文来说没有实质的差别。<br>utf8_general_ci校对速度快，但准确度稍差。<br>utf8_unicode_ci准确度高，但校对速度稍慢。</p>
<p>如果你的应用有德语、法语或者俄语，请一定使用utf8_unicode_ci。一般用utf8_general_ci就够了。</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>var</tag>
        <tag>let</tag>
        <tag>const</tag>
        <tag>字面量</tag>
        <tag>literals</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>2018_03-第3周</title>
    <url>/2018/03/16/2018_03_week_3rd/</url>
    <content><![CDATA[<h3 id="2018-03-第三周"><a href="#2018-03-第三周" class="headerlink" title="2018-03-第三周"></a>2018-03-第三周</h3><p>又到周五了，，今天手头的工作差不多告一段落了，趁着热乎劲儿赶紧把这两天遇到的问题记录一下~</p>
<h4 id="jQuery中-load-动态加载页面脚本调试"><a href="#jQuery中-load-动态加载页面脚本调试" class="headerlink" title="jQuery中$.load()动态加载页面脚本调试"></a>jQuery中$.load()动态加载页面脚本调试</h4><p><span id="dynamicDebug"></span><br>you know，我是一个写前端的Java程序员。。<br>最近在做后台的数据表格页面时遇到一个问题，，大家应该都见过类似的后台<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901135914-backstage.png" alt="后台页面"><br>点击白色框选地方的菜单项，右侧动态加载相应的内容，，每一个菜单项有一个点击事件，像这样👇</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript:clickMenu(&#x27;#(menu.url)&#x27;)&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// url为相对路径地址，最终指向某个html页面</span><br><span class="hljs-comment">// #mainContent指向右侧主页面</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">clickMenu</span>(<span class="hljs-params">url</span>)&#123;<br>    $(<span class="hljs-string">&#x27;#mainContent&#x27;</span>).<span class="hljs-title function_">load</span>(url);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>正常来说，如果我们想要调试页面中的JavaScript代码，只需要 Cmd+Alt+I 调出Chrome DevTools，选择 source，找到相应的代码段，添加断点即可。但是，，以$.load()的方式动态加载的页面在Source中根本无法找到。。这 就尴尬了！！！难道只能在页面javaScript代码段中手码<code>debugger</code>？！惨无人道！一点也不优雅！！<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901135914-breakpoint-u.png" alt="常规打断点"></p>
<p>一番求索，终于看到了希望，，在<a href="https://stackoverflow.com/questions/9092125/how-to-debug-dynamically-loaded-javascript-with-jquery-in-the-browsers-debugg">Stack Overflow</a>[^1]找到了类似的问题，，顺藤摸瓜，找到了一个唤作<a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl">sourceURL</a>的东东，,只需要在要载入的页面中javascript代码添加一句<code>//# sourceURL=jsName.js</code>即可，然后就可以在 source 中找到了，接下来就可以愉快的打断点啦~👇<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901135915-source-url.png" alt="sourceURL"></p>
<p>另外，，我们可以再深入挖掘一下下，比如了解下阮一峰老师写的<a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">JavaScript Source Map 详解</a>，看到日期着实尴尬了下，2013年就有了，而我2018年才第一次见到，，介，也许就是传说中的差距。。</p>
<h4 id="jqGrid中将导航栏复制到表格上方"><a href="#jqGrid中将导航栏复制到表格上方" class="headerlink" title="jqGrid中将导航栏复制到表格上方"></a>jqGrid中将导航栏复制到表格上方</h4><p>在<a href="#dynamicDebug">jQuery中$.load()动态加载页面脚本调试</a>中的第一张偏中，主页面表格左下角的导航栏是一些常见的操作，比如添加、删除、编辑、搜索和刷新，，但是放在左下角的话，着实不太方便。控制好表格的高度还好一些，不用像下滑动直接就能在左下角找到这些操作入口。但是，如果控制不好高度的话，还要将页面滑到底部，，这体验，相当不好，，如果用户首次登陆后台的话，可能会懵『卧槽，怎么添加数据？！！咋操作？？？』。我一直觉得不需要产品使用说明的设计才是好设计，，这样，把常用操作放在表格左上角，效果马上不一样了~</p>
<p>在导航栏的设置项中，找到了<code>cloneToTop</code>选项，但是设置为<code>true</code>后，导航栏并没有cloneToTop..<br>在初始化设置项中找到了<code>toppager</code>，将值改为<code>true</code>之后，呦，的确上去了，，像这样<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901135915-jqgrid-toolbar1.png" alt="jqgrid-toolbar-1"></p>
<p>唯独导航栏没有上去！！！可恶，，于是又是一番求索，有成果~<br>原来，，设置<code>cloneToTop</code>的前提是<code>toppager</code>的值为<code>true</code>，，所以，接下来变成了这样👇<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901135915-jqgrid-toolbar2.png" alt="jqgrid-toolbar-2"></p>
<p>然后只需将分页和统计相关的div remove()就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#merchantTable_toppager_center&quot;</span>).<span class="hljs-title function_">remove</span>();<br>$(<span class="hljs-string">&quot;#merchantTable_toppager_right&quot;</span>).<span class="hljs-title function_">remove</span>();<br><br><span class="hljs-comment">// 我将这两行代码放在了 loadComplete 回调函数中。</span><br></code></pre></td></tr></table></figure>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901135915-jqgrid-toolbar3.png" alt="jqgrid-toolbar-3"></p>
<p>完美~</p>
<hr>
<p>参考链接：</p>
<h6 id="关于Source-Map动态调试"><a href="#关于Source-Map动态调试" class="headerlink" title="关于Source Map动态调试"></a>关于Source Map动态调试</h6><ol>
<li><a href="https://stackoverflow.com/questions/9092125/how-to-debug-dynamically-loaded-javascript-with-jquery-in-the-browsers-debugg">https://stackoverflow.com/questions/9092125/how-to-debug-dynamically-loaded-javascript-with-jquery-in-the-browsers-debugg</a></li>
<li><a href="https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl">https://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html">http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html</a></li>
</ol>
<h6 id="关于jqGrid导航栏复制到表格上方"><a href="#关于jqGrid导航栏复制到表格上方" class="headerlink" title="关于jqGrid导航栏复制到表格上方"></a>关于jqGrid导航栏复制到表格上方</h6><ol>
<li><a href="https://stackoverflow.com/questions/3929896/adding-jqgrid-custom-navigation-to-top-toolbar">https://stackoverflow.com/questions/3929896/adding-jqgrid-custom-navigation-to-top-toolbar</a></li>
<li><a href="https://stackoverflow.com/questions/3552855/add-toolbar-in-the-bottom-of-the-header-using-jqgrid/3557663#3557663">https://stackoverflow.com/questions/3552855/add-toolbar-in-the-bottom-of-the-header-using-jqgrid/3557663#3557663</a></li>
</ol>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>Source Map</tag>
        <tag>jqGrid</tag>
        <tag>Chrome DevTools</tag>
      </tags>
  </entry>
  <entry>
    <title>2018年11月第三周</title>
    <url>/2018/11/20/2018_11_week_3rd/</url>
    <content><![CDATA[<h4 id="shadowssocks日志级别配置"><a href="#shadowssocks日志级别配置" class="headerlink" title="shadowssocks日志级别配置"></a>shadowssocks日志级别配置</h4><h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>这个，，闲得无聊，看了看<code>shadowsocks.log</code>文件👇</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"># 江湖险恶啊，，请求IP地址处理了下下。<br><span class="hljs-number">2018</span>-<span class="hljs-number">11</span>-<span class="hljs-number">20</span> <span class="hljs-number">07</span>:<span class="hljs-number">45</span>:<span class="hljs-number">21</span> INFO     connecting mtalk.google.com:<span class="hljs-number">5228</span> from <span class="hljs-number">1</span>*<span class="hljs-number">4</span>.<span class="hljs-number">2</span>*<span class="hljs-number">6</span>.<span class="hljs-number">2</span>*<span class="hljs-number">0</span>.<span class="hljs-number">10</span>:<span class="hljs-number">42373</span><br><span class="hljs-number">2018</span>-<span class="hljs-number">11</span>-<span class="hljs-number">20</span> <span class="hljs-number">07</span>:<span class="hljs-number">46</span>:<span class="hljs-number">21</span> INFO     connecting mtalk.google.com:<span class="hljs-number">5228</span> from <span class="hljs-number">1</span>*<span class="hljs-number">4</span>.<span class="hljs-number">2</span>*<span class="hljs-number">6</span>.<span class="hljs-number">2</span>*<span class="hljs-number">0</span>.<span class="hljs-number">10</span>:<span class="hljs-number">42376</span><br><span class="hljs-number">2018</span>-<span class="hljs-number">11</span>-<span class="hljs-number">20</span> <span class="hljs-number">07</span>:<span class="hljs-number">46</span>:<span class="hljs-number">39</span> INFO     connecting notifications.google.com:<span class="hljs-number">443</span> from <span class="hljs-number">1</span>*<span class="hljs-number">4</span>.<span class="hljs-number">2</span>*<span class="hljs-number">6</span>.<span class="hljs-number">2</span>*<span class="hljs-number">0</span>.<span class="hljs-number">10</span>:<span class="hljs-number">42377</span><br><span class="hljs-number">2018</span>-<span class="hljs-number">11</span>-<span class="hljs-number">20</span> <span class="hljs-number">07</span>:<span class="hljs-number">47</span>:<span class="hljs-number">22</span> INFO     connecting mtalk.google.com:<span class="hljs-number">5228</span> from <span class="hljs-number">1</span>*<span class="hljs-number">4</span>.<span class="hljs-number">2</span>*<span class="hljs-number">6</span>.<span class="hljs-number">2</span>*<span class="hljs-number">0</span>.<span class="hljs-number">10</span>:<span class="hljs-number">42239</span><br><span class="hljs-number">2018</span>-<span class="hljs-number">11</span>-<span class="hljs-number">20</span> <span class="hljs-number">07</span>:<span class="hljs-number">47</span>:<span class="hljs-number">58</span> INFO     connecting clients4.google.com:<span class="hljs-number">443</span> from <span class="hljs-number">1</span>*<span class="hljs-number">4</span>.<span class="hljs-number">2</span>*<span class="hljs-number">6</span>.<span class="hljs-number">2</span>*<span class="hljs-number">0</span>.<span class="hljs-number">10</span>:<span class="hljs-number">42346</span><br></code></pre></td></tr></table></figure>
<p>日志信息中没啥特别有用的信息，，关键是这么长时间了，日志文件已经很大了👇</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@host ~]<span class="hljs-comment"># ls -lh /var/log/shadowsocks.log</span><br>-rw-r--r-- 1 root root 56M Nov 20 08:21 /var/log/shadowsocks.log<br></code></pre></td></tr></table></figure>
<p>已然55M了，既然目前没有时间精力去搞输出更详细的日志，，那么只好想办法把这些日志信息要么按日期时间分割下，要么提高下日志输出级别(正常请求信息不输出，只输出WARN级别以上的信息)。</p>
<h5 id="开搞"><a href="#开搞" class="headerlink" title="开搞"></a>开搞</h5><p>很用力地翻了<a href="https://github.com/shadowsocks/shadowsocks/wiki">文档</a>，没找到什么关于日志的信息。只知道日志文件在<code>/var/log/shadowsocks.log</code>，然并卵。只好自己动手翻源码了，好可怕。。。</p>
<p>这个Python，，零零星星翻过两遍，在<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000">廖雪峰的博客网站</a>上，并没有实际深入去了解，更别说做项目了(关键是工作中暂时用不到..)，有点怂。<br>打开项目之后，并不知道从哪儿开始看…不过，我们可以搜索关键字信息啊，哈哈…笑得一点底气都没有…直接搜『&#x2F;var&#x2F;log&#x2F;shadowsocks.log』，我们可以看到在<code>⁨shadowsocks-2.8.2⁩/⁨shadowsocks⁩/shell.py</code>文件中👇</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 日志文件配置路径 R224</span><br>config[<span class="hljs-string">&#x27;log-file&#x27;</span>] = config.get(<span class="hljs-string">&#x27;log-file&#x27;</span>, <span class="hljs-string">&#x27;/var/log/shadowsocks.log&#x27;</span>)<br><br><span class="hljs-comment">## config？难道是我想的那种config么？？？继续往下看 R245</span><br>logging.getLogger(<span class="hljs-string">&#x27;&#x27;</span>).handlers = []<br>    logging.addLevelName(VERBOSE_LEVEL, <span class="hljs-string">&#x27;VERBOSE&#x27;</span>)<br>    <span class="hljs-keyword">if</span> config[<span class="hljs-string">&#x27;verbose&#x27;</span>] &gt;= <span class="hljs-number">2</span>:<br>        level = VERBOSE_LEVEL<br>    <span class="hljs-keyword">elif</span> config[<span class="hljs-string">&#x27;verbose&#x27;</span>] == <span class="hljs-number">1</span>:<br>        level = logging.DEBUG<br>    <span class="hljs-keyword">elif</span> config[<span class="hljs-string">&#x27;verbose&#x27;</span>] == -<span class="hljs-number">1</span>:<br>        level = logging.WARN<br>    <span class="hljs-keyword">elif</span> config[<span class="hljs-string">&#x27;verbose&#x27;</span>] &lt;= -<span class="hljs-number">2</span>:<br>        level = logging.ERROR<br>    <span class="hljs-keyword">else</span>:<br>        level = logging.INFO<br>    verbose = config[<span class="hljs-string">&#x27;verbose&#x27;</span>]<br>    logging.basicConfig(level=level, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)-8s %(message)s&#x27;</span>, datefmt=<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)<br><span class="hljs-comment">## 看到这儿好像问题解决了。。</span><br></code></pre></td></tr></table></figure>
<p>原来配置文件中可以通过 verbose 来设置日志的输出级别，结合脚本代码和日志信息，可以看到默认级别为 INFO，那么接下来我们只需要在<code>/etc/shadowsocks.conf</code>中添加<code>&quot;verbose&quot;: -1</code>就可将日志级别提升至<code>WARN</code>了~别忘了重启服务噢</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[root@host ~]<span class="hljs-comment"># ssserver -c /etc/shadowsocks.json -d restart</span><br>INFO: loading config from /etc/shadowsocks.json<br>stopped<br>started<br></code></pre></td></tr></table></figure>
<p>亲测有效~但是！WARNING日志也很多，，无奈直接改成了<code>&quot;verbose&quot;:-2</code>。<br>关于其他配置，有兴趣的同学可以查阅下<code>shell.py</code>文件中的<code>config</code>对象的具体信息。</p>
<h5 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h5><p>日志输出信息是在<code>⁨shadowsocks-2.8.2⁩/shadowsocks⁩/tcprelay.py</code>文件中</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog"># R293<br>logging.info(&#x27;connecting %s:%d from %s:%d&#x27; %(common.to_str(remote_addr), remote_port, self._client_address<span class="hljs-string">[0]</span>, self._client_address<span class="hljs-string">[1]</span>))<br></code></pre></td></tr></table></figure>
<p>看样子我们可以控制日志具体输出哪些内容的，，对python比较了解的同学可以尝试修改下，可以试着添加上请求用户的信息~</p>
<h4 id="微信防盗链"><a href="#微信防盗链" class="headerlink" title="微信防盗链"></a>微信防盗链</h4><h5 id="Context-1"><a href="#Context-1" class="headerlink" title="Context"></a>Context</h5><p>微信公众号使用开发模式后，部分功能就只能使用API接口去实现了，，比如『自定义菜单』功能。所以这个时候，需要在后台实现类公众号后台的自定义菜单功能。这其中就会涉及到素材引用的问题，，倘若直接在自己服务器中的后台中引用，就会出现如下图片👇<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131835-%E5%BE%AE%E4%BF%A1%E9%98%B2%E7%9B%97%E9%93%BE.jpeg" alt="@微信防盗链"></p>
<p>但如果直接在浏览器中输入图片地址就可以正常访问。后来得知是<code>referrerPolicy</code>在作怪。</p>
<h5 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h5><p>我们需要做的是在请求图片资源的时候隐藏自己的<code>referrer</code>，避免腾讯识别出我们的服务器不是自己人。<br>具体做法是添加<code>meta</code>标签(详细信息参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy">MDN-Referrer-Policy</a>)👇</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"># content值也可以是no-referrer<br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;referrer&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;same-origin&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>倘若，，引用的图片是通过CSS中<code>background-color</code>引用的，那就悲催了。。想办法将<code>div</code>元素转为<code>img</code>元素，通过<code>src</code>属性引用图片，这样也是可以的。</p>
<h5 id="img-referrerPolicy"><a href="#img-referrerPolicy" class="headerlink" title="img.referrerPolicy"></a>img.referrerPolicy</h5><p>如果不想用meta标签，也可以在img元素中添加<code>referrerPolicy</code>属性，也可以正常引用(详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement/referrerPolicy">HTMLImageElement-referrerPolicy</a>)。如果无效，请尝试清空缓存之后重新请求，亲测有效~</p>
<h5 id="link-referrerpolicy"><a href="#link-referrerpolicy" class="headerlink" title="link.referrerpolicy"></a>link.referrerpolicy</h5><p>如果是引用外部样式，，可以在link标签中添加<code>referrerpolicy</code>属性，，详见<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link">Element-link</a>。</p>
<h5 id="需要注意的是，，"><a href="#需要注意的是，，" class="headerlink" title="需要注意的是，，"></a>需要注意的是，，</h5><p>img.referrerPolicy和link.referrerpolicy属于实验功能，使用前务必检查自己的浏览是否支持！<br>另外，，不能通过<code>ducument.referrer=&#39;no-referrer&#39;</code>去修改，因为<code>ducument.referrer</code>是只读属性..详见<a href="https://www.w3.org/TR/DOM-Level-2-HTML/html.html#ID-95229140">ducument.referrer</a></p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>text-overflow</code>样式用来控制文字溢出盒子之后的处理逻辑，，<br>值为<code>clip</code>，则直接裁切(即隐藏)<br>值为<code>ellipsis</code>，则显示溢出省略标记<code>…</code></p>
<p><code>white-space: nowrap</code> 文本不换行</p>
<p><code>word-wrap</code>用来控制文本超出元素边界后的对英文单词换行的处理逻辑，适用于块元素，行元素需设置width、height。<br>值为<code>break-word</code>，则以单词为单位换行；<br>值为<code>break-all</code>，则以字母为单位换行。</p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>shadowscoks</tag>
      </tags>
  </entry>
  <entry>
    <title>2018_12_week_1st</title>
    <url>/2019/03/17/2018_12_week_1st/</url>
    <content><![CDATA[<p>好久好久之前的零碎知识点了…</p>
<h5 id="关于Linux中的管道"><a href="#关于Linux中的管道" class="headerlink" title="关于Linux中的管道"></a>关于Linux中的管道</h5><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">// 列出当前目录下后缀为 conf 的文件<br><span class="hljs-built_in">ls</span> -lh | grep *.conf<br></code></pre></td></tr></table></figure>
<p>Pipe：即 ls 和 grep 命令之间的**|<strong>(⇧+\)，</strong>管道就是连接一个程序输出和另一个程序输入的通路**！！！</p>
<h5 id="node-js-项目中的-package-json-文件的作用"><a href="#node-js-项目中的-package-json-文件的作用" class="headerlink" title="node.js 项目中的 package.json 文件的作用"></a>node.js 项目中的 package.json 文件的作用</h5><p>— 摘自<a href="https://github.com/PanJiaChen/webpack-and-spa-guide/blob/master/README.md#%E7%BB%99%E9%A1%B9%E7%9B%AE%E5%8A%A0%E4%B8%8A%E8%AF%AD%E6%B3%95%E6%8A%A5%E9%94%99%E5%92%8C%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%A3%80%E6%9F%A5">GitHub-PanJiaChen-webpack-and-spa-guide</a></p>
<blockquote>
<p><code>npm install</code>的<code>--save-dev</code> 会把安装的包和版本号记录到 <code>package.json</code> 中的 <code>devDependencies</code> 对象中，还有一个 <code>--save</code>， 会记录到 <code>dependencies</code> 对象中，它们的区别，我们可以先简单的理解为打包工具和测试工具用到的包使用 <code>--save-dev</code> 存到 <code>devDependencies</code>， 比如 eslint、webpack。浏览器中执行的 js 用到的包存到 dependencies， 比如 jQuery 等。那么它们用来干嘛的？</p>
</blockquote>
<blockquote>
<p>因为有些 npm 包安装是需要编译的，那么导致 windows &#x2F; mac &#x2F;linux 上编译出的可执行文件是不同的，也就是无法通用，因此我们在提交代码到 git 上去的时候，一般都会在 <code>.gitignore</code> 里指定忽略 <code>node_modules </code>目录和里面的文件，这样其他人从 git 上拉下来的项目是没有<code>node_modules</code> 目录的，这时我们需要运行<code>npm install</code><br>它会读取 <code>package.json</code> 中的 <code>devDependencies</code> 和 <code>dependencies</code> 字段，把记录的包的相应版本下载下来。</p>
</blockquote>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
  </entry>
  <entry>
    <title>2023_08—第三周</title>
    <url>/2023/08/23/2023_08_week_3rd/</url>
    <content><![CDATA[<h4 id="2023-08-23"><a href="#2023-08-23" class="headerlink" title="2023-08-23"></a>2023-08-23</h4><p>最近在 Review 同事代码时发现某个方法中加了事务 <code>@Transactional</code> 注解，方法体中的逻辑大概是这样：👇🏻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;<br>    aMapper.deleteAll();<br>    <span class="hljs-keyword">for</span>(*;*;*)&#123;<br>        aMapper.insert(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看上去挺正常的，但实际进入 <code>deleteAll()</code> 方法后发现 SQL 使用的是 <code>TRUNCATE TABLE Statement</code>，这就有意思了。这种情况事务能不能生效呢？如果不生效就悲催了，一旦 <code>insert()</code> 方法执行异常，整张表就相当于被清空了。。</p>
<p>查资料先，，</p>
<p>首先，<code>TRUNCATE TABLE Statement</code> 是 DDL[^1]。</p>
<p>其次，在 Mysql 官网中，有这样一章专门用来描述事务不能回滚的情况[^2]：</p>
<blockquote>
<p><strong>Some statements cannot be rolled back. In general, these include data definition language (DDL) statements</strong>, such as those that create or drop databases, those that create, drop, or alter tables or stored routines.</p>
<p>You should design your transactions not to include such statements. If you issue a statement early in a transaction that cannot be rolled back, and then another statement later fails, the full effect of the transaction cannot be rolled back in such cases by issuing a <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html"><code>ROLLBACK</code></a> statement.</p>
</blockquote>
<hr>
<p>[^1]: <a href="https://dev.mysql.com/doc/refman/5.7/en/truncate-table.html">13.1.34 TRUNCATE TABLE Statement</a><br>[^2]: <a href="https://dev.mysql.com/doc/refman/5.7/en/cannot-roll-back.html">13.3.2 Statements That Cannot Be Rolled Back</a></p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>2023_08—第四周</title>
    <url>/2023/08/30/2023_08_week_4th/</url>
    <content><![CDATA[<h4 id="Druid-driverClassName"><a href="#Druid-driverClassName" class="headerlink" title="Druid driverClassName"></a>Druid driverClassName</h4><p><strong>Context</strong>: 数据库从 Oracle 迁移至 OceanBase（Oracle 租户模式），顺便将数据库配置从项目文件迁移至 Apollo，代码无改动。框架为定制化的 Spring。</p>
<p>OK，下面讲问题，，</p>
<p>不出意外，出意外了，，发版时，服务启动成功后，查询数据库报错：👇🏻</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs log">nested exception is org.apache.ibatis.exceptions.PersistenceException: <br>### Error updating database.  Cause: java.lang.NullPointerException<br>### The error may involve com.*.*.dao.*Mapper.updateByPrimaryKeySelective-Inline<br>### The error occurred while setting parameters<br>### SQL: update xxx<br>### Cause: java.lang.NullPointerException<br></code></pre></td></tr></table></figure>
<p>报错的堆栈信息其实并不能说明特别具体的问题，因为执行任何一条 SQL 都会报错，可以排除跟代码无关。</p>
<p>另外，经过深入查找还发现其他报错信息：<code>unknown jdbc driver : ***</code>，位于 Druid 包中，以 1.1.9 版本为例，代码如下：👇🏻</p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 该方法主要使用来通过数据库链接串来确定对应数据库的驱动名称</span><br><span class="hljs-comment"> * https://github.com/alibaba/druid/blob/1.1.9/src/main/java/com/alibaba/druid/util/JdbcUtils.java</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getDriverClassName</span><span class="hljs-params">(String rawUrl)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br> <span class="hljs-keyword">if</span> (rawUrl == <span class="hljs-literal">null</span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> &#125;<br> <span class="hljs-keyword">if</span> (rawUrl.startsWith(<span class="hljs-string">&quot;jdbc:derby:&quot;</span>)) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;org.apache.derby.jdbc.EmbeddedDriver&quot;</span>;<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawUrl.startsWith(<span class="hljs-string">&quot;jdbc:mysql:&quot;</span>)) &#123;<br>     <span class="hljs-keyword">if</span> (mysql_driver_version_6 == <span class="hljs-literal">null</span>) &#123;<br>         mysql_driver_version_6 = Utils.loadClass(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>) != <span class="hljs-literal">null</span>;<br>     &#125;<br>     <span class="hljs-keyword">if</span> (mysql_driver_version_6) &#123;<br>         <span class="hljs-keyword">return</span> MYSQL_DRIVER_6;<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">return</span> MYSQL_DRIVER;<br>     &#125;<br> &#125;<br> ...<br> &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rawUrl.startsWith(<span class="hljs-string">&quot;jdbc:clickhouse:&quot;</span>)) &#123;<br>     <span class="hljs-keyword">return</span> JdbcConstants.CLICKHOUSE_DRIVER;<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SQLException</span>(<span class="hljs-string">&quot;unkow jdbc driver : &quot;</span> + rawUrl);    <span class="hljs-comment">// 👈🏻👈👈</span><br> &#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>那基本确定问题了，，当前 Druid 版本有点低，没有对 OceanBase 做兼容，理论上升级高版本的可以解决。事实上，升级到 2.X 版本后也确实解决了问题[^1]，但还有个疑点，测试环境没问题啊。</p>
<p>此时已经将近凌晨 12 点，不少关联方同事都在等待验证，先试探性的找到运维同学帮忙替换高版本 jar 之后，重启试试。重启之后，业务一切正常，验证完自己负责的业务功能后，继续寻找答案，，</p>
<p>此情此景，不免心生疑问，，Druid 这么 Low 的么？通过这种方式查询对应的数据库驱动，那岂不是很耽误事儿，，市场每出一款数据库，就要立即出版本做兼容？不是可以指定驱动名称的么？有妖气！！！</p>
<p>其实到这里，问题基本定位到了，，就是驱动名称配置的问题。搞笑的是，出问题的不是配置中的驱动名称：<code>com.alipay.oceanbase.jdbc.Driver</code>，而是对应的 Key：<code>driverClassName</code>。。测试环境配置的没问题，生产环境配置的是 <code>driverClass</code> 😂。</p>
<p>以👆🏻上内容都是后知后觉，因为当初核对生产配置时，有三个开发在场，大家的关注点都在 value 上，key 反而忽略了。。</p>
<p>继续追查妖气，，在 druid 包下查找 <code>JdbcUtils.getDriverClassName()</code> 的上层引用，发现了蛛丝马迹：👇🏻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSourceProxyConfig <span class="hljs-title function_">parseConfig</span><span class="hljs-params">(String url, Properties info)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">restUrl</span> <span class="hljs-operator">=</span> url.substring(DEFAULT_PREFIX.length());<br><br>    <span class="hljs-type">DataSourceProxyConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceProxyConfig</span>();<br><br>    <span class="hljs-keyword">if</span> (restUrl.startsWith(DRIVER_PREFIX)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> restUrl.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>, DRIVER_PREFIX.length());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">driverText</span> <span class="hljs-operator">=</span> restUrl.substring(DRIVER_PREFIX.length(), pos);<br>        <span class="hljs-keyword">if</span> (driverText.length() &gt; <span class="hljs-number">0</span>) &#123;<br>            config.setRawDriverClassName(driverText.trim());     <span class="hljs-comment">// 👈👈👈</span><br>        &#125;<br>        restUrl = restUrl.substring(pos + <span class="hljs-number">1</span>);<br>    &#125;<br>        <span class="hljs-comment">// ...</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rawUrl</span> <span class="hljs-operator">=</span> restUrl;<br>    config.setRawUrl(rawUrl);<br><br>    <span class="hljs-keyword">if</span> (config.getRawDriverClassName() == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">rawDriverClassname</span> <span class="hljs-operator">=</span> JdbcUtils.getDriverClassName(rawUrl);   <span class="hljs-comment">// 👈👈👈</span><br>        config.setRawDriverClassName(rawDriverClassname);<br>    &#125;<br><br>    config.setUrl(url);<br>    <span class="hljs-keyword">return</span> config;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接着追查 <code>parseConfig()</code> 可以发现 druid 的数据源工厂在生产数据源时，会通过配置文件组装实例：👇🏻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DruidDataSourceFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ObjectFactory</span> &#123;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PROP_DRIVERCLASSNAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;driverClassName&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PROP_INIT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;init&quot;</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title function_">createDataSource</span><span class="hljs-params">(Map properties)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">DruidDataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DruidDataSource</span>();<br>        config(dataSource, properties);            <span class="hljs-comment">// 👈👈👈 使用配置文件组装实例</span><br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">config</span><span class="hljs-params">(DruidDataSource dataSource, Map&lt;?, ?&gt; properties)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-comment">// ...</span><br>        value = (String) properties.get(PROP_DRIVERCLASSNAME);<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>            dataSource.setDriverClassName(value);   <span class="hljs-comment">// 👈👈👈 setDriverClassName</span><br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>        value = (String) properties.get(PROP_INIT);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;true&quot;</span>.equals(value)) &#123;  <br>            dataSource.init();                      <span class="hljs-comment">// 👈👈👈 如果 `init` 设置为 true 的话，会在 init() 中执行 validationQuery，验证数据库是否可用，否则就只能等服务启动后执行 SQL 语句时 getConnection() 时验证了。</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在定制框架中，在 DruidBean 在实现 <code>InitializingBean#afterPropertiesSet()</code> 的方法中， 指定了配置项 A，如果该配置项开启，则执行 <code>dataSource.init();</code> 方法，遗憾的是，，该配置项并未开启，导致问题在服务启动阶段并未暴露。。</p>
<p>看了下 SpringBoot 框架通过 <code>@EnableAutoConfiguration</code> 机制注入的 <code>DruidDataSource</code> 执行流程与上述有差异，大家需要注意下，挖个坑，慢慢填。。</p>
<h4 id="OceanBase-ORA-24761"><a href="#OceanBase-ORA-24761" class="headerlink" title="OceanBase ORA-24761"></a>OceanBase ORA-24761</h4><p>在 OceanBase Oracle 租户模式下，存在一个特殊的配置：<code>ob_trx_idle_timeout</code>，数据库迁移时需额外注意下。官方解释为：<strong>事务空闲超时指当事务两条语句执行间隔超过指定阈值</strong>。可以通过以下语句查看数据库配置：</p>
<blockquote>
<p>  obclient&gt; SHOW variables like ‘ob_trx_idle_timeout’;</p>
<p>  | ob_trx_idle_timeout | 120000000 |</p>
</blockquote>
<p>需要注意的是，单位为微秒，即默认 120s。官方在 v4.2 版本[^2]中的例子比较好理解：(吐槽下..下载的 v3.2.3 版本的 PDF 文档例子不容易理解)：👇🏻</p>
<blockquote>
<p>  obclient [SYS]&gt; SELECT * FROM ordr;</p>
<p>   +—-+——+——-+——————————+ </p>
<p>  | ID | NAME | VALUE | GMT_CREATE   |</p>
<p>  +—-+——+——-+——————————+ |</p>
<p>  |  1 | CN   |  NULL | 04-NOV-22 06.06.16.843024 PM | </p>
<p>  |  2 | UK   |  NULL | 04-NOV-22 06.06.16.843024 PM |</p>
<p>  |  3 | US   |  NULL | 04-NOV-22 06.06.16.843024 PM |</p>
<p>   +—-+——+——-+——————————+ </p>
<p>  3 rows in set </p>
<p>  obclient [SYS]&gt; UPDATE ordr SET value&#x3D;1003 WHERE id&#x3D;3; </p>
<p>  Query OK, 1 rows affected </p>
<p>  Rows matched: 1  Changed: 1  Warnings: 0 </p>
<p>  &#x2F;* 等待较长一段时间不操作*&#x2F;                    &#x2F;&#x2F; 👈👈👈 时间超过 ob_trx_idle_timeout 即报错</p>
<p>  obclient [SYS]&gt; SELECT * FROM ordr; </p>
<p>  ORA-24761: transaction rolled back: transaction idle timeout</p>
</blockquote>
<p>简单来说就是，，开启事务后，事务内两条语句执行间隔超过 <code>ob_trx_idle_timeout</code> 就会报 ORA-24761。</p>
<p>快速解决方案就是将间隔时间配置长一点，要从根本上解决还得是分析业务逻辑，重新评审代码实现方案缩小事务范围，可以考虑最终一致 + 局部事务 +补偿，保证不会产生脏数据，再结合报警+运营手段解决。</p>
<hr>
<p>[^1]: <a href="https://github.com/alibaba/druid/blob/2.x/src/main/java/com/alibaba/druid/util/JdbcUtils.java">JdbcUtils.java  V2.X </a><br>[^2]: <a href="https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000000033924">事务空闲超时，错误代码 ORA-24761</a></p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>2023_09—第二周</title>
    <url>/2023/09/13/2023_09_week_2nd/</url>
    <content><![CDATA[<h3 id="2023-09-13"><a href="#2023-09-13" class="headerlink" title="2023-09-13"></a>2023-09-13</h3><h4 id="JOIN-表使用建议-1"><a href="#JOIN-表使用建议-1" class="headerlink" title="JOIN 表使用建议[^1]"></a>JOIN 表使用建议[^1]</h4><blockquote>
<p>某些性能消耗非常大的 SQL 可以直接造成数据库主从长时间延迟、主从中断、甚至实例 CRASH 等。性能消耗过大的 SQL 本身执行时间长，其实也就是资源占用时间长，会造成集群并发能力低下。在业务流量突增（业务本身或网络抖动都可能导致）等情况下，容易造成 SQL 堆积、并发超过限制等，从而影响到业务正常运行。OceanBase 数据库没有关联表数的限制，复杂函数的使用目前只针对正则表达式相关函数，例如 <code>regexp_substr</code> 这类函数的执行性能差，容易影响业务。</p>
<p><strong>一个业务，使用简单的 SQL 语句，使用数据库最简单的增、删、改、查功能，从而让数据库处于一种可预估，可扩展，可控的状态</strong>。我们来衡量一个业务 SQL 写的是否优秀，其关键点是这个业务的 SQL 是否在合理范围内足够的简单。这个合理的范围指的是<strong>随着业务及数据的增长，SQL 本身的性能消耗不大且不会有大的变化，不会占用过多的 CPU 或 IO 时间</strong>。比如一个根据主键查询的语句，一行数据与一千万行数据不会有太大的变化。业务可以很好的在此基础之上预估当前流量要增加比如 N 倍的情况下，数据库应就当如何扩容并能确保数据库可以支撑.但如果业务中复杂语句过多，性能消耗又大，数据库可能就只因为偶尔的或是前端的，或是网络的，可是数据库本身的波动导致 SQL 堆积、实例并发增长，业务受到影响。</p>
<p><strong>复杂的 SQL 会让集群处于一种性能波动明显，并发能力低，业务可能不可控的状态</strong>。</p>
<p>– OceanBase 数据库 》参考指南 》SQL 参考 》SQL 实践和建议 》SQL 语句示例</p>
</blockquote>
<hr>
<p>[^1]: <a href="https://www.oceanbase.com/docs/common-oceanbase-database-cn-1000000000035083">JOIN 表使用建议</a></p>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>2023_12—第二周</title>
    <url>/2023/12/16/2023_12_week_2nd/</url>
    <content><![CDATA[<h3 id="2023-12-16"><a class="header-anchor" href="#2023-12-16">¶</a>2023-12-16</h3>
<h4 id="Context"><a class="header-anchor" href="#Context">¶</a>Context</h4>
<p>之前小程序中有左滑删除的功能，但对应的 slide-view 组件不是很好用，下滑翻页时也会触发左滑，想着换个组件。于是，找到了 weui 中的 <strong>Slideview</strong><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p>
<h4 id="整合WEUI"><a class="header-anchor" href="#整合WEUI">¶</a>整合WEUI</h4>
<p>顺利的话，按照 WEUI 的快速上手教程就 OK 了，然而我小程序的框架是用的是 Wepy<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，事情并没有这么简单。</p>
<p>我的预期是 通过 useExtendedLib<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 扩展库 的方式引入，这种方式引入的组件将不会计入代码包大小。</p>
<p>OK, 首先在 <code>app.wpy</code>中增加以下内容：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#useExtendedLib</span></span><br><span class="line"><span class="attr">&quot;useExtendedLib&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;weui&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后在对应的页面中增加以下配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">usingComponents<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mp-slideview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;weui-miniprogram/slideview/slideview&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>按照预期，接下来就是直接引用对应的标签了，然而编译时会直接报错：</p>
<blockquote>
<p>Can’t resolve /weui-miniprogram/***</p>
</blockquote>
<p>一顿操作，我们在 Wepy 的 GitHub 仓库找到了相关的 [issue#2680](wepy2 不能通过useExtendedLib扩展的方式引入weui #2680)，里边提到：</p>
<blockquote>
<p><a href="https://github.com/SpringHgui">SpringHgui</a> mentioned this issue on Aug 4, 2021</p>
<p><a href="https://github.com/Tencent/wepy/pull/2758">支持useExtendedLib导入weui #2758</a></p>
</blockquote>
<p>时间是 2021-08-04，既然支持了，OK 那我们就按照上边 issue#2758 的做就可以啦，也就是把 <code>usingComponents</code> 部分改动下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加 raw:</span></span><br><span class="line">usingComponents<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mp-slideview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;raw:weui-miniprogram/slideview/slideview&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>改动后编译果然不报错了，但页面还是异常的，打开编译后的文件发现，结果与文中提到的预期不一样，<code>raw</code> 前缀依然还在，，手动在编辑器中去掉之后，页面正常了。</p>
<p>但，，这也不是个事儿啊，既然提到已经解决了，那应该是解决了，，再找找吧，然后看到了 issue#2680 中提到的：</p>
<blockquote>
<p><strong><a href="https://github.com/SpringHgui">SpringHgui</a></strong> commented on Nov 30, 2021</p>
<p>使用这个插件解决 <a href="https://www.npmjs.com/package/wepy-cli-extend">wepy-cli-extend</a></p>
</blockquote>
<p>安装这个插件后国人解决了，，但为啥这个评论是 2021-11-30 的？前边 2021-08-04 评论不是说已经解决了么，笑哭。</p>
<hr>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://wechat-miniprogram.github.io/weui/docs/slideview.html#%E4%BB%A3%E7%A0%81%E5%BC%95%E5%85%A5">weui-Slideview</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://wepyjs.github.io/wepy-docs/2.x/#/?id=wepy-2-alpha">WePY 2</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#useExtendedLib">useExtendedLib</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>关于微信开放平台账号管理权限</title>
    <url>/2023/12/16/About_WeChat_Open_account_manage_auth/</url>
    <content><![CDATA[<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>最近在为客户部署小程序时遇到一个问题，通过日志定位到问题是，，没有获取到小程序用户的UnionID，导致无法对小程序用户和卡包(公众号)用户形成有效的映射，bulabula…总之，翻到日志才想起来，应该通过<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1498704199_1bcax&token=6616e998e48175a3d6490042d013a5bc53b4acef&lang=zh_CN">微信提供的接口</a>创建微信开放平台，然后绑定另一个appid即可。</p>
<p>想想也没啥，之前也为其他客户部署过，无非是调用两次接口：一次创建，一次绑定，，齐活~</p>
<h4 id="BUT！！！"><a href="#BUT！！！" class="headerlink" title="BUT！！！"></a>BUT！！！</h4><p>但！！！这次搞的格外艰辛，微信服务器一直返回</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;errcode&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">40013</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;errmsg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;invalid appid hint: [iAEcfA03241959]&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>日狗，真心日狗！确定一定以及肯定，两个appid都没问题，，因为通过**<a href="https://api.weixin.qq.com/cgi-bin/open/create?access_token=xxxx">创建 开放平台帐号并绑定公众号&#x2F;小程序</a>**接口，两个appid都可以创建开放平台。<br>搞到这儿也<span id="ques">想到一个问题</span>，，</p>
<blockquote>
<p>我想通过接口，把客户的小程序和公众号绑在同一个开放平台，，无疑，小程序肯定是授权给第三方平台的。倘若，我用小程序的<code>appid</code>，创建开放平台，然后将公众号的<code>appid</code>绑到小程序创建的开放平台上。<br>那么问题来了，，公众号需要将<code>开放平台账号管理权限</code>授权给第三方平台么？？？</p>
</blockquote>
<p>为了赶紧绑定成功先，暂时将公众号的开放平台账号管理权限授权给第三方平台了。</p>
<h4 id="Succeed？？"><a href="#Succeed？？" class="headerlink" title="Succeed？？"></a>Succeed？？</h4><p>我疯了，成功疯了。。最后找之前没接触过这块儿的同事从阅读文档开始，慢慢review代码。刚开始也是不行，，后来他要静静，然后闷头搞。<br>…<br>一会儿，，诶？我好像创建成功了？！</p>
<p>稀里糊涂的 创建成功了，，然后我要求他复盘整个流程。</p>
<ol>
<li>分别用两个<code>appid</code>都创建开放平台；</li>
<li>然后在小程序后台解绑开放平台；</li>
<li>通过接口将小程序的appid绑定到公众号创建的开放平台账号上。</li>
</ol>
<p>前两步都没啥，但是第三步！我在调用接口的地址上发现点端倪，跟我之前调用时写的不一样，然后就提醒他这儿应该写公众号的<code>appid</code>，而不是小程序的。他突然也想到了些什么，很肯定的说，上次绑定成功的时候就是这样写的！</p>
<p>终于找到问题所在，，验证，成功！！！<br>在这儿详细复盘下，给大家伙儿做个参考，，</p>
<p>我将文档中<code>将 公众号/小程序绑定到开放平台帐号下</code>的接口封装成我们自己的接口，，伪代码如下👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将 公众号/小程序绑定到开放平台帐号下</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Attention</span> 该API用于将一个尚未绑定开放平台帐号的公众号或小程序绑定至指定开放平台帐号上。二者须主体相同。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindOpen</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">appid</span> <span class="hljs-operator">=</span> getPara(<span class="hljs-string">&quot;appId&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">open_appid</span> <span class="hljs-operator">=</span> getPara(<span class="hljs-string">&quot;open_appid&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">target_appid</span> <span class="hljs-operator">=</span> getPara(<span class="hljs-string">&quot;target_appid&quot;</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">BIND_OPEN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.weixin.qq.com/cgi-bin/open/bind?access_token=&quot;</span> + getAuthorizerAccessToken(appid);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> HttpUtils.post(BIND_OPEN, Kv.set(<span class="hljs-string">&quot;appid&quot;</span>, target_appid).set(<span class="hljs-string">&quot;open_appid&quot;</span>, open_appid).toJson());<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>失败</code>：我之前的绑定方式，，</p>
<ol>
<li>通过小程序<code>appid</code>创建开放平台；</li>
<li>调用接口<code>http://IP:Port/path/bindOpen?appId=小程序APPID&amp;open_appid=开放平台账号&amp;target_appid=公众号APPID</code>。</li>
</ol>
<p>👆In a word，，<strong>使用 A 创建开放平台，然后使用 A 的access_token绑定 B。</strong><br>报错<code>&#123;&quot;errcode&quot;:40013,&quot;errmsg&quot;:&quot;invalid appid hint: [iAEcfA03241959]&quot;&#125;</code></p>
<hr>
<p><code>成功</code>：同事的绑定方式，，</p>
<ol>
<li>使用公众号的<code>appid</code>创建开放平台账号；</li>
<li>调用接口<code>http://IP:Port/path/bindOpen?appId=小程序APPID&amp;open_appid=开放平台账号&amp;target_appid=小程序APPID</code>。</li>
</ol>
<p>👆In a word，，<strong>使用 A 创建开放平台，然后使用 B 的access_token绑定 B。</strong></p>
<p>至此，，问题解决！另外，<a href="#ques">之前的问题</a>也迎刃而解：<strong>公众号和小程序都需要将开放平台账号管理权限授权给第三方平台</strong>。</p>
<p>想想也是，当初将小程序和公众号的权限授权给第三方平台时也是这样，，<strong>标的主动绑定平台，而不是平台主动绑定标的</strong>。</p>
<h4 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h4><p>嗯，希望<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1498704199_1bcax&token=6616e998e48175a3d6490042d013a5bc53b4acef&lang=zh_CN">微信开放平台帐号管理</a>完档越来月完善，，意味深长的微笑 🙂。</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>关于死亡，关于宗教</title>
    <url>/2018/01/10/Death_and_religion/</url>
    <content><![CDATA[<h3 id="关于死亡，关于宗教"><a href="#关于死亡，关于宗教" class="headerlink" title="关于死亡，关于宗教"></a>关于死亡，关于宗教</h3><h5 id="2018-01-15-17-57-44"><a href="#2018-01-15-17-57-44" class="headerlink" title="2018-01-15 17:57:44"></a>2018-01-15 17:57:44</h5><p>科学是工具类，宗教是抽象类？？？两者不冲突，哈哈</p>
<hr>
<p>很早就想写这个题目了，，可是，这个题目好像离自己又很远，年纪轻轻这个题目又能写多深呢？但，，2017年，真的有很多事情都跟死扯上了关系，又留下巨深的印象。以至于，2017年的关键词不是网易云的『等待』，也不是支付宝的『旺』，，<strong>死亡</strong>。</p>
<h4 id="Chapter-Ⅰ-完整的人生"><a href="#Chapter-Ⅰ-完整的人生" class="headerlink" title="Chapter Ⅰ.完整的人生"></a>Chapter Ⅰ.完整的人生</h4><p>大概是年初的时候吧，跟周婶儿、姜老师和阿松去龙泉寺，，下山的时候不知怎么就聊到了人生和理想，亦聊到了死亡。婶儿说，，<strong>人这一辈子是不完整的，只经历了活着，没有经历死亡</strong>。就像完整的一天有白天和黑夜，但是我们出生之后只经历了黎明、白天和傍晚，，黎明和傍晚又似是无意识的，那么傍晚之后的黑夜呢？？</p>
<p>深以为然，，如此，<strong>反而突然对死亡变得好奇起来，甚至有些『盼望』，迫切地想知道死亡是怎样一回事。把『人生』和『人死』两块图拼起来，岂不是圆满了？</strong>再也不害怕死亡了，，白天的太阳看腻了，晚上的星星月亮是蛮不错的~ </p>
<h4 id="Chapter-Ⅱ-Nothing-at-all"><a href="#Chapter-Ⅱ-Nothing-at-all" class="headerlink" title="Chapter Ⅱ.Nothing at all"></a>Chapter Ⅱ.Nothing at all</h4><p>再后来，，国庆的时候，想来一周的时间该怎么在家消磨？于是开始刷『权利的游戏』，加上节后以后周末的时间，，七季全刷完了。其实，前五季的确是『权利的游戏』，之后便是『冰与火之歌』了。给我留下印象极深的便是第六季第二集，雪诺被红袍女复活，雪诺醒后，，</p>
<blockquote>
<p><a href="http://v.youku.com/v_show/id_XMzMyNzM1ODk2MA==.html?spm=a2hzp.8244740.0.0">权游-雪诺复活</a></p>
</blockquote>
<ul>
<li><code>雪诺</code>- I shouldn’t be here. #我不该在这里的。</li>
<li><code>洋葱骑士</code>-The lady brought you back. #这位女士复活了你。</li>
<li><code>红袍女</code>-Afterwards, after they stabbed you, after you died, where did you go? What did you see? #在他们刺伤你之后，在你死之后，你去了哪里？你看到了什么？</li>
<li><code>雪诺</code>-Nothing. There was nothing at all. #什么都没，根本什么都没有。</li>
</ul>
<p>看到这儿的时候，我的内心是奔溃的，，宕机的那种！我满心期待的死亡，居然什么都没有？！<strong>Nothing at all</strong>！！！我想要的是死亡，不是暂停！我的世界突然变成灰色了。。只剩失望</p>
<h4 id="Chapter-Ⅲ-相亲相爱"><a href="#Chapter-Ⅲ-相亲相爱" class="headerlink" title="Chapter Ⅲ.相亲相爱"></a>Chapter Ⅲ.相亲相爱</h4><p>Sherry推荐张艾嘉的『相亲相爱』，，光听名字，这电影不招人待见，最喜欢的还是科幻片。。但是有Sherry的口碑，我对她的taste也有信心，也知道自己以名取影是狭隘的。<br>…..<br>总是盯着进度条看，，不过瘾，为什么不拍得再长一点？！从阿达征得阿祖的同意后，躺进棺材，突然就哽咽了，，这种情绪来得太突然，始料未及。我也绷不住了，，哭得像傻哔一样。<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901135021-%E7%9B%B8%E4%BA%B2%E7%9B%B8%E7%88%B1.jpg" alt="相亲相爱"></p>
<p>其实，这部电影，死亡不是主题，，只不过这个镜头，阿达突如其来的哽咽，shocked。</p>
<h4 id="Chapter-Ⅳ-一定有另一个世界"><a href="#Chapter-Ⅳ-一定有另一个世界" class="headerlink" title="Chapter Ⅳ.一定有另一个世界"></a>Chapter Ⅳ.一定有另一个世界</h4><p>12月30号元旦放假，回老家，，爷爷还是躺在床上。</p>
<p>我和哥哥，还有表弟一块，，其实，大家心里都明白，爷爷身体每况愈下，怕是时间不多了。姑姑也在老家陪床。中午炒了几个家常菜，我不喜欢喝酒，尤其是白酒，，便没有参与。留老爷子自己在床上，，以前都是一块，看着他，我也很无助。我去拿了个鹌鹑蛋，给他剥开皮，，喂他吃了。递到嘴边就张开嘴了，还是认食儿，，这种状态，欣慰。<br>不过，，也可能是蛋黄的原因，也可能是嗓子比较干，他有点咳。我赶紧调的温水，用很浅的勺子喂他，，又不敢直接喂在嘴里，便用勺子贴着下嘴唇，以牙齿引流。喂了几勺，，我觉得应该可以把蛋黄冲下去了。但还咳，，咳得的次数多了，大概明白了，呼吸肌无力，已经没力气咳嗽了。。开始用力呼吸，声音很大，隔壁房间都可以听到。听姑姑说了，这才知道老爷子从昨晚开始就不怎么吃东西了，早上还吐了，，顿时我感觉自己闯祸了。这时候，老爷子呼吸开始缓下来了，平静了很多，，就是总扯被子。我有点无措，问姑姑，，爷爷已经不能说话了，，姑姑也不知道该怎么办了，掀开被子，摸摸爷爷身上，，除了很多汗，但是不至于热成这样这样啊。我摸摸爷爷的额头，没有发烧。其实，爷爷看上去，气色还是不错的，就是瘦了点，太瘦了。之前帮姑姑给爷爷换尿布的时候，我无法描述我看到了怎样一副躯体，，换好之后，背过去，用力憋着，尽量不哭出声音。</p>
<p>吃过午饭后，，我回趟家，想着准备些微信小程序的开发资料，然后回爷爷这边，守着他，无聊的时候打发下时间。我以为这次会像往常一样，，不会有事的。<br><code>/**以下内容，可能涉及描述人的临终状态，，慎读预警**/</code><br><font style="color:white">再回爷爷这边的时候，，奶奶、姑姑、叔叔都在房间里，都在紧张的盯着爷爷。盯着，让人感觉不舒服的盯着，但此时除了盯着，好像其余也无能为力。爷爷的呼吸很有节奏，，但是在用嘴巴呼吸，张着嘴，眼睛半睁半闭。不知道是想睁着，还是想闭着。他的每一次呼吸，都是呼气长，吸气短，，呼气和吸气之间还会有很短的停顿。这个停顿着实让人揪心，，我也开始盯着。婶婶开始给两个堂弟打电话，让他们回家，，妈妈也打了电话让爸爸回来。三爷家的姑姑也来了，开始给族里话事的伯伯打电话。。<br>我们几个还在盯着，，突然，爷爷的呼吸幅度明显小了，，像运动过后喘着的粗气突然平静下来了。呼气和吸气之间的停顿也变长了。这种感觉很不好，，姑姑看看了爷爷的眼睛，瞳孔明显散了，颜色也浅了，浅灰色。用手指以很近的距离在爷爷眼前晃也不眨眼了。这个时候，呼吸已经变成纯生理性了，大概已经没有意识了，，不知道此时对 爷爷 来说，这到底是怎样一种状态，游离么？慢慢，，坍缩了，爷爷不张嘴了，眼睛向上翻了一下。。此时，我就站在床边，用平生最大的力气憋着，背过去，还是失声了！</font></p>
<p>我幻想过很多次亲人去世时的场景，每次想都会怕，，我怕他们离世后，我不敢再靠近他们。但此时此刻，一点点怕的感觉都没有，，很亲。爷爷离世前一直用嘴呼吸，离世后嘴巴还是张着，大人说得趁爷爷的身体还热着，姑姑托着爷爷的下巴，帮他把嘴巴合上。屋里开始有人忙活了，蒙镜子，门口放碗水，准备给爷爷擦洗身子，穿寿衣。爷爷的脸上盖上了白毛巾，姑姑忙不过来，我隔着毛巾托着爷爷的下巴，跪在床头痛哭。。</p>
<p>我又想到雪诺说的 Nothing at all，我希望他说的是错的。我希望真的有另外一个世界，我希望有一天我可以在那里再见到爷爷。突然间，，我好像明白宗教为什么存在了。受唯物主义的影响，我一直觉得宗教是狭隘的，反智的，荒谬的。但是，宗教描述了人死亡后的世界，让人们面对死别时能够得到宽慰，，还有天堂，还有来世！我们还会再见！我们并没有永远的分开。。宗教很大一部分是用来解答人们对身后事的疑惑的，给现世的人重生重逢的希望！科学？科学不可以。。从这一方面讲，科学好像跟宗教不冲突，反而互相补充。</p>
<p>在雪诺复活以前，，我从没认真想过有没有 Nothing at all 的情况，因为三大宗教都有对身后事的描述，佛教有六道轮回，基督有天堂地狱，伊斯兰有信后世。Nothing at all 一定是个BUG。</p>
]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>死亡</tag>
        <tag>宗教</tag>
      </tags>
  </entry>
  <entry>
    <title>对马斯洛需要层次理论的简单抽象</title>
    <url>/2018/07/12/Abstraction_Maslow&#39;s-hierarchy-of-needs/</url>
    <content><![CDATA[<p>中午十二点，太饿了，，心里又总想着前阵子读到的一句话。噢？突然觉得马斯洛的需求层次理论刚好可以抽象一下~</p>
<p>↑ ++++++++++++++++++++++++++++++++<br>↑ +++++++++++++&amp;nbsp;++++++++++++++&amp;nbsp;&amp;nbsp;++++<br>↑ +++++++++++&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;++++++++++++&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;++++<br>↑ +++++++++&amp;nbsp;<strong>自我实现</strong>&amp;nbsp;+++++++++<strong>→人与内心</strong>++++<br>↑ +++++++&amp;nbsp;&amp;nbsp;&amp;nbsp;<strong>尊重需要</strong>&amp;nbsp;&amp;nbsp;&amp;nbsp;++++++++&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+++++<br>↑ +++++&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<strong>归属与爱</strong>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+++++<strong>→人与社会</strong>&amp;nbsp;&amp;nbsp;&amp;nbsp;++++++<br>↑ +++&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<strong>安全需要</strong>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;++++&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;++++++<br>↑ +&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;<strong>生理需要</strong>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+<strong>→人与物质</strong>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;+++++++<br>↑ ++++++++++++++++++++++++++++++++++++++++++++++++++</p>
<p>简单来说，，『生理需要』和『安全需要』是人与物质的关系，『归属与爱的需要』和『尊重需要』是人与人或人与社会的关系，『自我实现』是人与内心或人与自己关系。</p>
<p>毫无违和感！年龄越大，越发的喜欢跟年长的人接触，，好像突然就知道原因了。</p>
]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>马斯洛需求层次理论</tag>
        <tag>抽象</tag>
      </tags>
  </entry>
  <entry>
    <title>人生的意义与自由意志</title>
    <url>/2019/08/31/Fate&amp;FreeWill/</url>
    <content><![CDATA[<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>上周六看『<a href="https://movie.douban.com/subject/27010768/">寄生虫</a>』的时候，有个片段，，下暴雨的时候，男主一家人居住的半地下室被水淹之后，父子俩和受灾群众去体育馆过夜的时的对话👇</p>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901140404-%E5%AF%84%E7%94%9F%E8%99%AB-%E6%B2%A1%E6%9C%89%E8%AE%A1%E5%88%92.png" alt="寄生虫-没有计划"></p>
<p>虽然关于计划的逻辑极端了些，，但在那一霎那我还是被击中了！突然意识到<strong>人生的意义和所谓自由意志根本是两个互斥的东西！！</strong></p>
<h4 id="人生的意义"><a href="#人生的意义" class="headerlink" title="人生的意义"></a>人生的意义</h4><p>人生的意义被定义之后也好似是其中一种计划，，这个计划定义了我们对生命的终极目标，实现这个目标，我们的人生便是有意义的。那么，这个目标是什么？我相信每个人在出生的时候是不存在这样目标的，或者说人生的意义。你的人生可是才刚开始呀，怎么会有那些条条框框。</p>
<p>(岁岁念一句，，倘若真有宿命存在，那我的宿命和你的宿命有冲突可怎么办？僵着？宿命之所以是宿命就是得完成啊，僵着算是怎么回事儿；既然不能僵着，那肯定有一方的宿命完成不了，那还算宿命么；OK，那又有人说了，我的宿命优先级比你的高，所以 <a href="http://www.baidu.com/link?url=ZiLzi5Zo71GmTXO3J1opYpfSXMdwlnKyFlRp_lA2WEeqLFjmOh3eO3Wci08L92Z03oi92T7h6lWon5-xM6l5xa"><em>America</em> <em>First</em> </a>！我去你大爷！！)</p>
<p>于是，我们后来由本我，经历了自由，可能还有超我。在无所事事的时候，难免会想起我们存在的目的，就像我们难免会认为自己是天选之人，，(神让)[^1]我来到世上，天降大任，总得图点啥吧？如果这样的话，我们的自由意志将至于何地？！又是唯心主义在作怪！『<a href="https://book.douban.com/subject/11445548/">自私的基因</a>』也提到了：</p>
<blockquote>
<p>我们都是生存机器–作为载运工具的机器人，其程序是盲目编制的，为的是永久保存所谓基因这种禀性自私的分子。</p>
</blockquote>
<p>说白了，我们人生的意义就是生孩子，，还得尽可能的多生，这样才能扩大自己的基因在整个基因库中的份额。这不光是我们人类生活的意义，也是整个生物圈中作为个体存在的意义。太过赤裸裸，但我还是接受了，而且欣然接受。接受的并非是，我此生的一定要多生娃多下崽儿，，而是我们的人生没有意义，我拒绝成为基因的运载工具，拒绝彻底沦为下半身动物。</p>
<h4 id="自由意志"><a href="#自由意志" class="headerlink" title="自由意志"></a>自由意志</h4><p>『命运的安排』这种东西不可以存在于我的生命中，根本不应该存在。我深刻地相信，我所做的一切都是由我自己选择的，，自由意志这种东西实在太过重要。关于自由意志，我们拥有的也并非完全的自由意志，，比如我们的肉体，肉体之内，那些纯生理的病理的。细思极恐，，膝跳反应居然是是我们自己不能控制的。。再微观一些，我们心脏的跳动也不受我们意志的左右。但，也还好，，倘若心脏怎样跳动，神经怎样感受，血液怎样流淌我们都需要操心的话，那大脑的算力肯定是不够的，，干脆形成一套<a href="https://baike.baidu.com/item/%E8%8C%83%E5%BC%8F/22773?fr=aladdin">范式</a>也好~</p>
<h4 id="愿爱无忧"><a href="#愿爱无忧" class="headerlink" title="愿爱无忧"></a><a href="https://music.163.com/#/song?id=28949131">愿爱无忧</a></h4><p>所以，，冯唐所言极是：</p>
<blockquote>
<p>做人第一原则，自己的事情自己做；第二原则，不给别人添不必要的麻烦。</p>
</blockquote>
<p><strong>愿世界和平！</strong></p>
<p>[^1]: 神：超越人类认知的一种存在，无所谓玉帝 佛祖 上帝 真主。</p>
]]></content>
      <categories>
        <category>呓语</category>
      </categories>
  </entry>
  <entry>
    <title>高墙与鸡蛋</title>
    <url>/2018/01/13/High_walls_and_eggs/</url>
    <content><![CDATA[<h3 id="高墙与鸡蛋"><a href="#高墙与鸡蛋" class="headerlink" title="高墙与鸡蛋"></a>高墙与鸡蛋</h3><blockquote>
<p>转载自 <a href="http://blog.sina.com.cn/s/blog_48f36ce00100e3qd.html">http://blog.sina.com.cn/s/blog_48f36ce00100e3qd.html</a> - by 林少华的博客</p>
</blockquote>
<p>[按：此文是依据村上春树在日本《文艺春秋》杂志（四月号）发表的日语原文翻译的]</p>
<p>　　我作为一个小说家，换句话说，作为以巧妙说谎为职业的人来到这里、来到耶路撒冷市。</p>
<p>　　当然，说谎的不都是小说家。诸位知道，政治家屡屡说谎，外交官和军人说谎，二手车推销员和肉铺和建筑业者也说谎。但小说家说谎和他们说谎的不同之处在于：小说家说谎不受道义上的谴责。莫如说谎说得越大越高明，小说家越能得到人们的赞赏和好评。为什么呢？</p>
<p>　　这是因为，小说家能够通过巧妙说谎、通过栩栩如生的虚构而将真相拽到另一场所投以另一光照。以其固有的形式捕捉真相并予以准确描述在许多情况下是不可能的。惟其如此，我们才要把真相引诱出来移去虚构地带，通过将其置换为虚构形式来抓住真相的尾巴。但为此必须首先在自己心底明确真相的所在，这是巧妙说谎所需要的重要资格。</p>
<p>　　可是今天我不准备说谎，打算尽可能说实话。一年之中我也有几天不说谎，今天恰好是其中的一天。</p>
<p>　　实话实说好了。关于此次来以色列接受耶路撒冷文学奖，不少人劝我最好拒绝。甚至警告说如果前来，将开展不买我的书的运动。无须说，理由在于加沙地区的激战。迄今为止，已不止一千人在被封锁的城区丧生，据联合国报告，大多数是儿童、老人等手无寸铁的平民。</p>
<p>　　接到获奖通知以来，我本人也一再自问：这种时候来以色列接受文学奖果真是妥当的行为吗？不会给人以支持作为纷争当事者一方、拥有占绝对优势的军事力量并积极行使的国家及其方针的印象吗？那当然不是我所希望的。我不认可任何战争，不支持任何国家。同时，自不待言，我的书在书店被人拒买也不是我所希求的。</p>
<p>　　然而，经过深思熟虑，我重新坚定了来这里的决心。原因之一，就在于有那么多人劝我最好别来。或许我有一种大部分小说家都有的“犟脾气”——别人叫我“别去那里”、“别干那个”、尤其那样警告我的时候，我就偏偏想去或想干，此乃小说家的nature（天性）。为什么呢？因为小说家属于这样一种人：无论刮怎样的逆风，也只能相信自己实际目睹、自己实际手摸的东西。</p>
<p>　　正因如此，我才出现在这里。较之不来，选择了来；较之什么也不看，选择了看点儿什么；较之什么也不说，选择了向诸位说点儿什么。</p>
<p>　　有一句话（message）请允许我说出来，一句个人性质的话。这句话在我写小说时总在我脑袋里挥之不去。它并非写在纸上贴在墙壁，而是刻于我的脑壁。那是这样一句话：</p>
<p>　　假如这里有坚固的高墙和撞墙破碎的鸡蛋，我总是站在鸡蛋一边。 </p>
<p>　　是的，无论高墙多么正确和鸡蛋多么错误，我也还是站在鸡蛋一边。正确不正确是由别人决定的，或是由时间和历史决定的。假如小说家站在高墙一边写作——不管出于何种理由——那个作家又有多大价值呢？</p>
<p>　　那么，这一隐喻到底意味什么呢？在某种情况下它是简单明了的。轰炸机、坦克、火箭、白燐弹、机关枪是坚硬的高墙。被其摧毁、烧毁、击穿的非武装平民是鸡蛋。这是这一隐喻的一个含义。</p>
<p>　　但不仅仅是这个，还有更深的含义。请这样设想好了：我们每一个人都或多或少分别是一个鸡蛋，是具有无可替代的灵魂和包拢它的脆弱外壳的鸡蛋。我是，你们也是。再假如我们或多或少面对之于每一个人的坚硬的高墙。高墙有个名称，叫作体制（System）。体制本应是保护我们的，而它有时候却自行其是地杀害我们和让我们杀人，冷酷地、高效地、而且系统性地（Systematiclly）。</p>
<p>　　我写小说的理由，归根结底只有一个，那就是为了让个人灵魂的尊严浮现出来，将光线投在上面。经常投以光线，敲响警钟，以免我们的灵魂被体制纠缠和贬损。这正是故事的职责，对此我深信不疑。不断试图通过写生与死的故事、写爱的故事来让人哭泣、让人惧怕、让人欢笑，以此证明每个灵魂的无可替代性——这就是小说家的工作。我们为此而日复一日地认真编造故事。</p>
<p>　　我的父亲去年夏天去世了，活了九十岁。他是个退休教师，也是个兼职佛教僧侣。在研究生院就读期间被征召入伍，参加了中国大陆的战斗。我小的时候，他每天早上都在饭前向佛坛献上长长的深深的祈祷。一次我问父亲为什么祈祷，他回答为了在战场死去的人，为了在那里——无论友方敌方——失去性命的人。每次看见父亲祈祷的身姿，我都觉得那里似乎漂浮着死亡的阴影。</p>
<p>　　父亲去世了，其记忆——还没等我搞清是怎样的记忆——也彻底消失了。但是，那里漂浮的死亡气息仍留在我的记忆中。那是我从父亲身上继承的少数然而宝贵的事项之一。</p>
<p>　　我在这里想向诸位传达的只有一点：我们都是超越国籍、种族和宗教的一个一个的人，都是面对体制这堵高墙的一个一个的蛋。看上去我们毫无获胜的希望。墙是那么高那么硬，那么冰冷。假如我们有类似获胜希望那样的东西，那只能来自我们相信自己和他人的灵魂的无可替代性并将其温煦聚拢在一起。</p>
<p>请这样想想看。我们每一个人都有可以拿在手中的活的灵魂，体制则没有。不能让体制利用我们，不能让体制自行其是。不是体制创造了我们，而是我们创造了体制。</p>
<p>　　我想对诸位说的仅此一点。</p>
<p>　　荣获耶路撒冷奖，我很感谢。感谢世界很多地方都有看我书的人。我要向耶路撒冷的每一位读者致以谢意。毕竟是因了你们的力量我才出现在这里的。但愿我们能够共同拥有什么——非常有意义的什么。我很高兴得以来此向诸位讲话。</p>
<hr>
<p>英语对照：</p>
<blockquote>
<p>转载自 <a href="http://blog.sina.com.cn/s/blog_65da5f5b0101doa2.html">http://blog.sina.com.cn/s/blog_65da5f5b0101doa2.html</a> - by 背包走天涯的博客</p>
</blockquote>
<p>Good evening. I have come to Jerusalem today as a novelist, which is to say as a professional spinner of lies.</p>
<p>Of course, novelists are not the only ones who tell lies. Politicians do it, too, as we all know. Diplomats and generals tell their own kinds of lies on occasion, as do used car salesmen, butchers and builders. The lies of novelists differ from others, however, in that no one criticizes the novelist as immoral for telling lies. Indeed, the bigger and better his lies and the more ingeniously he creates them, the more he is likely to be praised by the public and the critics. Why should that be? </p>
<p>My answer would be this: namely, that by telling skilful lies–which is to say, by making up fictions that appear to be true–the novelist can bring a truth out to a new place and shine a new light on it. In most cases, it is virtually impossible to grasp a truth in its original form and depict it accurately. This is why we try to grab its tail by luring the truth from its hiding place, transferring it to a fictional location, and replacing it with a fictional form. In order to accomplish this, however, we first have to clarify where the truth-lies within us, within ourselves. This is an important qualification for making up good lies.</p>
<p>Today, however, I have no intention of lying. I will try to be as honest as I can. There are only a few days in the year when I do not engage in telling lies, and today happens to be one of them.</p>
<p>So let me tell you the truth. In Japan a fair number of people advised me not to come here to accept the Jerusalem Prize. Some even warned me they would instigate a boycott of my books if I came. The reason for this, of course, was the fierce fighting that was raging in Gaza. The U.N. reported that more than a thousand people had lost their lives in the blockaded city of Gaza, many of them unarmed citizens–children and old people.</p>
<p>Any number of times after receiving notice of the award, I asked myself whether traveling to Israel at a time like this and accepting a literary prize was the proper thing to do, whether this would create the impression that I supported one side in the conflict, that I endorsed the policies of a nation that chose to unleash its overwhelming military power. Neither, of course, do I wish to see my books subjected to a boycott.</p>
<p>Finally, however, after careful consideration, I made up my mind to come here. One reason for my decision was that all too many people advised me not to do it. Perhaps, like many other novelists, I tend to do the exact opposite of what I am told. If people are telling me– and especially if they are warning me– “Don’t go there,” “Don’t do that,” I tend to want to “go there” and “do that”。 It’s in my nature, you might say, as a novelist. Novelists are a special breed. They cannot genuinely trust anything they have not seen with their own eyes or touched with their own hands.</p>
<p>And that is why I am here. I chose to come here rather than stay away. I chose to see for myself rather than not to see. I chose to speak to you rather than to say nothing.</p>
<p>Please do allow me to deliver a message, one very personal message. It is something that I always keep in mind while I am writing fiction. I have never gone so far as to write it on a piece of paper and paste it to the wall: rather, it is carved into the wall of my mind, and it goes something like this:</p>
<p>“Between a high, solid wall and an egg that breaks against it, I will always stand on the side of the egg.”</p>
<p>Yes, no matter how right the wall may be and how wrong the egg, I will stand with the egg. Someone else will have to decide what is right and what is wrong; perhaps time or history will do it. But if there were a novelist who, for whatever reason, wrote works standing with the wall, of what value would such works be?</p>
<p>What is the meaning of this metaphor? In some cases, it is all too simple and clear. Bombers and tanks and rockets and white phosphorus shells are that high wall. The eggs are the unarmed civilians who are crushed and burned and shot by them. This is one meaning of the metaphor.</p>
<p>But this is not all. It carries a deeper meaning. Think of it this way. Each of us is, more or less, an egg. Each of us is a unique, irreplaceable soul enclosed in a fragile shell. This is true of me, and it is true of each of you. And each of us, to a greater or lesser degree, is confronting a high, solid wall. The wall has a name: it is “The System.” The System is supposed to protect us, but sometimes it takes on a life of its own, and then it begins to kill us and cause us to kill others–coldly, efficiently, systematically.</p>
<p>I have only one reason to write novels, and that is to bring the dignity of the individual soul to the surface and shine a light upon it. The purpose of a story is to sound an alarm, to keep a light trained on the System in order to prevent it from tangling our souls in its web and demeaning them. I truly believe it is the novelist’s job to keep trying to clarify the uniqueness of each individual soul by writing stories–stories of life and death, stories of love, stories that make people cry and quake with fear and shake with laughter. This is why we go on, day after day, concocting fictions with utter seriousness.</p>
<p>My father passed away last year at the age of ninety. He was a retired teacher and a part-time Buddhist priest. When he was in graduate school in Kyoto, he was drafted into the army and sent to fight in China. As a child born after the war, I used to see him every morning before breakfast offering up long, deeply-felt prayers at the small Buddhist altar in our house. One time I asked him why he did this, and he told me he was praying for the people who had died in the battlefield. He was praying for all the people who died, he said, both ally and enemy alike. Staring at his back as he knelt at the altar, I seemed to feel the shadow of death hovering around him.</p>
<p>My father died, and with him he took his memories, memories that I can never know. But the presence of death that lurked about him remains in my own memory. It is one of the few things I carry on from him, and one of the most important.</p>
<p>I have only one thing I hope to convey to you today. We are all human beings, individuals transcending nationality and race and religion, and we are all fragile eggs faced with a solid wall called The System. To all appearances, we have no hope of winning. The wall is too high, too strong–and too cold. If we have any hope of victory at all, it will have to come from our believing in the utter uniqueness and irreplaceability of our own and others’ souls and from our believing in the warmth we gain by joining souls together.</p>
<p>Take a moment to think about this. Each of us possesses a tangible, living soul. The System has no such thing. We must not allow the System to exploit us. We must not allow the System to take on a life of its own. The System did not make us: we made the System.</p>
<p>That is all I have to say to you.</p>
<p>I am grateful to have been awarded the Jerusalem Prize. I am grateful that my books are being read by people in many parts of the world. And I would like to express my gratitude to the readers in Israel. You are the biggest reason why I am here. And I hope we are sharing something, something very meaningful. And I am glad to have had the opportunity to speak to you here today.</p>
<p>Thank you very much.</p>
]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>村上春树</tag>
        <tag>高墙与鸡蛋</tag>
      </tags>
  </entry>
  <entry>
    <title>先行发生原则</title>
    <url>/2019/03/13/Java_happens_before/</url>
    <content><![CDATA[<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>果然，『深入理解Java虚拟机』这本书读一遍是远远不够的，温故总能知新~今天要写的是先行发生原则，说来惭愧，，好像读第一遍的时候并没有太深刻的印象，昨晚再读的时候就拍大腿了：醍醐灌顶啊！！所以，今天还真得扮演搬运工的角色。</p>
<h4 id="啥是先行发生原则"><a href="#啥是先行发生原则" class="headerlink" title="啥是先行发生原则"></a>啥是先行发生原则</h4><p>说到先行发生原则，还得再往前倒倒，说下 Java 内存模型的特征。<br>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这个3个特征来建立的。</p>
<ul>
<li><strong>原子性</strong>(Atommicity): 由 Java 内存模型来直接保证原子性变量的操作，包括 read、load、use、assign、store、write, 大致可以认为基本数据类型的访问读写是具有原子性的(long、double 的非原子性协定除外)。如果场景需要更大范围的保证原子性，则需要 <a href="https://someoneiscoding.com/2019/03/08/about_java_microcosmic_i++/#lock">lock</a> 和 <a href="https://someoneiscoding.com/2019/03/08/about_java_microcosmic_i++/unlock">unlock</a> 操作。反映到 Java 代码中就是同步块– synchronized 关键字。因此，所以 synchronized 块之间的操作也具备原子性。</li>
<li><strong>可见性</strong>(Visibility): Java 内存模型是通过在变量修改后将新值同步回主存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可行性的，无论是普通变量还是 volatile 变量都是如此。只不过，volatile 关键字能保证新值被立即同步回主内存，以及每次使用前从主内存刷新，普通变量则不能保证这一点。<br>  除此之外，synchronized 和 final 关键字也可以保证变量的可见性。同步快的可见性是由『对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中(执行 store 和 write 操作)』这条规则获得的。而 final 关键字的可见性是指: 被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有把 this 的引用传递出去<a href="%5BThis%E5%BC%95%E7%94%A8%E9%80%83%E9%80%B8%E9%97%AE%E9%A2%98%5D(http://www.cnblogs.com/whatisjava/archive/2013/05/29/3106336.html)">^1</a>，那么在其他线程中就能看见 final 字段的值。(最初以为是因为 final 修饰的变量不能被修改，所以导致所有线程读到的值都是一样的，不变的，，然鹅并不是[^2])。</li>
<li><strong>有序性</strong>(Ordering): Java 程序中天然的有序性可以总结为一句话：<strong>如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。</strong>前半句是指“线程内表现为串行的语义(Within-Thread As-If Serial Semantics)”，后半句是指“指令重排序”和“工作内存和主内存同步延迟”线程。<br>  volatile 关键字本身就含有禁止指令重排的语义，而 synchronized 则是由『一个变量在同一时刻只允许一条线程对其进行 lock 操作。』这条规则获得的，这条规则决定了持有同一个锁( lock 操作的变量)的两个同步块只能串行的进入。</li>
</ul>
<p>好像 synchronized 关键字在需要这3种特性的时候都可以作为其中一种解决方案，于此同时其万能的属性导致了被我们程序员滥用。。<br>　<br>逼逼叨半天，还是没提到啥是先行发生原则。。别急，马上。。<br>如果 Java 内存模型中所有的有序性都靠 volatile 和 synchronized 来完成，那么有一些操作将变得非常繁琐，然鹅我们在写代码的过程中并没有感受到这一点，这就是因为『先行发生原则』。它是判断数据是否存在竞争、线程是否安全的主要依据。<br>先行发生是在 Java 内存模型中定义两项操作之间的偏序关系，如果说操作 A先行发生于操作 B，则说明发生操作B之前，操作 A 产生的影响能被操作 B 观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以下操作在线程 A 中执行</span><br>i = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 以下操作在线程 B 中执行</span><br>j = i;<br><br><span class="hljs-comment">// 以下操作在线程 C 中执行</span><br>i = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>
<p>👆 假设线程 A 中的操作”i &#x3D; 1”先行发生于线程 B 的操作”j &#x3D; i”, 那么可以确定的是线程 B 的操作执行后，变量 j 一定等于 1，得出这个结论的依据有两个：</p>
<ol>
<li>根据先行发生原则，”i &#x3D; 1”的结果可以被观察到；</li>
<li>线程 C 还没”登场”, 线程 A 操作结束之后没有其他线程会修改变量 i 的值。现在再来考虑线程 C，我们依然保持线程 A 和线程 B 之间的先行发生关系，而线程 C 出现在线程 A 和线程 B 的操作之间，但是线程 C 与线程 B 没有先行发生关系，那 j 的值就无法确定了。</li>
</ol>
<p>下面是 Java 内存模型中一些”天然”的先行发生关系，它们无须任何同步器的协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则中推导出来的话，他们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<ul>
<li><strong>程序次序原则</strong>(Program Order Rule): 在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于写在后面的操作。准确来说是程序流顺序而不是代码顺序，因为要考虑分支和循环。</li>
<li><strong>管程锁定原则</strong>(Monitor Lock Rule): 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。这里必须强调的是同一个锁，而”后面”是指时间上的先后顺序。</li>
<li><strong>volatile 变量规则</strong>(Volatile Variable Rule): 对于一个volatile 变量的写操作先行发生于后面对这个变量的读操作，这里的”后面”同样是指时间上的先后。</li>
<li><strong>线程启动规则</strong>(Thread Start Rule): Thread 对象的 start() 方法先行发生于此线程的每一个动作。</li>
<li><strong>线程终止规则</strong>(Thread Termination Rule): 线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值等手段检测到线程已经终止运行。</li>
<li><strong>线程中断原则</strong>(Thread Interruption Rule): 线程中的所有操作都先行发生于被中断线程的代码检测到中断事件的发生，可以通过 Thread.interrupted() 方法检测到是否有中断发生。</li>
<li><strong>对象终结原则</strong>(Finalizer Rule): 一个对象的初始化完成(构造函数执行结束)先行发生于它的 finalize()[^3]法的开始。</li>
<li><strong>传递性</strong>(Transitivity): 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，则操作 A 先行发生于操作 C。</li>
</ul>
<p>举个栗子：👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span>&#123;<br>    <span class="hljs-built_in">this</span>.value = value;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面👆的代码为最普通的 getter&#x2F;setter 方法。假设存在线程 A 和 B，线程 A 先(时间上的先)调用了”setValue(1)”，然后线程 B 调用了同一个对象的”getValue()”，那么线程 B 收到的返回值为多少？</p>
<p>由两个方法分别为线程 A 和线程 B 调用，不在同一个线程中，所以程序次序规则在这里不适用；由于没有同步块，自然不会发生 lock 和 unlock 操作，所以管程锁定规则也不适用；由于 value 变量没有被 volatile 修饰，所以 volatile 变量规则在这里也不适用；后面的线程启动、终止、中断规则和对象终结规则也和这里完全没有关系。因为没有一个适用的先行发生规则，所以最后一条传递性也无从谈起。因此，我们可以判定：尽管线程 A 在操作时间上先于线程 B，但是无法确定线程 B 中 getValue() 方法的返回值，即这里的操作不是线程安全的。</p>
<p>解决方式也很简单，要么把 getter&#x2F;setter 方法都定义为 synchronized 方法，这样就可以适用于管程锁定规则；要么把 value 定义为 volatile 变量，由于 setter 方法对 value 值的修改不依赖 value 的原值，满足 volatile 关键字使用场景，这样就可以套用 volatile 变量规则来满足先行发生原则。<br>通过上面的例子，，我们可以得出一个结论：**一个操作”时间上的先发生”不代表这个操作会是”先行发生”，那如果一个操作”先行发生”是否就能对导出这个操作必定是”时间上的先发生”呢？很遗憾，同样也不能，一个典型的例子就是”指令重排序”**。👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 下面操作在同一个线程中执行</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> i;<br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure>
<p>👆根据程序次序规则，<code>int i = 1;</code>先行发生于<code>int j = 2;</code>但是<code>int j = 2;</code>的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程中是无法感知到这点的。</p>
<p>[^2]: <a href="https://www.jianshu.com/p/cba722d994fa">Java的Final 关键字的内存语义</a></p>
<p>[^3]: <a href="https://www.jb51.net/article/125728.htm">Java 禁止使用 finalizer 方法</a></p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>管程：并发编程的万能钥匙</title>
    <url>/2019/08/03/Monitor-The_Universal_Key_of_Concurrent_Programming/</url>
    <content><![CDATA[<p>节选自 <a href="http://gk.link/a/106Xr">王宝令-Java变法编程实战</a>，欢迎大家订阅~</p>
<h4 id="什么是管程"><a href="#什么是管程" class="headerlink" title="什么是管程"></a>什么是管程</h4><p>不知道你是否曾经思考过这个问题：为什么 Java 在 1.5 之前仅仅提供了 <code>synchronized</code> 关键字及 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 这三个看似从天而降的方法？在刚刚接触 Java 的时候，我以为它会提供信号量这种编程原语，因为操作系统原理课程告诉我，用信号量能解决所有并发问题，结果我发现不是。后来我找到了原因：Java 采用的是管程技术，<code>synchronized</code> 关键字及 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 这三个方法都是管程的组成部分。而<strong>管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程</strong>。但是管程更加容易使用，所以 Java 选择了管程。</p>
<p>管程，对应的英文是 Monitor，很多 Java 领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这个是意译，而我自己也更倾向于使用“管程”。</p>
<p>所谓<strong>管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发。翻译为 Java 领域的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的</strong>。那管程是怎么管的呢？</p>
<h4 id="MESA模型"><a href="#MESA模型" class="headerlink" title="MESA模型"></a>MESA模型</h4><p>在管程的发展史上，先后出现过三种不同的管程模型，分别是：Hasen模型、Hoare模型和 MESA 模型。其中，现在广泛应用的是 MESA 模型，并且 Java 管程的实现也是参考 MESA 模型。所以今天我们重点介绍一下 MESA 模型。</p>
<p>在并发编程领域，有两大核心问题：一个是<strong>互斥，即同一时刻只允许一个线程访问共享资源</strong>；另一个是<strong>同步，即线程之间如何通信、协作</strong>。这两大问题，管程都是能购解决的。</p>
<p>我们先来看看管程是如何解决互斥问题的。</p>
<p><strong>管程解决互斥问题的思路很简单，就是将共享变量及其对共享变量的操作统一封装起来</strong>。在下图中，<code>管程 X</code> 将共享变量 <code>queue</code> 这个队列和相关的操作入队 <code>enq()</code>、出队 <code>deq()</code> 都封装起来了；<code>线程 A</code> 和<code>线程 B</code> 如果想访问共享变量 <code>queue</code>，只能通过调用管程提供的 <code>enq()</code> 、<code>deq()</code> 方法来实现；<code>enq()</code> 、<code>deq()</code> 保证互斥性，只允许一个线程进入管程。不知你与没有发现，<strong>管程模型和面向对象是高度契合的</strong>。估计这也是 Java 选择管程的原因吧。</p>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131636-%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8C%96%E8%AF%AD%E4%B9%89.png" alt="管程模型的代码化语义"></p>
<p>那管程是如何解决线程间的同步问题呢？</p>
<p>这个就比较复杂了，不过你可以借鉴一下我们曾经提到过的就已流程，它可以帮你快速地理解这个问题。为进一步便于你理解，在下面👇，我展示了一副 MESA 的管程模型示意图，它详细的描述了 MESA 模型的主要组成部分。</p>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-MESA%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="MESA管程模型"></p>
<p>在管程模型里，共享变量和对共享变量的操作是被封装起来的，👆图中最外层的框就代表封装的意思。框的上面只有一个入口，并且在入口旁边还有一个入口等待队列。当多个线程同时进入管程内部时，只允许一个线程进入，其他线程则在入口等待队列中等待。这个过程类似就医流程的分诊，只允许一个患者就诊，其他患者在门口等待。</p>
<p>管程里还引入了条件变量的概念，而且<strong>每个条件变量都对应有一个等待队列</strong>，条件变量 A 和条件变量 B 分别都有自己的等待队列。<strong>条件变量和等待队列的作用其实就是解决线程同步问题</strong>。你也可以结合上面提到的入队出队例子加深一下理解。</p>
<p>假设有个<code>线程 T1</code> 执行出队操作，不过需要注意的是执行出队操作，有个前提条件，就是队列不能是空的，而队列不为空这个前提条件就是管程的条件变量。如果<code>线程 T1</code>进入管程后恰好发现队列是空的，那就只能去“队列不为空”这个条件变量队列里等待了。这个过程类似大夫给你开了单子让你去验血，你就去验血窗口排队去了。<code>线程 T1</code> 进入条件变量的等待队列后，是允许其他线程进入管程的。这个你去验血的时候，医生可以给其他患者诊治，道理是一样的。</p>
<p>再假设之后<strong>另外一个<code>线程 T2</code>执行入队操作，入队操作执行成功之后，“队列不为空”这个条件对于<code>线程 T1</code>来说已经满足了，此时<code>线程 T2</code>要通知<code>T1</code>，告诉它需要的条件已经满足了。当<code>线程 T1</code>得到通知后，会从等待队列里面出来，但是出来后不是马上执行，而是重新进入到入口等待队列里面</strong>。这个过程类似你验血回来找大夫，需要重新分诊排队。</p>
<p>条件变量及其等待队列我们讲清楚了，下面再说说 <code>wait()</code>、<code>notigy()</code>、<code>notifyAll()</code>这三个操作。前面提到<code>线程 T1</code>发现“队列不为空”这个条件不满足，需要进到对应的等待队列里等待。这个过程就是通过调用<code>wait()</code>来实现的。如果我们用对象 A 代表“队列不为空”这个条件，那么<code>线程 T1</code>需要调用 <code>A.wait()</code> 。同理当“队列不为空”这个条件满足时，<code>线程 T2</code>需要调用 <code>A.notify()</code>来通知 A 等待队列中的一个线程，此时这个队列里面只有<code>线程 T1</code>。至于 <code>notigAll()</code>这个方法，它可以通知等待队列中的所有线程。</p>
<p>这里我们还是来一段代码再次说明一下吧。下面的代码实现的是一个阻塞队列，阻塞队列有两个操作分别是入队和出队，这两个方法都是先互相获取互斥锁，类比管程模型中的入口。</p>
<ol>
<li>对于入队操作，如果队列已满，就需要等待至队列不满，所以这里用了<code>notFull.await()</code>;</li>
<li>对于出队操作，如果队列为空，就需要等待至队列不为空，所以就用了<code>notEmpty.await()</code>;</li>
<li>如果入队成功，所以队列就不为空了，就需要通知条件变量：队列不为空 <code>notEmpty</code> 对应的等待队列。</li>
<li>如果出队成功，那队列就不满了，就需要通知条件变量：队列不满 <code>notFull</code> 对应的等待队列。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockQueue</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 条件变量：notFull</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// 条件变量：notEmpth</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <br>    <span class="hljs-comment">// 入队</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">enq</span><span class="hljs-params">(T x)</span>&#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">while</span>(队列已满)&#123;<br>                <span class="hljs-comment">// 等待队列不满</span><br>                notFull.await();<br>            &#125;<br>            <span class="hljs-comment">// do 入队操作</span><br>            <span class="hljs-comment">// 入队后，通知可出队</span><br>            notEmpty.signal();<br>        &#125;fianlly&#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>   <span class="hljs-comment">// 出队</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">deq</span><span class="hljs-params">()</span>&#123;<br>       lock.lock();<br>       <span class="hljs-keyword">try</span>&#123;<br>           <span class="hljs-keyword">while</span>(队列已空)&#123;<br>               <span class="hljs-comment">// 等待队列不空</span><br>               notEmpty.await();<br>           &#125;<br>           <span class="hljs-comment">// do 出队操作</span><br>           <span class="hljs-comment">// 出队后，通知可入队</span><br>           notFull.signal();<br>       &#125;<span class="hljs-keyword">finally</span>&#123;<br>           lock.unlock();<br>       &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这段代码👆中，我们用了 Java 并发包里面的 <code>Lock</code> 和 <code>Condition</code>，如果你看着吃力，也没关系，后面我们还会详细介绍，这个例子只是先让你明白条件变量及其等待队列是怎么回事。需要注意的是：<code>await()</code> 和 前面我们提到的 <code>wait()</code> 的语义是一样的；<code>signal()</code> 和前面我们提到的 <code>notify()</code> 语义是一样的。</p>
<h4 id="wait-的正确姿势"><a href="#wait-的正确姿势" class="headerlink" title="wait() 的正确姿势"></a>wait() 的正确姿势</h4><p>但是有一点，需要再次提醒，<strong>对于 MESA 管程来说，有一个编程范式，就是需要在一个 <code>while</code> 循环中调用 <code>wait()</code>，这个是 MESA管程特有的</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(条件不满足)&#123;<br>    wait();<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>Hasen 模型里面，要求 <code>notify()</code> 放在代码的最后，这样 <code>T2</code> 通知完 <code>T1</code> 后，<code>T2</code> 就结束了，然后 <code>T1</code> 再执行。这样就能保证同一时刻只有一个线程执行。</li>
<li>Hoare 模型里面，<code>T2</code> 通知完 <code>T1</code> 后，<code>T2</code> 阻塞， <code>T1</code> 马上执行；等 <code>T1</code> 执行完，再唤醒 <code>T2</code>，也能保证同一时刻只有一个线程执行。但是相比 Hesen 模型，<code>T2</code> 多了一个阻塞唤醒操作。</li>
<li>MESA 管程里面，T2 通知完 T1 后， T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进入到入口等待队列里面。这样做的好处是 <code>notify()</code>不用放在代码最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环的方式检验条件变量。</li>
</ol>
<h4 id="notify-何时可以使用"><a href="#notify-何时可以使用" class="headerlink" title="notify() 何时可以使用"></a>notify() 何时可以使用</h4><p>还有一个需要注意的地方，就是 <code>notify()</code> 和 <code>notifyAll()</code> 的使用，前面章节，我曾经介绍过，**除非经过深思熟虑，否则尽量使用 <code>notifyAll()</code>**。那么什么时候可以使用 <code>notify()</code> 呢？需要满足以下三个条件：</p>
<ol>
<li>所有等待线程拥有相同的等待条件；</li>
<li>所有等待线程被唤醒后，执行相同的操作；</li>
<li>只需要唤醒一个线程。</li>
</ol>
<p>比如上面阻塞队列的例子中，对于“队列不满”这个条件变量，其阻塞队列里的线程都是在等待“队列不满”这个条件，反映在代码里就是下面👇三行代码。对所有等待线程来说，都是执行这三行代码，重点是 <code>while</code> 里面的等待条件是完全相同的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(队列已满)&#123;<br>    <span class="hljs-comment">// 等待队列不满</span><br>    notFull.await();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所有等待线程被唤醒后执行的操作也是相同的，都是下面👇几行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 省略入队操作...</span><br><span class="hljs-comment">// 入队后，通知可出队</span><br>notEmpty.signal();<br></code></pre></td></tr></table></figure>

<p>同时也满足第三条，只需要唤醒一个线程。所以上面👆阻塞队列的代码，使用 signal() 是可以的。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Java 参考了 MESA 模型，语言内置的管程(<code>synchronized</code>)对 MESA 模型进行了精简。MESA 模型中，条件变量可以有多个，Java 语言内置的管程里只有一个条件变量。具体如下图👇所示。</p>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-java%E4%B8%AD%E7%9A%84%E7%AE%A1%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Java 中的管程示意图"></p>
<p>Java 内置的管程方法(<code>synchronized</code>)使用简单，**<code>synchronized</code>关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量；而 Java SDK 并发包实现的管程支持多个条件变量，不过并发包里的锁，需要开发者自己进行加锁和解锁操作**。</p>
<p>并发编程里两大核心问题—互斥和同步，都可以由管程来帮你解决。学好管程，理论上所有的并发问题都可以解决，并且很多并发工具类的底层都是管程实现的，所以学好管程，就相当于掌握了一把并发编程的钥匙。</p>
<h4 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h4><ol>
<li><p><code>wait()</code>方法，在 Hasen 模型和 Hoare 模型中都是没有参数的，而在 MESA 模型里面，增加了超时参数，你觉得这个参数有必要么？</p>
<p>有。Hasen 模型是执行完，再去唤醒另外一个线程，能保证线程的执行。Hoare 模型是中断当前线程，唤醒另外一个线程，执行完再去唤醒，也能够保证执行。而 MESA 是进入条件等待队列，不一定有机会能够执行。</p>
</li>
<li><p>针对条件变量的 <code>while</code> 循环，还是不太理解，您说是范式，那它一定是为了解决特定的场景而强烈推荐的，也有评论说是为了解决虚假唤醒，但唤醒后，不也是从条件的等待队列进入到入口的等待队列，抢到锁后，重新进行条件变量的判断，用 <code>if</code> 完全可以啊，为什么必须是 <code>while</code>，并且是范式？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">code1;<br><span class="hljs-keyword">if</span>(条件不满足)&#123;<br>    wait();<br>&#125;<br>code2;<br></code></pre></td></tr></table></figure>

<p>以上👆代码中，当调用 <code>wait()</code>时，阻塞。被唤醒时，就直接执行 <code>code2 </code>了，没机会重新判断。</p>
<p>使用 <code>while</code> 范式，如果 A 线程 <code>wait</code> 了，而且未设置超时时间。由于代码 bug，没有其他线程 <code>notify</code> ，就会导致 A 线程一直 <code>wait</code>。增加超时时间后，A 线程可以自己决定是否继续等待。这样代码的健壮性会更好。</p>
<p>简单来说，一个锁实际上对应两个队列，，一个就绪队列，对应入口等待队列；一个是阻塞队列，实际对应条件变量等待队列。<code>wait</code> 操作是把当前线程放入条件变量的等待队列中，而 <code>notifyAll</code> 是将条件变量等待队列中的所有线程唤醒到就绪队列(入口等待队列)中，实际上哪个线程执行由 JVM 操作。</p>
</li>
<li><p>对信号量和管程的理解</p>
<p>&#x2F;&#x2F; TODO 信号量</p>
<p>管程是定义了一个数据结构和能为并发执行的一组操作，这组操作能够进行同步和改变管程中的数据。这相当于对临界资源的同步操作都集中进行管理，凡是要访问临界资源的进程或线程，都必须先通过管程，由管程的这套机制来实现多进程或线程对同一临界资源的互斥和使用。管程的同步主要通过 condition 类型的变量(条件变量)，条件变量可执行 <code>await()</code> 和 <code>signal()</code> 操作。管程一般是有语言编译器进行封装，体现在 OOP 中的封装思想，也如老师所说的，管程和面向对象高度契合。</p>
</li>
<li><p>文中说到的条件变量，假如 <code>synchronized(instance)&#123;// do something;&#125;</code>，这样一段代码，程序实际运行过程中条件变量是什么呢？</p>
<p>没用到条件变量，只有调用 <code>wait</code> 和 <code>notify</code> 的时候才会用到。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Object::wait|notify</title>
    <url>/2023/02/12/Object_wait_notify/</url>
    <content><![CDATA[<h3 id="Object-wait-最佳实践"><a href="#Object-wait-最佳实践" class="headerlink" title="Object::wait 最佳实践"></a>Object::wait 最佳实践</h3><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>在 <code>Object::wait</code> 的方法注释中有这样一句：</p>
<blockquote>
<p>As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>   <span class="hljs-keyword">while</span> (&amp;lt;condition does not hold&amp;gt;)<br>       obj.wait();<br>   ... <span class="hljs-comment">// Perform action appropriate to condition</span><br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p>大意是 <code>Object::wait</code> 的最佳实践是放在循环体中使用，循环体之后是获取锁资源后真实执行的同步代码。</p>
<p>与此同时，我们在网上找到好多使用 <code>if</code> 代替 <code>while</code> 相关的 <code>wait</code> 代码，比如 <a href="https://blog.csdn.net/agonie201218/article/details/125314410">java JUC 中 Object里wait()、notify() 实现原理及实战讲解</a>、<a href="https://segmentfault.com/a/1190000018096174">Java 多线程编程之：notify 和 wait 用法</a>。当然，也有讨论为什么 wait 要放在 loop 中使用的文章：<a href="https://blog.csdn.net/fengg5241/article/details/7551270">论Object.wait()要放到while循环里</a>。文章都能看懂，但以前两篇文章为例，用 <code>if</code> 好像也没什么问题。</p>
<h4 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h4><p>接下来，以下题为例讨论一下：</p>
<blockquote>
<p>启动两个线程, 一个输出 1,3,5,7…99，另一个输出 2,4,6,8…100， 最后 STDOUT 中按序输出 1,2,3,4,5…100。</p>
</blockquote>
<h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>题目中的题眼在于『按序输出 1,2,3,4,5…100』中的『按序』。如果单单是启动两个线程，一个输出奇数，一个输出偶数，很简单。只要控制好打印条件<code>i%2</code>即可，但输出顺序无法保证，有可能得到</p>
<blockquote>
<p>1 3 5 2 4 7…</p>
</blockquote>
<p>所以需要引入互斥资源，保证交替打印。以下是我给出的第一份解法：👇🏻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 独占式对象资源</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-comment">// 代码需要 main 方法中执行，不要使用 @Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] arg)</span>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (r1)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i&lt;= <span class="hljs-number">100</span>; ++i)&#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">// 输出单数</span><br>                    System.out.println(<span class="hljs-string">&quot;t1: &quot;</span> + i);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 通知输出双数</span><br>                        r1.notifyAll();<br>                        <span class="hljs-comment">// 当前线程主动阻塞，最后一次不阻塞</span><br>                        <span class="hljs-keyword">if</span>(i != <span class="hljs-number">99</span>)&#123;<br>                            r1.wait();<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                 &#125;<br>             &#125;<br>         &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>  <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (r1)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i&lt;= <span class="hljs-number">100</span>; ++i)&#123;<br>                <span class="hljs-comment">// 输出双数</span><br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;t2: &quot;</span> + i);<br>                    <span class="hljs-comment">// 通知单数执行</span><br>                    r1.notifyAll();<br>                    <span class="hljs-comment">// 最后一次不阻塞</span><br>                    <span class="hljs-keyword">if</span>(i != <span class="hljs-number">100</span>)&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            r1.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                     &#125;<br>                 &#125;<br>             &#125;<br>         &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>代码中在执行 <code>wait</code> 语句时使用的是 <code>if</code> ，最后输出的结果没啥问题。</p>
<p>我们将<code>for</code> 循环体中的逻辑改成范式试试看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 引入公共变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// t1</span><br><span class="hljs-keyword">for</span> (; i&lt;= <span class="hljs-number">100</span>; ++i)&#123;<br>    <span class="hljs-comment">// i 为偶数则阻塞</span><br>    <span class="hljs-keyword">while</span>(i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            r1.wait();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">100</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;t1: &quot;</span> + i);<br>    &#125;<br>    r1.notifyAll();<br>&#125;<br><br><span class="hljs-comment">// t2</span><br><span class="hljs-keyword">for</span> (; i&lt;= <span class="hljs-number">100</span>; ++i)&#123;<br>    <span class="hljs-comment">// i 为奇数，则阻塞</span><br>    <span class="hljs-keyword">while</span>(i%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            r1.wait();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i &lt;= <span class="hljs-number">100</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;t2: &quot;</span> + i);<br>    &#125;<br>    r1.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>改造后，运行结果与原来无异。以上👆🏻面的改造为基础，单纯把 <code>while</code> 改造成 <code>if</code> 对结果也是没影响的。为什么呢？</p>
<p>因为只有两个线程，且每次 <code>i++</code> 都会满足另外一个线程中同步代码块的条件，完全不存在 <strong>虚假唤醒</strong> ！此时，我们需要像魏成一样，引入第三个球体。</p>
<h4 id="引入第三个变量"><a href="#引入第三个变量" class="headerlink" title="引入第三个变量"></a>引入第三个变量</h4><p>此时，题目由原来的两个线程变成三个线程，同时启动，交替打印t1:1 t2:2 t3:3 t4:4 t5:5 t6:6… 即，3*+1 3*+2 3*+3</p>
<figure class="highlight java"><figcaption><span>mark:10</span></figcaption><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">// 引入公共变量</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] arg)</span>&#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (r1)&#123;<br>            System.out.println(<span class="hljs-string">&quot;t1 get r1. i= &quot;</span> + i);<br>            <span class="hljs-keyword">for</span> (; i&lt;= <span class="hljs-number">100</span>; ++i)&#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span> != <span class="hljs-number">1</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;t1 before wait.&quot;</span>);<br>                        r1.wait();<br>                        System.out.println(<span class="hljs-string">&quot;t1 waited.&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">if</span>&lt;=<span class="hljs-number">100</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;t1: &quot;</span> + i);  <br>                &#125;<br>                r1.notifyAll();<br>                System.out.println(<span class="hljs-string">&quot;t1 after notify i: &quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (r1)&#123;<br>            System.out.println(<span class="hljs-string">&quot;t2 get r1. i= &quot;</span> + i);<br>            <span class="hljs-keyword">for</span> (; i&lt;= <span class="hljs-number">100</span>; ++i)&#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span> != <span class="hljs-number">2</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;t2 before wait.&quot;</span>);<br>                        r1.wait();<br>                        System.out.println(<span class="hljs-string">&quot;t2 waited.&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i &lt;= <span class="hljs-number">100</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;t2: &quot;</span> + i);<br>                &#125;<br>                r1.notifyAll();<br>                System.out.println(<span class="hljs-string">&quot;t2 after notify i: &quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (r1)&#123;<br>            System.out.println(<span class="hljs-string">&quot;t3 get r1. i= &quot;</span> + i);<br>            <span class="hljs-keyword">for</span> (; i&lt;= <span class="hljs-number">100</span>; ++i)&#123;<br>                <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span> != <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;t3 before wait.&quot;</span>);<br>                        r1.wait();<br>                        System.out.println(<span class="hljs-string">&quot;t3 waited.&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i &lt;= <span class="hljs-number">100</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;t3: &quot;</span> + i);<br>                &#125;<br>                r1.notifyAll();<br>                System.out.println(<span class="hljs-string">&quot;t3 after notify i: &quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t3&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上我们使用的是 <code>if</code> ，结果如下：</p>
<blockquote>
<p>t1 get r1. i&#x3D; 1<br>t1: 1<br>t1 after notify i: 1<br>t1 before wait.                  &#x2F;&#x2F; t1 阻塞，进入monitor WAIT_SET 条件等待队列<br>t2 get r1. i&#x3D; 2<br>t2: 2<br>t2 after notify i: 2              &#x2F;&#x2F; t2 唤醒所有线程，t1 进入 ENTRY_SET 入口等待队列<br>t2 before wait.                   &#x2F;&#x2F; t2 阻塞<br>t1 waited.                           &#x2F;&#x2F; t1获取独占锁，但此时并不满足 i%3 !&#x3D; 1条件，不应向下执行。 ❌<br>t1: 3                                     &#x2F;&#x2F; 我们的期望是 t3 输出 3 ❌<br>t1 after notify i: 3<br>t1: 4<br>t1 after notify i: 4<br>t1 before wait.</p>
</blockquote>
<p>此时将上述 <code>wait</code> 代码块中的 <code>if </code> 改为 <code>while</code> 可完美解决问题。 </p>
<p>可能有同学说了，那我把三个循环都改成这样，成不成啊？👇🏻</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (; i&lt;= <span class="hljs-number">100</span>; ++i)&#123;<br>    <span class="hljs-keyword">if</span>(i%<span class="hljs-number">3</span> == <span class="hljs-number">1</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;t1: &quot;</span> + i);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        r1.notifyAll();<br>        <span class="hljs-comment">// 当前线程主动阻塞，最后一次不阻塞</span><br>        r1.wait();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>那肯定不成啊。能保证三个线程依次获取锁资源么？妥妥不能，为啥？<code>synchronized</code> 是非公平锁喔~最后输出的没准儿是这样：</p>
<blockquote>
<p>t1: 1<br>t1: 4<br>t1: 7<br>t3: 12<br>t1: 13<br>t2: 14</p>
</blockquote>
<p>最终的是，<code>wait</code> 代码放最后，打印结束之后谁来唤醒呢？最后三个线程都一直处于阻塞状态，服务器要崩…</p>
<h4 id="扩展：使用-ReentrantLock-和-Condition-该如何实现呢？"><a href="#扩展：使用-ReentrantLock-和-Condition-该如何实现呢？" class="headerlink" title="扩展：使用 ReentrantLock 和 Condition 该如何实现呢？"></a>扩展：使用 ReentrantLock 和 Condition 该如何实现呢？</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">for</span> (; i&lt;=<span class="hljs-number">100</span>; i++)&#123;<br>            <span class="hljs-keyword">while</span>(i%<span class="hljs-number">3</span> != <span class="hljs-number">1</span>)&#123;<br>                c1.await();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">100</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;t1: &quot;</span> + i);<br>            &#125;<br>            c1.signalAll();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">for</span> (; i&lt;=<span class="hljs-number">100</span>; i++)&#123;<br>            <span class="hljs-keyword">while</span>(i%<span class="hljs-number">3</span> != <span class="hljs-number">2</span>)&#123;<br>                c1.await();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">100</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;t2: &quot;</span> + i);<br>            &#125;<br>            c1.signalAll();<br>         &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          e.printStackTrace();<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>          lock.unlock();<br>    &#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">for</span> (; i&lt;=<span class="hljs-number">100</span>; i++)&#123;<br>            <span class="hljs-keyword">while</span>(i%<span class="hljs-number">3</span> != <span class="hljs-number">0</span>)&#123;<br>                c1.await();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">100</span>)&#123;<br>                System.out.println(<span class="hljs-string">&quot;t3: &quot;</span> + i);<br>            &#125;<br>            c1.signalAll();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>

<p>或者使用 <code>signal</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> lock.newCondition();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">for</span> (; i&lt;=<span class="hljs-number">100</span>; i++)&#123;<br>            <span class="hljs-keyword">while</span>(i%<span class="hljs-number">3</span> != <span class="hljs-number">1</span>)&#123;<br>                  c1.await();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">100</span>)&#123;<br>                  System.out.println(<span class="hljs-string">&quot;t1: &quot;</span> + i);<br>            &#125;<br>            c2.signal();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>          lock.unlock();<br>    &#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">for</span> (; i&lt;=<span class="hljs-number">100</span>; i++)&#123;<br>            <span class="hljs-keyword">while</span>(i%<span class="hljs-number">3</span> != <span class="hljs-number">2</span>)&#123;<br>                  c2.await();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">100</span>)&#123;<br>                  System.out.println(<span class="hljs-string">&quot;t2: &quot;</span> + i);<br>            &#125;<br>            c3.signal();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>          lock.unlock();<br>    &#125;<br>&#125;).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">for</span> (; i&lt;=<span class="hljs-number">100</span>; i++)&#123;<br>            <span class="hljs-keyword">while</span>(i%<span class="hljs-number">3</span> != <span class="hljs-number">0</span>)&#123;<br>                  c3.await();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;=<span class="hljs-number">100</span>)&#123;<br>                  System.out.println(<span class="hljs-string">&quot;t3: &quot;</span> + i);<br>            &#125;<br>            c1.signal();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>          lock.unlock();<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>普鲁斯特问卷-2017</title>
    <url>/2018/01/02/ProustQA_2017/</url>
    <content><![CDATA[<h3 id="普鲁斯特问卷-2017"><a href="#普鲁斯特问卷-2017" class="headerlink" title="普鲁斯特问卷-2017"></a>普鲁斯特问卷-2017</h3><p>这份问卷本应该在2017-12-31完成，但赶上，，到底有没有另一个世界？安好，，</p>
<hr>
<ol>
<li>你认为最完美的快乐是怎样的？<br><strong>见到最想见的人，如果能有个拥抱就更好了~</strong></li>
<li>你最希望拥有哪种才华？<br><strong>把问题抽象成数学模型，再转化为编程语言~</strong></li>
<li>你最恐惧的是什么？<br><strong>时光飞逝..</strong></li>
<li>你目前的心境怎样？<br><strong>有点困，不想睡觉，还有点浮躁，，想赶紧学好微信的小程序</strong></li>
<li>还在世的人中你最钦佩的是谁？<br><strong>埃隆马斯克吧，虽然他不是程序员</strong></li>
<li>你认为自己最伟大的成就是什么？<br><strong>有么？</strong></li>
<li>你自己的哪个特点让你最觉得痛恨？<br><strong>怂？我希望自己能够坚定更一点。</strong></li>
<li>你最喜欢的旅行是哪一次？<br><strong>大三暑假从哈尔滨搭车去满洲里</strong></li>
<li>你最痛恨别人的什么特点？<br><strong>站着说话不腰疼，，</strong></li>
<li>你最珍惜的财产是什么？<br><strong>『信』</strong>，，言而有信的信</li>
<li>你最奢侈的是什么？<br><strong>现在拥有的一切都挺奢侈的</strong></li>
<li>你认为程度最浅的痛苦是什么？<br><strong>口腔溃疡？</strong></li>
<li>你认为哪种美德是被过高的评估的？<br><strong>『传统美德』</strong></li>
<li>你最喜欢的职业是什么？<br>我现在在做的工作–<strong>程序员</strong></li>
<li>你对自己的外表哪一点不满意？<br><strong>脸左右不对称</strong>！！！</li>
<li>你最后悔的事情是什么？<br><strong>大学以前对计算机的了解太狭隘</strong></li>
<li>还在世的人中你最鄙视的是谁？<br><strong>标题档，傻哔标题档，，以及一切恶意带节奏的媒体工作者！！！</strong></li>
<li>你最喜欢男性身上的什么品质？<br><strong>慷慨</strong></li>
<li>你使用过的最多的单词或者是词语是什么？<br><strong>Enjoy</strong></li>
<li>你最喜欢女性身上的什么品质？<br><strong>优雅</strong></li>
<li>你最伤痛的事是什么？<br>失恋吧，，由<strong>最亲爱的人变成最不耐烦的人</strong></li>
<li>你最看重朋友的什么特点？<br><strong>『信』</strong></li>
<li>你这一生中最爱的人或东西是什么？<br>到目前为止，，应该是<strong>苹果电脑</strong>吧</li>
<li>你希望以什么样的方式死去？<br><strong>猝死？也可以是安乐死，，不要太狰狞</strong></li>
<li>何时何地让你感觉到最快乐？<br><strong>午后睡醒，一杯热咖啡，，听着网易云敲代码</strong></li>
<li>如果你可以改变你的家庭一件事，那会是什么？<br><strong>不要让贫穷限制我们的想象力</strong></li>
<li>如果你能选择的话，你希望让什么重现？<br><strong>希望姑父和爷爷没有生病，，健康重现</strong></li>
<li>你的座右铭是什么？<br><strong>奋力无悔，尽力无愧，，经历过就是财富！</strong>高中时的</li>
</ol>
]]></content>
      <categories>
        <category>ProustQA</category>
      </categories>
      <tags>
        <tag>普鲁斯特问卷</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>普鲁斯特问卷-2019</title>
    <url>/2020/01/01/ProustQA_2019/</url>
    <content><![CDATA[<p>🕯🕯🕯<br><span style="color:white;">今天给阿妈打电话的时候，得知三奶奶也走了，你们要好好的，互相照顾喔。</span></p>
<hr>
<ol>
<li>你认为最完美的快乐是怎样的？<br><strong>内心的平静</strong></li>
<li>你最希望拥有哪种才华？<br><strong>还是将问题抽象成代码的能力</strong></li>
<li>你最恐惧的是什么？<br><strong>变老</strong></li>
<li>你目前的心境怎样？<br><strong>有点焦虑，，关于年龄，关于未来</strong></li>
<li>还在世的人中你最钦佩的是谁？<br><strong>工作上还是硅谷钢铁侠，生活上是冯唐</strong></li>
<li>你认为自己最伟大的成就是什么？<br>本期拒绝回答，，立Flag！</li>
<li>你自己的哪个特点让你最觉得痛恨？<br><strong>还是要更自律一点，，自律即自由</strong></li>
<li>你最喜欢的旅行是哪一次？<br>2018年端午节的苏州之旅，，<strong>准确来说是喜欢苏州</strong></li>
<li>你最痛恨别人的什么特点？<br><strong>这样不好..</strong></li>
<li>你最珍惜的财产是什么？<br><strong>个人信用</strong></li>
<li>你最奢侈的是什么？<br><strong>爸妈是如此爱我</strong></li>
<li>你认为程度最浅的痛苦是什么？<br><strong>浅的都不痛苦，痛苦都不浅</strong></li>
<li>你认为哪种美德是被过高的评估的？<br>这个话题一两句说不清楚，，容易引战</li>
<li>你最喜欢的职业是什么？<br><strong>依然程序员</strong></li>
<li>你对自己的外表哪一点不满意？<br><strong>右上眼皮可不可以不要内双</strong></li>
<li>你最后悔的事情是什么？<br><strong>大学混沌且不自知</strong></li>
<li>还在世的人中你最鄙视的是谁？<br><strong>无法控制自己情绪的人</strong></li>
<li>你最喜欢男性身上的什么品质？<br><strong>能为自己说过的话、做过的事负责</strong></li>
<li>你使用过的最多的单词或者是词语是什么？<br>本年度是，，<strong>同一个世界，同一个梦想</strong>（大家都是同事，都想把事情做好）</li>
<li>你最喜欢女性身上的什么品质？<br><strong>会照顾自己，也会照顾别人</strong></li>
<li>你最伤痛的事是什么？<br><strong>形同陌路</strong></li>
<li>你最看重朋友的什么特点？<br><strong>靠谱儿</strong></li>
<li>你这一生中最爱的人或东西是什么？<br>28岁回答这个问题有些早，，现在我希望自己有长期稳定的住所，可以无所顾忌的买书，纸质的。</li>
<li>你希望以什么样的方式死去？<br><strong>安乐死，或者一场猝不及防的意外</strong></li>
<li>何时何地让你感觉到最快乐？<br><strong>Give Me Five！！！</strong></li>
<li>如果你可以改变你的家庭一件事，那会是什么？<br><del>早点让我知道电脑不光可以玩游戏..</del><br><strong>大家身体健康就好，别的真不奢求</strong></li>
<li>如果你能选择的话，你希望让什么重现？<br><strong>小我：早上被我爸的录音机(装磁带的那个)叫醒，我该起床吃饭上学了。</strong><br><strong>大我：太阳系重回三维宇宙。</strong></li>
<li>你的座右铭是什么？<br><strong>总之，经历过就是财富</strong></li>
</ol>
<hr>
<p><strong>Extra..</strong><br>2019年还有什么想说的？？</p>
<ul>
<li><p>『求稳』，，在完全陌生的城市找到归属感</p>
</li>
<li><p>在处理亲密关系中成长了许多许多，感谢大象</p>
</li>
<li><p>这一年你都做了些啥？？</p>
<ol>
<li><p>离职</p>
</li>
<li><p>入职</p>
</li>
<li><p>在一段新的亲密关系中成长</p>
</li>
</ol>
</li>
<li><p>明年有什么准备？</p>
<ol>
<li>把『高性能MySql』相关课程(纸质工具书+极客时间课程)学习完，并总结。</li>
<li>复习下『深入理解Java虚拟机』</li>
<li>完成『Redis深度历险』的学习</li>
<li>学习Guava源码</li>
</ol>
</li>
<li><p>还有什么想说的没？？</p>
<ol>
<li>坚持学习！！！</li>
<li>坚持情绪管理！！！</li>
<li>坚持在亲密关系中成长！！！</li>
<li>坚持『坚持』这件小事！！！</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>ProustQA</category>
      </categories>
      <tags>
        <tag>普鲁斯特问卷</tag>
      </tags>
  </entry>
  <entry>
    <title>普鲁斯特问卷-2018</title>
    <url>/2018/12/31/ProustQA_2018/</url>
    <content><![CDATA[<p>🕯🕯🕯<br><span style="color:white;">我上小学，你出差；之后我开始住校，初中两周回家一次，每次两天；高中四周回家一次，每次不到36小时；我上大学了，你退休了，我半年回家一次。<br>如果你还在..</span></p>
<hr>
<ol>
<li>你认为最完美的快乐是怎样的？<br><strong>内心的平静</strong></li>
<li>你最希望拥有哪种才华？<br><strong>还是将问题抽象成代码的能力</strong></li>
<li>你最恐惧的是什么？<br><strong>变老</strong></li>
<li>你目前的心境怎样？<br><del>邻居不懂事儿，挪动椅子和桌子的时候硬扯，发出刺耳的声音，，MMP</del><br><strong>这一年过得真特么快！！</strong></li>
<li>还在世的人中你最钦佩的是谁？<br>由埃隆马斯克临时改为<strong>『丁香医生』，，不会删稿，对每一个字负责，欢迎来告。</strong></li>
<li>你认为自己最伟大的成就是什么？<br><strong>大概是全马323吧</strong></li>
<li>你自己的哪个特点让你最觉得痛恨？<br><strong>亲密关系里把握不好度？</strong></li>
<li>你最喜欢的旅行是哪一次？<br>2018年端午节的苏州之旅，，<strong>准确来说是喜欢苏州</strong></li>
<li>你最痛恨别人的什么特点？<br><strong>不知何为个人边界！</strong></li>
<li>你最珍惜的财产是什么？<br><strong>个人信用</strong></li>
<li>你最奢侈的是什么？<br><strong>很幸运，，如此幸运</strong></li>
<li>你认为程度最浅的痛苦是什么？<br><strong>浅的都不痛苦，痛苦都不浅</strong></li>
<li>你认为哪种美德是被过高的评估的？<br><strong>这个话题一两句说不清楚，，容易引战。</strong></li>
<li>你最喜欢的职业是什么？<br><strong>还是程序员</strong>，，能用技术改变世界的职业都是我喜欢的</li>
<li>你对自己的外表哪一点不满意？<br><strong>右边的眉毛，，为什么你不能听话一点.Smile.</strong></li>
<li>你最后悔的事情是什么？<br><strong>大学时太混沌，而且当时完全不自知..</strong></li>
<li>还在世的人中你最鄙视的是谁？<br><strong>杠精们</strong>，，Love&amp;Peace</li>
<li>你最喜欢男性身上的什么品质？<br><strong>能为自己说过的话、做过的事负责</strong></li>
<li>你使用过的最多的单词或者是词语是什么？<br><strong>Clear?</strong>(PS: 跟别人沟通时，不确定对方是否完全接收到自己想传达的信息，会问一句Clear？Clear &#x3D; 我表达清楚了么？+你GET到了么？)</li>
<li>你最喜欢女性身上的什么品质？<br><strong>真∙男女平等</strong></li>
<li>你最伤痛的事是什么？<br><strong>形同陌路</strong></li>
<li>你最看重朋友的什么特点？<br><strong>言行一致，，不整那些片儿汤话</strong></li>
<li>你这一生中最爱的人或东西是什么？<br><strong>Macbook Pro 15’’ (Especially 32G)，，心心念</strong></li>
<li>你希望以什么样的方式死去？<br><strong>安乐死，或者一场猝不及防的意外</strong></li>
<li>何时何地让你感觉到最快乐？<br><strong>写了一大段代码，一次就能跑起来，不用调试的那种</strong></li>
<li>如果你可以改变你的家庭一件事，那会是什么？<br><del>早点让我知道电脑不光可以玩游戏..</del><br><strong>大家身体健康就好，别的真不奢求</strong></li>
<li>如果你能选择的话，你希望让什么重现？<br><strong>小我：早上被我爸的录音机(装磁带的那个)叫醒，我该起床吃饭上学了。</strong><br><strong>大我：太阳系重回三维宇宙。</strong></li>
<li>你的座右铭是什么？<br><strong>生命的过程，无论是阳春白雪，青菜豆腐，我都得尝尝是什么滋味，才不枉来走这么一遭。</strong></li>
</ol>
<hr>
<p><strong>Extra..</strong><br>2018年的 Keyword 是？？</p>
<ul>
<li><strong>『焦虑』，，最焦虑的时候会在公交车上用手机学习廖雪峰老师的Python教程 😔</strong></li>
<li>除了两点一线，你最常去的地方是？？<br><strong>周五下班在北国商城下车，去勒泰溜一圈，步行回家。</strong><br><strong>周日没什么事儿就去省图待一会儿。</strong></li>
<li>为什么要去省图？？<br><strong>保持焦虑。。在省图，年长的人在学习，年幼的人在学习，同龄人也在学习。</strong></li>
<li>所以，这一年你都学了些啥？？</li>
</ul>
<ol>
<li>小程序爆发，想给自己做个<strong>小程序</strong>，用来收集自己的位置信息。所以看文档学习了小程序，中间还必须学 <strong>Vue.js</strong>。然后刚好公司也要准备做小程序，，所以，这一年大部分时间都在做与小程序相关的项目，<strong>对微信公众号和小程序的 API 熟悉了很多</strong>，中间爬过的坑都在博客中记录下来了。</li>
<li><strong>重读『哲学家都干了些什么』</strong></li>
<li><strong>重读『三体』</strong></li>
<li>学习『**鸟哥的 Linux 私房菜(基础学习篇)**』: 计算机概论、Linux 是什么、首次登陆与在线求助 man page、Linux 的文件权限与目录配置、Linux 文件与目录管理、Linux 磁盘与文件系统管理(认识Ext2文件系统)、文件与文件系统的压缩与打包(Linux 系统常用压缩命令、打包命令tar)、Vim 编辑器、认识与学习Bash、正则表达式与文件格式化处理、学习Shell Script、例行性工作、程序管理与 SELinux 初探(工作管理（job controller）、进程管理)。<br>全书778页，只选修了部分章节，，嗯，一边学一边忘，一边忘一边学。。</li>
<li>买了 Linux 服务器，主要用来部署自己做的小程序服务端和<strong>linux相关的技术验证练习</strong>(Tomcat MySql Redis Nginx https)；顺便搭了梯子。</li>
<li>粗读一遍<strong>『码农翻身』</strong>，第二遍正在精读中..</li>
<li>为了缓解焦虑，正在<strong>抄『飞鸟集』</strong>，目前抄到了第122首。</li>
<li>廖雪峰老师的 <strong>Python</strong> 教程前10章断断续续看了3遍，，因为工作中用不到，真是一边学一边忘。。12月初，用 Python 的开源框架 Scrapy 写了超市商品图片爬虫，感觉还不错~嗯，现在正在学第四遍。。</li>
<li><strong>学会了拒绝，学会了独处。</strong><br>(大概就是这样，，期间也读了其他书，暂时没有读第二遍的兴趣，略过不表。)</li>
</ol>
<ul>
<li>明年准备学啥？<br>争取在4月份前读完『深入理解Java虚拟机』和『Java并发编程的艺术』，然后再读一遍『Java编程思想』，，把剩下的『人类简史』和『宇宙简史』收个尾。。</li>
<li>还有什么想说的没？？</li>
</ul>
<ol>
<li><strong>不会的东西越来越多，我可能会一直焦虑下去。。</strong></li>
<li><strong>讨好自己总归是最容易的</strong></li>
<li><strong>没那么喜欢老罗了，对他的期待只剩下自传了。</strong> <strong>Talk is cheap, show me your</strong> <del>code</del> <strong>phone</strong>.</li>
<li><strong>以前总盼着接私活儿，现在完全没这种感觉了。</strong>个人项目一般价格敏感；公司项目一般有坑，大概率背锅。而且，接私活儿是对八小时工作制的严重亵渎！有时间多看会儿书，点点技能树多好~</li>
<li><strong>坚持看人民日报。</strong></li>
</ol>
]]></content>
      <categories>
        <category>ProustQA</category>
      </categories>
      <tags>
        <tag>普鲁斯特问卷</tag>
      </tags>
  </entry>
  <entry>
    <title>普鲁斯特问卷-2021</title>
    <url>/2022/01/12/ProustQA_2021/</url>
    <content><![CDATA[<p>🕯🕯🕯<br><span style="color:white;">今年家里又走了一个老人，奶奶也比之前更容易流泪了，，尤其是我要回深圳的时候</span></p>
<hr>
<ol>
<li>你认为最完美的快乐是怎样的？<br><strong>快乐终究是短暂的</strong>，，今年没怎么读书，内心也没有去年平静。。</li>
<li>你最希望拥有哪种才华？<br><strong>还是将问题抽象成代码的能力</strong>。今年『稚晖君』火了，因为自己做了一个机械臂，媒体称之为华为天才少年，真好</li>
<li>你最恐惧的是什么？<br><strong>变老</strong>，一眼可以望到头儿的那种</li>
<li>你目前的心境怎样？<br><strong>还是焦虑，，关于年龄，关于未来</strong>。今年的焦虑比去年来的更猛烈了一些，，又年长了一岁，好像又没有什么进步。头发都抠掉了，也深刻理解光哥的两根食指是怎么抠坏的了。</li>
<li>还在世的人中你最钦佩的是谁？<br><strong>不再是马斯克，是稚晖君</strong></li>
<li>你认为自己最伟大的成就是什么？<br><strong>能照顾好自己就挺伟大的</strong></li>
<li>你自己的哪个特点让你最觉得痛恨？<br><strong>还是不够自律..</strong></li>
<li>你最喜欢的旅行是哪一次？<br>2018年端午节的苏州之旅，，<strong>准确来说是喜欢苏州</strong>。今年因为疫情没怎么出去玩儿，去了广州张信哲的演唱会，本来还计划再去五条人的专场，票和酒店都定好了，结果突发疫情取消了。嗯，还去了盘尼西林的专场 [狗头]</li>
<li>你最痛恨别人的什么特点？<br><strong>双标，妥妥的双标！</strong></li>
<li>你最珍惜的财产是什么？<br><strong>个人信用</strong></li>
<li>你最奢侈的是什么？<br><strong>父母是如此爱我</strong></li>
<li>你认为程度最浅的痛苦是什么？<br><strong>浅的都不痛苦，痛苦都不浅</strong></li>
<li>你认为哪种美德是被过高的评估的？<br>这个话题一两句说不清楚，，容易引战</li>
<li>你最喜欢的职业是什么？<br><strong>依然程序员</strong>(上边提到的『稚晖君』，奈斯！)</li>
<li>你对自己的外表哪一点不满意？<br><strong>右上眼皮可不可以不要内双</strong></li>
<li>你最后悔的事情是什么？<br><strong>大学混沌且不自知</strong></li>
<li>还在世的人中你最鄙视的是谁？<br><strong>每个人应该都不想被别人鄙视的..</strong></li>
<li>你最喜欢男性身上的什么品质？<br><strong>能为自己说过的话、做过的事负责</strong></li>
<li>你使用过的最多的单词或者是词语是什么？<br>本年度是，，<strong>我不管，我就要</strong>（其实不是我说的）。</li>
<li>你最喜欢女性身上的什么品质？<br><strong>会照顾自己，也会照顾别人</strong></li>
<li>你最伤痛的事是什么？<br><strong>形同陌路</strong></li>
<li>你最看重朋友的什么特点？<br><strong>靠谱儿</strong></li>
<li>你这一生中最爱的人或东西是什么？<br>现在想想，，以前最爱的人是自己，现在不是了，持续付出爱的行为会让人成长。</li>
<li>你希望以什么样的方式死去？<br><strong>安乐死，或者一场猝不及防的意外</strong></li>
<li>何时何地让你感觉到最快乐？<br><strong>代码一遍过！！！</strong></li>
<li>如果你可以改变你的家庭一件事，那会是什么？<br><del>早点让我知道电脑不光可以玩游戏..</del><br><strong>大家身体健康就好，别的真不奢求</strong></li>
<li>如果你能选择的话，你希望让什么重现？<br><strong>小我：早上被我爸的录音机(装磁带的那个)叫醒，我该起床吃饭上学了。</strong><br><strong>大我：太阳系重回三维宇宙。</strong></li>
<li>你的座右铭是什么？<br><strong>经历过就是财富</strong></li>
</ol>
<hr>
<p><strong>Extra..</strong><br>2021年还有什么想说的？？</p>
<ul>
<li><p>今年和大象-又一起成长了很多，慢慢有了处理问题的默契，有时候我以为她会生气的时候，她没有生气，我很感激这一点。她的成长应该比我更多，，在以前，她十点半睡觉，午饭准时。如今，她也会熬到后半夜睡觉，午饭也不再准时。她也会经常说，『这一天，跟打仗似的。。』经历过打仗似的工作节奏，某种程度上，她跟自己和解了很多，也更明白为什么会有人不按时吃午饭。</p>
</li>
<li><p>这一年你都做了些啥？？</p>
<ol>
<li>如今工作更多的是得心应手，毕竟已经是组里资历最老的人了，，两年半足够换一茬儿同事了，2022年应该会资历更老；</li>
<li>真正学习了AQS；</li>
<li>误打误撞开始买币了[扶额]，事情还要从 Asgardia 升级钱包的一封邮件开始说起，，</li>
<li>我的小程序上线了，起初叫『足记打卡』，后来改成了『足迹日志』，希望明年用户会多一点，现在只有142个；</li>
</ol>
</li>
<li><p>明年有什么准备？</p>
<ol>
<li>换工作；</li>
<li>继续完善小程序功能。</li>
</ol>
</li>
<li><p>还有什么想说的没？？</p>
<ol>
<li>坚持学习！！！</li>
<li>坚持情绪管理！！！</li>
<li>坚持在亲密关系中成长！！！</li>
<li>坚持『坚持』这件事！！！</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>ProustQA</category>
      </categories>
      <tags>
        <tag>普鲁斯特问卷</tag>
      </tags>
  </entry>
  <entry>
    <title>普鲁斯特问卷-2020</title>
    <url>/2021/01/23/ProustQA_2020/</url>
    <content><![CDATA[<p>🕯🕯🕯<br><span style="color:white;">向在这场疫情中去世的奉献者们致敬！</span></p>
<hr>
<ol>
<li>你认为最完美的快乐是怎样的？<br><strong>内心的平静</strong>，，上周日，在普宁美佳乐一层的大厅了，等大象-的时候，百无聊赖在按摩椅上休息了15分钟。整个人躺在上面，外面熙熙攘攘(音乐美食节，同时有四家在卖臭豆腐…)，我看着天花板，完全放空了。想起了去年夏天去外伶仃岛，返程等船的时候，在树荫下的一块裸石上边，盘腿进入冥想状态。大抵就是这种『没有意义』的一刻钟吧。</li>
<li>你最希望拥有哪种才华？<br><strong>还是将问题抽象成代码的能力</strong>。今年突然发现了『稚晖君』，好生羡慕。</li>
<li>你最恐惧的是什么？<br><strong>变老</strong>..</li>
<li>你目前的心境怎样？<br><strong>有点焦虑，，关于年龄，关于未来</strong>。做总结的时候总是焦虑的，一年一年，，上周五的时候，在公司加班写代码，周婶儿发起视频，还有大松，光哥没接。没说几句，松突然提到『腿儿，你三十啦？！』，周婶儿说『没事儿，三十岁一事无成很正常，嫑伤心哈』，接着就是一阵坏笑，[扶额]。</li>
<li>还在世的人中你最钦佩的是谁？<br><strong>工作上还是硅谷钢铁侠，生活上是冯唐</strong></li>
<li>你认为自己最伟大的成就是什么？<br>(一声叹息..)</li>
<li>你自己的哪个特点让你最觉得痛恨？<br><strong>还是不够自律..</strong></li>
<li>你最喜欢的旅行是哪一次？<br>2018年端午节的苏州之旅，，<strong>准确来说是喜欢苏州</strong>。去年的双月湾和外伶仃岛也不错，如今想起的都是美好~</li>
<li>你最痛恨别人的什么特点？<br><strong>双标，妥妥双标！</strong></li>
<li>你最珍惜的财产是什么？<br><strong>个人信用</strong></li>
<li>你最奢侈的是什么？<br><strong>爸妈是如此爱我</strong>（我爸刚嘟噜玩说白养我了，看得见摸不着指不上[笑哭]）</li>
<li>你认为程度最浅的痛苦是什么？<br><strong>浅的都不痛苦，痛苦都不浅</strong></li>
<li>你认为哪种美德是被过高的评估的？<br>这个话题一两句说不清楚，，容易引战</li>
<li>你最喜欢的职业是什么？<br><strong>依然程序员</strong>(上边提到的『稚晖君』，奈斯！)</li>
<li>你对自己的外表哪一点不满意？<br><strong>右上眼皮可不可以不要内双</strong></li>
<li>你最后悔的事情是什么？<br><strong>大学混沌且不自知</strong></li>
<li>还在世的人中你最鄙视的是谁？<br><strong>每个人应该都不想被别人鄙视的..</strong></li>
<li>你最喜欢男性身上的什么品质？<br><strong>能为自己说过的话、做过的事负责</strong></li>
<li>你使用过的最多的单词或者是词语是什么？<br>本年度是，，**easy, man~**（想表达的是，Easy tiger.）</li>
<li>你最喜欢女性身上的什么品质？<br><strong>会照顾自己，也会照顾别人</strong></li>
<li>你最伤痛的事是什么？<br><strong>形同陌路</strong></li>
<li>你最看重朋友的什么特点？<br><strong>靠谱儿</strong></li>
<li>你这一生中最爱的人或东西是什么？<br>现在回答这个问题还是有些早，，现在希望大象-能够再胖一点。</li>
<li>你希望以什么样的方式死去？<br><strong>安乐死，或者一场猝不及防的意外</strong></li>
<li>何时何地让你感觉到最快乐？<br><strong>Give Me Five！！！</strong></li>
<li>如果你可以改变你的家庭一件事，那会是什么？<br><del>早点让我知道电脑不光可以玩游戏..</del><br><strong>大家身体健康就好，别的不奢求</strong></li>
<li>如果你能选择的话，你希望让什么重现？<br><strong>小我：早上被我爸的录音机(装磁带的那个)叫醒，我该起床吃饭上学了。</strong><br><strong>大我：太阳系重回三维宇宙。</strong></li>
<li>你的座右铭是什么？<br><strong>经历过就是财富</strong></li>
</ol>
<hr>
<p><strong>Extra..</strong><br>2020年还有什么想说的？？</p>
<ul>
<li><p>今年和大象-又一起成长了很多，慢慢有了处理问题的默契。</p>
</li>
<li><p>这一年你都做了些啥？？</p>
<ol>
<li>离职-被动离开长亮(太差了)</li>
<li>入职-被动进入博彦(比长亮好多了)</li>
<li>在亲密关系中感觉到了稳定。</li>
<li>年初疫情隔离的时候好好学习了下Mysql，有了更深的认识，开始在『极客时间』买课程学习。</li>
<li>主动了解保险，够买保险，安利保险。购买基金股票是看多，购买保险是看空(加杠杆)。</li>
<li>年中的银壹项目从头跟到尾，对业务有了更深的理解，也算中流砥柱了。代价是工作变的繁重，白天处理生产时间，晚上写代码，平均到家时间22:00+。</li>
</ol>
</li>
<li><p>明年有什么准备？</p>
<ol>
<li>学完『Redis核心技术与实战』相关课程(纸质工具书+极客时间课程)学习完，并总结。</li>
<li>复习下『深入理解Java虚拟机』</li>
<li>完成『Redis深度历险』的学习</li>
<li>学习Guava源码</li>
<li>学习openSDK。</li>
</ol>
</li>
<li><p>还有什么想说的没？？</p>
<ol>
<li>坚持学习！！！</li>
<li>坚持情绪管理！！！</li>
<li>坚持在亲密关系中成长！！！</li>
<li>坚持『坚持』这件事！！！</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>ProustQA</category>
      </categories>
      <tags>
        <tag>普鲁斯特问卷</tag>
      </tags>
  </entry>
  <entry>
    <title>普鲁斯特问卷-2022</title>
    <url>/2023/01/28/ProustQA_2022/</url>
    <content><![CDATA[<p>新冠疫情终于在2022年的最后一个月结束了，幸运的是家里的老人都平安过来了。只是奶奶的情况不是很好，阿兹海默，不认识我妈了，每顿吃的什么也不记得了，，一切都发生在短短的一年间。刚回家的时候，才知道爸妈在电话中提到的『没精神』是怎样一种状况，，眼皮耷拉着，像是困极了。还好，年后明显感觉精神多了，不再总是低头眯着，，静等春来！</p>
<hr>
<ol>
<li>你认为最完美的快乐是怎样的？<br><strong>快乐依然是短暂的</strong>，，已经不要求快乐了，只希望心里能干净一点，不要总是存着事儿。</li>
<li>你最希望拥有哪种才华？<br><strong>SOP(Standard Operating Procedure)，大部分代码终究是重复的，『标准化』才是高价值的</strong>。今年『稚晖君』从华为离职创业了，祝好！</li>
<li>你最恐惧的是什么？<br><strong>妈妈变老</strong>，，心疼，没有一分钟为自己活</li>
<li>你目前的心境怎样？<br><strong>刚回答完上一个问题，泪目</strong>。两个老人，难啊。。今年不再抠头发了，头发也长出来了。下半年过的好难好焦虑，尤其是下半年跟进发动机账户下线的时候，每天在公司如坐针毡。</li>
<li>还在世的人中你最钦佩的是谁？<br><strong>稚晖君</strong></li>
<li>你认为自己最伟大的成就是什么？<br><strong>别让家里人操心</strong></li>
<li>你自己的哪个特点让你最觉得痛恨？<br><strong>还是不够自律..</strong></li>
<li>你最喜欢的旅行是哪一次？<br>回深圳前，跟周婶儿在庄里小聚，说起他们去大西北自驾的见闻，实在是羡慕的很，恨不得马上成行 也去上一趟。今年依然是因为疫情没怎么出去玩儿，上半年去了清远桃花谷，差点找不到回不了深圳。年底计划去桂林草莓音乐节，都安排好了，突发疫情，活动取消。没多久，疫情放开了。。</li>
<li>你最痛恨别人的什么特点？<br><strong>双标</strong></li>
<li>你最珍惜的财产是什么？<br><strong>个人信用</strong></li>
<li>你最奢侈的是什么？<br><strong>父母是如此爱我</strong></li>
<li>你认为程度最浅的痛苦是什么？<br><strong>浅的都不痛苦，痛苦都不浅</strong></li>
<li>你认为哪种美德是被过高的评估的？<br>这个话题一两句说不清楚，，容易引战</li>
<li>你最喜欢的职业是什么？<br><strong>依然程序员</strong>(上边提到的『稚晖君』，奈斯！)</li>
<li>你对自己的外表哪一点不满意？<br><strong>右上眼皮可不可以不要内双</strong>，最近发现身上的痦子多了很多，脸上也是 好在都在侧面。。</li>
<li>你最后悔的事情是什么？<br><strong>大学混沌且不自知</strong></li>
<li>还在世的人中你最鄙视的是谁？<br><strong>每个人应该都不想被别人鄙视的..</strong></li>
<li>你最喜欢男性身上的什么品质？<br><strong>能为自己说过的话、做过的事负责</strong></li>
<li>你使用过的最多的单词或者是词语是什么？<br>今年没有什么特别经常挂在嘴边的，，每天下班前在微信上跟大象在微信上说的『回家』？</li>
<li>你最喜欢女性身上的什么品质？<br><strong>会照顾自己，也会照顾别人</strong></li>
<li>你最伤痛的事是什么？<br><strong>远离家乡</strong></li>
<li>你最看重朋友的什么特点？<br><strong>靠谱儿</strong></li>
<li>你这一生中最爱的人或东西是什么？<br>『<strong>眼前人</strong>』</li>
<li>你希望以什么样的方式死去？<br><strong>安乐死，或者一场猝不及防的意外</strong></li>
<li>何时何地让你感觉到最快乐？<br><strong>跑单测的时候</strong></li>
<li>如果你可以改变你的家庭一件事，那会是什么？<br><strong>大家身体健康就好，别的不奢求</strong></li>
<li>如果你能选择的话，你希望让什么重现？<br><strong>小我：小时候，在床边，，妈妈剪完自己的指甲后，顺手拉过爸爸的手帮他剪指甲。</strong></li>
<li>你的座右铭是什么？<br><strong>经历过就是财富</strong></li>
</ol>
<hr>
<p><strong>Extra..</strong><br>2022年还有什么想说的？？</p>
<ul>
<li><p>今年和大象-又一起成长了很多，处理问题的默契更多了一点。要一起去北方走走，补充下对北方的认识。</p>
</li>
<li><p>这一年你都做了些啥？？</p>
<ol>
<li>上半年没什么，按部就班。下半年进入脱O的下半程，留下的都是硬骨头，实在是难受，但学到的也是着实不少，大数据入门儿 Hadoop(Hive Sqoop HBase ES)~</li>
<li>AQS该复习了。。</li>
<li>『原神』本来是节假日游戏，但从『神女劈观』开始，常驻了。。</li>
<li>『足迹日志』小程序，小版本迭代不给过审了，说是涉及用户隐私——收集用户地理位置，真的是无语，跟个保法有很大的关系，用户数已经不奢求了。发现 APP STORE 中有几个优秀的类似功能的 APP，价格还挺贵，功能完整，就是有点封闭。。</li>
<li>原神文本搜索功能初步完成，待优化上线。</li>
</ol>
</li>
<li><p>明年有什么准备？</p>
<ol>
<li>2022年给转内了，薪资变化不大，待遇好了些，，钱少事儿多，2023年要换个行业了，倾向实体制造，写代码终究不是长久之计；</li>
<li>原神-世界树搜索功能上线。</li>
</ol>
</li>
<li><p>还有什么想说的没？？</p>
<ol>
<li>坚持学习！！！</li>
<li>坚持情绪管理！！！</li>
<li>坚持在亲密关系中成长！！！</li>
<li>硬着头皮再坚持一下！！！</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>ProustQA</category>
      </categories>
      <tags>
        <tag>普鲁斯特问卷</tag>
      </tags>
  </entry>
  <entry>
    <title>关于微信卡券预览接口</title>
    <url>/2018/07/13/WeChat-card-coupons-preview-interface-/</url>
    <content><![CDATA[<p>最近在做微信卡券接口相关的功能，，妈耶，相当于复制一个微信公众平台的卡券模块！光字段就能反4屏，简直就是惩罚性编程，搞的我很焦虑。。花了两周的时间，终于仿照微信原版在自己后台完成了创建卡券的功能，，当在微信公众平台看到新创建的折扣券，长舒一口气，终于看见了正反馈！！接下来，，得预览下吧？不能直接投放呀。OK，预览接口，，今天的主角儿。要知道，卡券预览接口做的很顺利的话，也就没这篇文章了。。</p>
<hr>
<p>OK，进入正题儿。</p>
<p>创建完卡券之后，我们按照逻辑，可以应该继续往下进行，在文档中可以找到<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1451025062">管理卡券</a>的模块。直接在这个页面搜索关键字『预览接口』，，即👇</p>
<blockquote>
<p>###4.6 预览接口<br>支持开发者调用该接口下发卡券。订阅号不可用，服务号认证后可用。详情见</p>
</blockquote>
<p><a href="http://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140549&token=&lang=zh_CN">预览接口</a></p>
<p>按理儿说，这就成了呀，，照预览接口做就得了呗。但是！！！点开预览接口，我们看到的是啥？丫丫，空的，空页面，啥玩意儿没有？！🙃<br>(问候一下微信写文档的同学)</p>
<p>冷静一下，，既然做了链接，这说明极有可能在别的模块中，否则就没必要做链接了对吧；另外，预览接口，那得把消息推送到手机上呀，事件推送，消息管理？~那找吧，，<br>loding..</p>
<p>诶！还真在<strong>消息管理</strong>的<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1481187827_i0l21">群发接口和原创校验</a>模块中给找着了！</p>
<blockquote>
<h6 id="预览接口【订阅号与服务号认证后均可用】"><a href="#预览接口【订阅号与服务号认证后均可用】" class="headerlink" title="预览接口【订阅号与服务号认证后均可用】"></a>预览接口【订阅号与服务号认证后均可用】</h6></blockquote>
<p>文档有了，nèng!</p>
<blockquote>
<p>卡券：</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;touser&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;OPENID&quot;</span><span class="hljs-punctuation">,</span> <br> <span class="hljs-attr">&quot;wxcard&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>              <br>    <span class="hljs-attr">&quot;card_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;123dsdajkasd231jhksad&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;card_ext&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;&quot;</span>code<span class="hljs-string">&quot;: &quot;</span><span class="hljs-string">&quot;,&quot;</span>openid<span class="hljs-string">&quot;: &quot;</span><span class="hljs-string">&quot;,&quot;</span>timestamp<span class="hljs-string">&quot;: &quot;</span><span class="hljs-number">1402057159</span><span class="hljs-string">&quot;,&quot;</span>signature<span class="hljs-string">&quot;: &quot;</span><span class="hljs-number">017</span>bb17407c8e0058a66d72dcc61632b70f511ad<span class="hljs-string">&quot;&#125;&quot;</span>               <br>           <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;msgtype&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;wxcard&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment">// 请注意，上述JSON数据中的touser字段都可以改为towxname，这样就可以针对微信号进行预览（而非openID），towxname和touser同时赋值时，以towxname优先。</span><br></code></pre></td></tr></table></figure>
<p>参数说明就不放了，文档中有说明，，但是这个<code>card_ext</code>什么鬼？！！没听说过呀都，忒眼生。。另外，这个字段里，别的参数还好说。但，，<code>signature</code>是怎么计算出来的？这是关键呀。得，这真难倒我了，而且这页面中只有这一个地方出现了这一属性。搁哪儿找呀，，百度先行，关键字[微信 卡券 card_ext]</p>
<p>顺藤摸瓜，找到了<strong>微信网页开发</strong>模块中的<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115">微信JS-SDK说明文档</a>看上去怎么那么不靠谱？消息推送跟网页开发有嘛关系？！！但在这个页面中还真就找到了<code>card_ext</code>字段，，👇</p>
<blockquote>
<h4 id="附录4-卡券扩展字段及签名生成算法"><a href="#附录4-卡券扩展字段及签名生成算法" class="headerlink" title="附录4-卡券扩展字段及签名生成算法"></a>附录4-卡券扩展字段及签名生成算法</h4><h6 id="卡券-api-ticket"><a href="#卡券-api-ticket" class="headerlink" title="卡券 api_ticket"></a>卡券 api_ticket</h6><h6 id="卡券扩展字段cardExt说明"><a href="#卡券扩展字段cardExt说明" class="headerlink" title="卡券扩展字段cardExt说明"></a>卡券扩展字段cardExt说明</h6><h6 id="签名说明"><a href="#签名说明" class="headerlink" title="签名说明"></a>签名说明</h6></blockquote>
<p>剩下的一切按文档来就成了，，需要注意的是👇</p>
<blockquote>
<p>######签名说明<br>1.将 api_ticket、timestamp、card_id、code、openid、nonce_str的value值进行字符串的字典序排序。</p>
</blockquote>
<p>这个<strong>字典序排序</strong>，第一次看见还真有点懵，，但好在通过搜索引擎可以解决~我参考了这篇博客，，<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=cardsign">TreeMap按照value进行排序</a>实现代码如下👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String, String&gt; wxMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;String, String&gt;();<br><span class="hljs-comment">//参数封装</span><br>wxMap.put(<span class="hljs-string">&quot;api_ticket&quot;</span>, wxJsApiTicket);<br>wxMap.put(<span class="hljs-string">&quot;timestamp&quot;</span>, wxTimestamp);<br>wxMap.put(<span class="hljs-string">&quot;card_id&quot;</span>, cardId);<br>wxMap.put(<span class="hljs-string">&quot;code&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 视实际情况</span><br>wxMap.put(<span class="hljs-string">&quot;openid&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<span class="hljs-comment">// 视实际情况</span><br>wxMap.put(<span class="hljs-string">&quot;noncestr&quot;</span>, wxNoncestr);<br><br><span class="hljs-comment">// 将 api_ticket、timestamp、card_id、code、openid、nonce_str的value值进行字符串的字典序排序。</span><br>List&lt;Entry&lt;String, String&gt;&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Entry&lt;String, String&gt;&gt;(wxMap.entrySet());  <br>Collections.sort(list,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Map.Entry&lt;String,String&gt;&gt;() &#123;  <br>    <span class="hljs-comment">//升序排序  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2)</span> &#123;  <br>        <span class="hljs-keyword">return</span> o1.getValue().compareTo(o2.getValue());  <br>    &#125;  <br>&#125;);<br><br><span class="hljs-comment">// 将排序后的值依次取出，并拼接为字符串。</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">wxBaseString</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><span class="hljs-keyword">for</span> (Entry&lt;String, String&gt; param : list) &#123;<br>    wxBaseString.append(param.getValue());<br>&#125;<br>log.info(wxBaseString.toString());<br><br><span class="hljs-comment">// 加密获取signature</span><br><span class="hljs-type">String</span> <span class="hljs-variable">wxSignature</span> <span class="hljs-operator">=</span> HashKit.sha1(wxBaseString.toString());<br></code></pre></td></tr></table></figure>
<p>这剩下的就是调用<a href="https://api.weixin.qq.com/cgi-bin/message/mass/preview?access_token=">微信卡券预览接口</a>了，自己来吧~</p>
<hr>
<p>PS: 这昨儿个看了姜文儿的『邪不压正』，，本篇分享的风格就这样了，多包涵。哭笑</p>
<p>参考链接：</p>
<ol>
<li>群发接口 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1481187827_i0l21">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1481187827_i0l21</a></li>
<li>微信JS-SDK说明文档 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a></li>
<li>字典序排序 <a href="http://www.cnblogs.com/Berryxiong/p/6240514.html">http://www.cnblogs.com/Berryxiong/p/6240514.html</a></li>
<li>debug <a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=cardsign">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=cardsign</a></li>
</ol>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>卡券</tag>
      </tags>
  </entry>
  <entry>
    <title>微信第三方平台</title>
    <url>/2018/09/25/WeChat_third_platform/</url>
    <content><![CDATA[<p>时至今日，，作为第三方平台开发的小程序已经上线有一段时间了，第一次经历整个开发流程。再回首，尝试着从宏观上梳理下『当我们谈微信第三方平台时我们在谈什么』。同样，，不涉及代码级的具体实现。</p>
<h4 id="BTW，关于微信开放平台"><a href="#BTW，关于微信开放平台" class="headerlink" title="BTW，关于微信开放平台"></a>BTW，关于微信开放平台</h4><p>顺便聊聊微信开放平台先，，登陆<a href="https://open.weixin.qq.com/">微信开放平台</a>后，进入『管理中心』Tab。我们可以看到页面中有5个二级Tab，分别是『移动应用、网站应用、公众账号、小程序、第三方平台』。OK，微信开放平台，顾名思义，，是将微信体系下的服务接入其他互联网应用的平台。这5个tab代表了目前可以接入的互联网应用类型(准确来说是4个，，第三方平台应该算业务实现类型，不算互联网应用类型。再严谨一点，应该是两种，，web应用和客户端应用，微信公众号和小程序本质上还是客户端应用。再无聊一点，，就只有一种client-server了，笑哭)。</p>
<p><strong>要了解微信开放平台，我们必须深刻理解微信的UnionID机制</strong>：</p>
<blockquote>
<h5 id="获取用户基本信息-UnionID机制"><a href="#获取用户基本信息-UnionID机制" class="headerlink" title="获取用户基本信息(UnionID机制)"></a>获取用户基本信息(UnionID机制)</h5><p>在关注者与公众号产生消息交互后，公众号可获得关注者的OpenID（加密后的微信号，每个用户对每个公众号的OpenID是唯一的。对于不同公众号，同一用户的openid不同）。公众号可通过本接口来根据OpenID获取用户基本信息，包括昵称、头像、性别、所在城市、语言和关注时间。<br><strong>请注意，如果开发者有在多个公众号，或在公众号、移动应用之间统一用户帐号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。</strong></p>
<h5 id="UnionID机制说明："><a href="#UnionID机制说明：" class="headerlink" title="UnionID机制说明："></a>UnionID机制说明：</h5><p>开发者可通过OpenID来获取用户基本信息。特别需要注意的是，如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号，用户的unionid是唯一的。换句话说，同一用户，<strong>对同一个微信开放平台下的不同应用，unionid是相同的</strong>。</p>
</blockquote>
<blockquote>
<p>– 详见<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140839">获取用户基本信息(UnionID机制)
</a></p>
</blockquote>
<p>我们现在代入场景想象下：</p>
<ol>
<li>每个微信用户对『移动应用、web应用、公众号、小程序』都有唯一OpenID；<br>假如我有个商城卖卖零食什么的，客户遍布各个平台，，这样，让客户在Android、IOS客户端 Web网站 公众号菜单中的商城 小程序分别注册一个账号无疑是反人类的。这时候微信说了，，那你在我的微信开放平台注册个账号，然后把移动客户端 web网站 公众号 小程序什么的统统绑定(开放平台中的创建)到开放平台的这个账号主体上。那么新用户就可以在上述所有应用通过微信授权登陆了，无需注册(当然，登陆功能是实现了，，其实只是从微信那获取了几个无关痛痒的几个基本字段信息,实际操作过成功，一般都会要求用户重新绑定手机号或者邮箱什么的，以及其他用户信息。)~当然，统一微信授权登陆功能只是其中一个场景，还有微信支付接口什么的，具体看文档啦。</li>
<li>OK，，假设现在所有应用都可以通过微信授权登陆了。那么在获取用户额外信息之前，我们如何将所有应用的用户体系打通呢？换句话说，我们如何判断在移动客户端授权的OpenID A 与 在小程序端(或Web网站、公众号)的OpenID B是同一个现实世界中的同一个用户呢？<br>这个时候就需要 UnionID 了。当我们把所有端的应用全部绑定在微信开放平台的同一个账号主体上，这时候就可以获取 UnionID 了，因为对同一个微信开放平台下的不同应用，unionid是相同的。即我们可以通过在不同端获取到的 UnionID 进行比对，，如果相同，则为同一个账号主体下的用户。务必注意是同一主体。</li>
</ol>
<p>开放平台就是这样，说的有些啰嗦了都。。</p>
<h4 id="微信开放平台的第三方平台"><a href="#微信开放平台的第三方平台" class="headerlink" title="微信开放平台的第三方平台"></a>微信开放平台的第三方平台</h4><p>之前一直称呼『第三方平台』，也总是困惑第三方平台和开放平台是什么关系。后来在开放平台的『管理中心』Tab找到了答案，，原来一直都没注意。。</p>
<p>第三方平台是干嘛的呢？是为了实现什么？？？最开始了解『第三方平台』是公司要做小程序，同一个小程序要给很多客户用，类似套用模板一样，，但又怕微信有审核，怕相似度太高不给审核通过什么的(事实证明我想多了。。)，然后了解到了『第三方平台』。那个时候对第三平台并不了解，只是看文档，开发接口，实现业务。知其然不知其所以然，，直到有一天小程序开发基本完成，面临上传审核的问题。这个时候，诸多疑问赶到一块儿。其中，又以这两个问题最为棘手，，</p>
<ul>
<li>第三方平台的小程序模板怎么上传？需要审核么？？</li>
<li>这个全网发布什么鬼？也要审核？？？</li>
</ul>
<p>小程序审核发布什么的我基本想得通，像在应用分发平台(各应用市场)上传App一样的道理，，但这个『全网发布』有点太抽象了，，领导问起来，我也有点心虚，只能硬着头皮一点点试。好在领导给力，说 大不了微信不给审核通过，我们再按着未通过理由改呗。其实也看了<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419318611&token=43d90291769311af7af9b34c6c7b93ef600525b7&lang=zh_CN">全网发布接入检测说明</a>，要检查一些文档中的接口是否可用。但是总有一层很模糊的东西没想明白，，Why？后来全网发布检测，一遍过，，<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901133656-%E5%BE%AE%E4%BF%A1%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B9%B3%E5%8F%B0%E5%85%A8%E7%BD%91%E5%8F%91%E5%B8%83%E6%A3%80%E6%B5%8B.jpg" alt="微信第三方平台全网发布检测">(因为最初是为了发布小程序，所以小程序的接口全部实现了，公众号的接口没怎么做，，因此有两项测试失败，但还是提示检测通过了。)</p>
<p>然后检测通过后，就是等待微信审核(大概两个工作日)。这个时候还是不太确定全网发布是什么鬼，，直到审核通过。审核通过之后，，在上图中原『全网发布』按钮所在的那个 section(就是灰背景色那部分，，不知道怎么形容。。) 中灰字部分，会变成『全网发布的审核已通过，已允许公众号来进行授权托管。』。看到这行小字的时候好像突然明白了，，原来全网发布监测是为了保证基本服务可用(因为access_token获取方式变了，其他接口绝大部分需要通过传递access_token来实现业务)。检测通过之后，就可以面向所有客户(在测试阶段只测试白名单中应用可以使用第三方平台的接口实现业务)。</p>
<p>其实，在<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419318292&token=43d90291769311af7af9b34c6c7b93ef600525b7&lang=zh_CN">第三方平台概述</a>中，已经提到了，，只不过最开始开发的时候，不明所以，就略过了，，</p>
<blockquote>
<h5 id="四、第三方平台授权后如何帮助旗下公众平台帐号实现业务"><a href="#四、第三方平台授权后如何帮助旗下公众平台帐号实现业务" class="headerlink" title="四、第三方平台授权后如何帮助旗下公众平台帐号实现业务"></a>四、第三方平台授权后如何帮助旗下公众平台帐号实现业务</h5><p>请根据本文档目录中的“代公众号实现业务”文件夹中的相关文档，来了解如何帮助旗下公众号调用接口，实现业务。也可根据本文档目录中的“代小程序实现业务”文件夹中的相关文档，来了解如何帮助旗下小程序帐号调用接口，实现业务。</p>
</blockquote>
<p>关键字 -&gt; 『<strong>代公众号实现业务</strong>』。这几个字就是第三方平台的作用。当然，不光是公众号，还有小程序，，因为公众号业务比小程序实现的要早，文档维护不及时。。<br>以公众号为例，，公众号的开发首先是面向大众的，有微信公众号后台页面，图形化页面中也可以个性化定制一些功能，比如自定义消息回复什么的。但如果深度定制的话，就需要开发者通过调用微信接口实现了，接口的令牌就是access_token，既可以通过它识别公众号身份，又可以控制请求次数 频率什么的。那第三方平台呢，为了免去为多个客户重复开发相同业务麻烦，一套接口，一个项目实现所有用户的业务(当然，需要参数来区分每个请求属于哪个公众号)。<br>同理，小程序。</p>
<p>这就是第三方平台存在的价值。客户具体怎么授权第三方平台实现业务，可以<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1453779503&token=43d90291769311af7af9b34c6c7b93ef600525b7&lang=zh_CN">授权流程技术说明</a>，也可以参考我之前的博客<a href="http://someoneiscoding.com/2018/06/06/WeChat-third-party-platform-mina/">微信第三方平台小程序爬坑</a>。</p>
<p>另外，公众号或小程序授权给第三方平台时，可以自定义要授权的权限。潜台词就是，将相关权限授权给第三方平台后，那么相应的权限就由第三方平台实现，未授权的权限还是由自己开发开发实现。有些权限是互斥的，有些则是可以同时授权给多个平台的，，比如<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1498704199_1bcax&token=43d90291769311af7af9b34c6c7b93ef600525b7&lang=zh_CN">微信开放平台账号管理权限</a>。其中就有提到，，</p>
<blockquote>
<p><strong>小程序只可将此权限集授权给一个第三方平台，即授权互斥</strong>。</p>
</blockquote>
<p>其余的互斥权限倒没怎么注意到。</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>微信第三方平台</tag>
      </tags>
  </entry>
  <entry>
    <title>微信第三方平台小程序爬坑</title>
    <url>/2018/06/06/WeChat-third-party-platform-mina/</url>
    <content><![CDATA[<p>紧接上篇文章-<a href="http://someoneiscoding.com/2018/05/31/about-wechat-authorize3rd-component_verify_ticket&component_access_token/">关于获取微信第三方平台的 component_verify_ticket 和 component_access_token</a>-之后，，</p>
<h4 id="我以为…"><a href="#我以为…" class="headerlink" title="我以为…"></a>我以为…</h4><p>在上篇中，获取 component_access_token 之后，看看下边的步骤好像跟自己没什么太大关系了，直接跳过『<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1453779503&token=&lang=zh_CN">授权流程技术说明</a>』之后的步骤，，开始准备『代小程序实现业务』中的<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1492585163_FtTNA&token=&lang=zh_CN">微信登陆</a>，，没想到步子迈的有点大，终究还是扯着 * 了。。</p>
<p>顺着这个思路走，，在做 微信登陆 <span id="wxminalogin"></span>时，对于开发者来讲，也没有什么太大违和感呀，，👇 下边的参数也都有了呀，，</p>
<blockquote>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="center">是否必须</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">appid</td>
<td align="center">是</td>
<td align="left">小程序的AppID</td>
</tr>
<tr>
<td align="left">js_code</td>
<td align="center">是</td>
<td align="left">登录时获取的 code</td>
</tr>
<tr>
<td align="left">grant_type</td>
<td align="center">是</td>
<td align="left">填authorization_code</td>
</tr>
<tr>
<td align="left">component_appid</td>
<td align="center">是</td>
<td align="left">第三方平台appid</td>
</tr>
<tr>
<td align="left">component_access_token</td>
<td align="center">是</td>
<td align="left">第三方平台的 component_access_token</td>
</tr>
</tbody></table>
</blockquote>
<p>然而，在请求接口的时候，报如下错误👇</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;errcode&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">40001</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;errmsg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;invalid credential, access_token is invalid or not latest, hints: [ req_id: MNHl9a0063th42 ]&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>这时候首先是很费解，，为什么会报<em>不合法的调用凭证</em>错误？access_token 有问题，，</p>
<ul>
<li>component_access_token 有问题？不能啊，刚刚获取的，还热乎呢。。</li>
<li>但是参数中只传了这一个包含 access_token 的参数呀。。</li>
</ul>
<p>为了验证 component_access_token 是否有效，紧接着去以步骤 3 的方法获取预授权码 pre_auth_code了，，事实证明，完全没问题。这就有点蹊跷了，，</p>
<p>去小程序官方社区找相关帖子，比如<a href="https://developers.weixin.qq.com/blogdetail?action=get_post_info&docid=0008c6c53280d00c0546c0ef352000&highline=40001%20">微信开放平台 用户微信登录失败 invalid credential</a>，，下边有官方回复是 👇</p>
<blockquote>
<p>应该是login换取的code失效或者已经被消费了，导致获取到了错误的access_token，请检查后端login的逻辑<br>的确有可能，，因为 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html#wxloginobject">调用接口wx.login() 获取临时登录凭证（code）</a>是有时效限制的，目前有效期为5分钟，，而且测试之后发现，<strong>Code 是一次性的！！！</strong>就像发帖的哥们儿回复的那样，，<strong>Code 复用之后，的确会报 41063 的错误</strong>。</p>
</blockquote>
<p>至此，，哥们儿彻底在这儿趴窝了。。。带着”BUG”下班了，不好。</p>
<h4 id="乖乖看文档吧"><a href="#乖乖看文档吧" class="headerlink" title="乖乖看文档吧"></a>乖乖看文档吧</h4><p>根据以往的经验，，</p>
<ol>
<li>网上找不到类似的问题，，乖乖看文档</li>
<li>找到了类似的问题，根据别人提供的解决方案，还是解决不了，，乖乖看日志，检查上下文</li>
<li>实在没辙了，，抄一遍文档，从头儿开始！</li>
</ol>
<p>我决定乖乖看文档，，从『代小程序实现业务』中的开发简介开始。</p>
<h5 id="第一步：绑定开发小程序"><a href="#第一步：绑定开发小程序" class="headerlink" title="第一步：绑定开发小程序"></a>第一步：绑定开发小程序</h5><p>Done！</p>
<h5 id="第二步：小程序模版的开发和上传"><a href="#第二步：小程序模版的开发和上传" class="headerlink" title="第二步：小程序模版的开发和上传"></a>第二步：小程序模版的开发和上传</h5><p>Done！</p>
<h5 id="第三步：添加到小程序模版库，获得模版ID"><a href="#第三步：添加到小程序模版库，获得模版ID" class="headerlink" title="第三步：添加到小程序模版库，获得模版ID"></a>第三步：添加到小程序模版库，获得模版ID</h5><p>Done！</p>
<h5 id="第四步：调用接口，为旗下授权的小程序部署代码"><a href="#第四步：调用接口，为旗下授权的小程序部署代码" class="headerlink" title="第四步：调用接口，为旗下授权的小程序部署代码"></a>第四步：调用接口，为旗下授权的小程序部署代码</h5><p><strong>？？？</strong></p>
<p>可能我错过了些什么。。。赶紧去看『<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1489140610_Uavc4&token=&lang=zh_CN">代码管理</a>』</p>
<h5 id="1、为授权的小程序帐号上传小程序代码"><a href="#1、为授权的小程序帐号上传小程序代码" class="headerlink" title="1、为授权的小程序帐号上传小程序代码"></a>1、为授权的小程序帐号上传小程序代码<span id="commitcode"></span></h5><p>调用接口所需参数中的 access_token，需要使用第三方平台获取到的该小程序授权的authorizer_access_token，，到这儿，明了了。还是需要按『<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1453779503&token=&lang=zh_CN">授权流程技术说明</a>』的流程来。。</p>
<h4 id="还得按流程来"><a href="#还得按流程来" class="headerlink" title="还得按流程来"></a>还得按流程来</h4><h5 id="步骤1：第三方平台方获取预授权码（pre-auth-code）"><a href="#步骤1：第三方平台方获取预授权码（pre-auth-code）" class="headerlink" title="步骤1：第三方平台方获取预授权码（pre_auth_code）"></a>步骤1：第三方平台方获取预授权码（pre_auth_code）</h5><p>这个真没啥说的，测试一遍过，，这儿要出啥问题，极有可能是 component_access_token 的问题。</p>
<h5 id="步骤2：引入用户进入授权页"><a href="#步骤2：引入用户进入授权页" class="headerlink" title="步骤2：引入用户进入授权页"></a>步骤2：引入用户进入授权页<span id="componentloginpage"></span></h5><p>这一步之前也看过，，当时想到的场景只有公众号的，觉得这个跟小程序没啥关系呀。总不能让用户在小程序中以这种方式进行所谓的授权的？！</p>
<p>(PS:事实证明，的确不会让用户在小程序中以这种方式授权，<strong>naive</strong>!!在这儿，我对整个第三方平台的作用，以及授权流程还不清晰，，以为像 oauth 2.0 一样，<strong>naive</strong>!!! <strong>这里的授权其实是公众号或者小程序授权给第三方平台，就像第三方平台文档中菜单说的那样『代公众号实现业务』、『代小程序实现业务』</strong>。在这里，还没有面向终端用户，面向的是使用第三方平台的客户，客户的公众号或者小程序面向终端用户。)</p>
<p>看这个接口的时候有一丢丢费解，，梳理之后大概是这样 👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">获取预授权码（pre_auth_code）<br>=&gt; 引导用户进入一静态页面，页面中有一链接或一按钮，用户点击<br>=&gt; 进入微信授权页<br>=&gt; 用户确认要授予第三方平台的权限，决定是否授权<br>=&gt; End<br></code></pre></td></tr></table></figure>
<p>大概解释下，，我觉得，<em>获取预授权码（pre_auth_code）</em>和<em>引导用户进入授权页</em>这两个关系很紧密，某种程度上是一个步骤，，因为预授权码只能用在引导用户跳转向授权页面的链接中。所以，，我直接把这两步合并了：获取预授权码（pre_auth_code），返回引导授权页面。</p>
<ol>
<li><p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901133435-thirdAuthorize.png" alt="@引导页"></p>
</li>
<li><p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901133332-componentloginpage.jpeg" alt="@微信授权页 =&gt; Tips:若未全网发布，则需要**提前将要授权的测试公众号及小程序的原始ID添加到第三方平台的测试公众号列表中！！！**|300*550"></p>
</li>
</ol>
<h5 id="步骤3：用户确认并同意登录授权给第三方平台方"><a href="#步骤3：用户确认并同意登录授权给第三方平台方" class="headerlink" title="步骤3：用户确认并同意登录授权给第三方平台方"></a>步骤3：用户确认并同意登录授权给第三方平台方</h5><p>EASY~</p>
<h5 id="步骤4：授权后回调URI，得到授权码（authorization-code）和过期时间"><a href="#步骤4：授权后回调URI，得到授权码（authorization-code）和过期时间" class="headerlink" title="步骤4：授权后回调URI，得到授权码（authorization_code）和过期时间"></a>步骤4：授权后回调URI，得到授权码（authorization_code）和过期时间</h5><p>授权流程完成后，授权页会自动跳转进入回调URI，并在URL参数中返回授权码和过期时间(redirect_url?auth_code&#x3D;xxx&amp;expires_in&#x3D;600)[^1]</p>
<p>在<a href="#componentloginpage">第二步</a>中，有个参数<code>redirect_uri</code>，这个参数其实是以接口的形式指向了一个我们自身定义的回调函数，，在这个接口中我们可以通过	<code>request.getParameter()</code>获取到<code>auth_code</code>和<code>expires_in</code>两个参数。</p>
<h5 id="步骤5：利用授权码调用公众号或小程序的相关API"><a href="#步骤5：利用授权码调用公众号或小程序的相关API" class="headerlink" title="步骤5：利用授权码调用公众号或小程序的相关API"></a>步骤5：利用授权码调用公众号或小程序的相关API</h5><p>剩下的就简单了，，</p>
<h6 id="使用授权码换取公众号或小程序的接口调用凭据和授权信息"><a href="#使用授权码换取公众号或小程序的接口调用凭据和授权信息" class="headerlink" title="使用授权码换取公众号或小程序的接口调用凭据和授权信息"></a>使用授权码换取公众号或小程序的接口调用凭据和授权信息</h6><p>接口调用请求说明</p>
<blockquote>
<p>http请求方式: POST（请使用https协议）<br><code>https://api.weixin.qq.com/cgi-bin/component/api_query_auth?component_access_token=xxxx</code></p>
</blockquote>
<p>POST数据示例:</p>
<blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&gt;<span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;component_appid&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;appid_value&quot;</span><span class="hljs-punctuation">,</span><br> <span class="hljs-attr">&quot;authorization_code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;auth_code_value&quot;</span><br>&gt;<span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"><br>在返回结果中，在 authorization_info 对象中可以获取到 `authorizer_appid`、`authorizer_access_token`、`authorizer_refresh_token`三个重要参数。但是，有一点还不算太确定，，`authorizer_access_token`和`authorizer_refresh_token`是否与`authorizer_appid`相关。换句话说，，`authorizer_appid`不同，其他两个值是不是也不一样？？根据官方对`authorizer_refresh_token`的解释👇<br><br>&gt;接口调用凭据刷新令牌（在授权的公众号具备API权限时，才有此返回值），刷新令牌主要**用于第三方平台获取和刷新已授权用户的 access_token，只会在授权时刻提供**，请妥善保存。 一旦丢失，只能让用户重新授权，才能再次拿到新的刷新令牌。<br><br>我觉得应该是不一样的。总不能有新用户授权给第三方之后，之前已经授权的用户的刷新令牌就失效了吧。。后期可以分析下日志确定下这个问题。<br><br>到这儿，，我们就可以回到最初[为授权的小程序帐号上传小程序代码](#commitcode)的步骤了，现在上传应该就不会有问题了~上传成功后，[『微信登陆』](#wxminalogin)也是一遍过~<br><br>**完美！！！**<br><br><br>---<br><br>[^1]: <br>这儿坑比较大，，(WeChat-ID:shangD)，，还有一点需要注意!!!👇<br>**公众号授权，只需要运营者权限即可；但小程序授权，必须得是管理员！！！**<br>另外，，如果在没有授权的情况下，去调用相应公众号或小程序的接口时会得到`&#123;&quot;errcode&quot;:48001,&quot;errmsg&quot;:&quot;api unauthorized&#125;`,或`&#123;&quot;errcode&quot;:61003,&quot;errmsg&quot;:&quot;component is not authorized by this account&#125;`。此时应该先检查是否授权，可以利用[公众号第三方平台的权限说明](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419318459&amp;token=&amp;lang=zh_CN)接口。如果，已经公众号或者小程序授权给第三方，，此时应该检查授权时的权限；可以重新走一遍授权流程，在授权页检查权限集；如果是小程序的话，可以去小程序后台 =&gt; 设置 =&gt; 第三方服务查看。<br><br><br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>世界需要什么样的智能系统</title>
    <url>/2019/07/16/What_kind_of_intelligent_system_does_the_world_need/</url>
    <content><![CDATA[<p>本文摘自<a href="https://mp.weixin.qq.com/s/-R2STDlZEvE8uWSIBGDCYA">吴翰清-世界需要什么样的智能系统</a>(节选)</p>
<hr>
<h4 id="科技的进步是为了解放生产力"><a href="#科技的进步是为了解放生产力" class="headerlink" title="科技的进步是为了解放生产力"></a>科技的进步是为了解放生产力</h4><p>我将生产力的进步分为五个阶段：<strong>体力劳动，机械化，电气化，信息化，智能化</strong>。其中每一次科技的进步，都会带来生产力的解放，对社会的改变是巨大的。</p>
<p>在140年前发生的第二次科技革命，让电力深入到各行各业。自从中央发电站和交流电变压器等关键技术构建的电力基础设施成型后，获取电力的成本逐渐降低，各种各样的电气应用开始涌现，人们获取到了新的、稳定的能源。</p>
<p>我们现在知道电力最早是应用在电话、电报、电灯上的，也正是电气照明这一需求，拉动了电力基础设施的发展。因为在当时电力的用途比较单调，并没有今天这么琳琅满目的电器。在100年前爱迪生通用电气与威斯汀豪斯之间的主要竞争就是聚焦在电气照明领域。我们很难说在这个过程中，到底是电灯泡更重要，还是发电站更重要。我曾经比喻说当前云计算面临的窘境，就是「中央发电站」已经造出来了，我们有单集群上万台服务器规模的算力基础设施，但是「电灯泡」在哪里却没有找到。<strong>我们用「中央发电站」在点「煤气灯」，今天托管在云计算上的业务，大多数依然是「信息化系统」。而理想中的会消耗大量算力的应用，应当是「智能化系统」</strong>。我们一直在苦苦追寻云计算的「电灯泡应用」，却求之不得。</p>
<p>这里需要讲清楚「信息化系统」和「智能化系统」的区别。我认为「信息化系统」的本质是编辑数据库，一个业务系统如果存在大量人工交互，依赖于人提交表单来完成业务，那么就是一个信息化系统。而<strong>我理想中的「智能化系统」，应该是以自动完成任务为目的，以任务作为输入，以完成的结果作为输出，中间的过程应该是机器高度自动化完成的。以其完成任务的复杂度，来评价其智能程度的高低。</strong></p>
<p>从这个角度看，「智能手机」并不智能，依然是个「信息化系统」。市面上形形色色的智能系统也都只是冠上了智能的名号在鱼目混珠。我并不是说「信息化系统」没有价值，信息化系统很有价值，但不是下个时代的东西。自从计算机技术发展以来，产生的各色各样的信息化系统极大地改变了世界，完成了从「电气化」到「信息化」转型升级的重要一步。这就是我们看到各色各样的计算机系统开始应用在各个领域，帮助人们更加高效的管理工作和提供服务。</p>
<p>互联网在这一过程中扮演了放大作用。我认为互联网本身并不是生产力，互联网只是连接了成千上万个信息化系统，从而具备了规模效应。互联网是规模经济，能让一个系统的价值实现上千倍、上万倍的放大，但是生产力是信息化系统本身提供的。能够接收互联网连接服务的终端，是浏览器，是 iOS 和 Android，这些端的演进本身是重要的。百度通过互联网连接了人和信息，腾讯通过互联网连接人和人，阿里通过互联网连接了人和信息化服务。但是这些都不是下一个时代的东西。</p>
<p>下一个时代会发生的事情，首先是出现智能化系统对信息化系统的升级换代，然后会出现通过互联网连接所有智能化系统的公司。智能化对信息化的升级换代，是一次巨大的生产力进步，处于社会变革中的商业公司的结局是适者生存。从历史来看，在信息化时代的PC操作系统升级换代到移动操作系统，其过程就是天翻地覆的。苹果的iPhone 发布之后，所有的开发者都不再给微软的 Windows 写软件，而转去给 iOS 写软件，对微软带来了强烈的冲击，如果不是微软后来又抓住了云计算的机遇，就很可能会从此一蹶不振。从商业发展的角度看类似事件一定会发生，在信息化时代的庞然大物很可能随着一次生产力的变革就变得无足轻重。那么现在所有的问题在于，未来世界需要的智能系统到底是什么？</p>
<p>让机器获得智能，一直是计算机科学家孜孜以求的事情。在过去简单的专家系统，依靠经验和规则，也能处理简单的任务。但有一个弊病是对于专家经验未覆盖的异常情况，机器就不知道怎么处理了。所以后来出现了数据驱动诞生的智能。</p>
<p>我们看到当机器具备一定的智能后，就能处理相对简单的任务，从而部分地解放人的生产力，此时增加机器规模就等同于增加人力的规模。而机器智能和人的智能又各有所长，机器运算量大且不知疲倦，因此对于很多工作都有可能做到精细化管理。这往往能带来成本的节约。</p>
<p>比如在过去公交车的排班是按照经验，在一个线路里设置好公交车的数量，但是如果市民的出行情况发生波动时，公交车的供需关系之间一定会存在差异，有的线路会繁忙，有的线路则会空闲，从而出现资源的浪费。要解决这一问题需要先统计清楚每辆公交车每一趟的精确载客人数，再依靠机器智能精细化的调度公交车到不同的线路，就能在同等资源下实现效率最优。因此使用机器智能的好处是显而易见的。</p>
<h4 id="五年前做不出大规模的机器智能系统"><a href="#五年前做不出大规模的机器智能系统" class="headerlink" title="五年前做不出大规模的机器智能系统"></a>五年前做不出大规模的机器智能系统</h4><p>我们看到在生产力发展的过程中，从信息化到智能化的这一转型升级正在到来，已经到了爆发的前夜。这得益于四项技术的成熟：云计算、大数据、IoT、网络连接技术。</p>
<p>我们知道机器智能当前的发展是得益于对脑科学的研究，以及算力的进步，让神经网络进化到了深度学习，从而在视觉、语音等领域有了重大突破。算力的重要性毋庸置疑，但是光有算力依然难以在实际的应用中取得成功，还需要其他几项技术的成熟。在当前的技术环境来说，云计算为智能提供了足够的算力，是算力基础设施；大数据技术提供了数据处理的方法论和工具，是数据基础设施（当前还没有垄断性的数据基础设施，碎片化严重）；IoT 技术将智能设备的成本降到了足够低，为部署丰富的神经元感知设备提供了基础；网络连接技术，从4G到5G，为数据的高速传输提供了重要基础。</p>
<p>如果有科技树这种说法的话，那么机器智能的大规模应用，就需要先点亮前四个技术，这是基础。在五年以前，这几项技术的成本是制约我们将智能技术大规模应用的主要瓶颈。到今天已经逐渐成熟了。</p>
<p>在一项新技术刚出现的时候，我们往往会遇到两个问题。</p>
<p><strong>第一个问题是人才的稀缺性问题</strong>。我们知道一个懂深度学习或其他机器智能技术的博士生刚毕业的年薪可能比得上一个工作了十年的程序员。业界各处都需要机器智能，供不应求。</p>
<p><strong>第二个问题是技术的成本问题</strong>。新技术刚出来的成本一定是昂贵的，就像云计算刚出来的时候也是先解决能力问题，再解决效率问题。我前些时看一个报告，AWS 的 EC2 推出到现在连续降价了57次。我们熟知的摩尔定律，计算的性能每18个月翻一倍，也就意味着同等算力的硬件每18个月会降一半的成本。机器智能作为新技术也有同样的规律，在一开始我们不要指望它的成本会足够便宜到能进入千家万户，新技术的普及需要时间。只是我们往往迫不及待。</p>
<p>这两个问题决定了机器智能在一开始的时候，应该首先被应用在对社会效率撬动最大的那个点上。从商业上我们要找到这样的场景，来让这项技术脱离实验室，走向社会，通过商业来源源不断的滋养这项技术的迅速成长。</p>
<h4 id="世界需要什么样的机器智能系统"><a href="#世界需要什么样的机器智能系统" class="headerlink" title="世界需要什么样的机器智能系统"></a>世界需要什么样的机器智能系统</h4><p>这两个问题随着时间的推移很快就能解决。但今天产业界真正碰到的问题我认为是搞偏了方向。这体现在两个方面。</p>
<p><strong>第一个问题是未来不应该存在一个「人工智能」的产业，我们今天的分类就分错了</strong>。就像自电力基础设施诞生以来，各行各业都需要用电，因此电力成为了一个关键生产要素。我认为未来智能也是一个关键生产要素，每个行业都需要，因此不需要单独划分一个人工智能产业。单独搞了一个人工智能产业，反倒不知道这些公司在干什么了，这些公司自己也产生了困惑。最终应该像今天的零售业一样，每个做零售的都有个电商部门，会通过互联网来做营销和销售。<strong>未来每个企业也应该有一个部门，就是负责他们的智能系统的建设与训练。要像训练宠物一样训练智能系统，使他具备智能。这不是某一家人工智能公司要做的事情，而是每家公司都要自己做的事情</strong>。</p>
<p><strong>第二个问题和机器智能技术的发展有关</strong>。因为最近这次机器智能的热点是从深度学习开始，在视觉、语音等领域有了巨大突破，因此产业化后的企业往往都是在做视觉、语音、自然语言处理等工作。但是我们千万别忘了完整的人脑智能是从「感知」到「行动」，并通过不断的反馈完成高频率的协同，最终诞生了智能。</p>
<p>只做「感知」是一个巨大的误区，从技术上讲没有问题，但是从商业上讲创造的社会价值就很有限了，因为其解放的生产力相对是有限的。</p>
<p>从生产力发展的角度来讲，评判一个智能系统的社会价值，应该以它解放生产力的多少来衡量。只做「感知」就是只能看，但是做了这么多大型项目后，我发现所有的价值创造都是在于「处置」环节。因此只做感知，很难讲清楚投入产出是否值得，但是一旦开始进入到「行动」环节，就会开始解放生产力，价值是可被量化的。这里的行动，是机器智能实现了对人力或其他设备的调度。</p>
<p>实际上从技术发展的角度看，我们早就拥有了让机器智能做决策的能力。搜索引擎和个性化推荐，就是典型的通过机器智能做决策。通过每天处理海量的数据，最终实现精细化的匹配。</p>
<p>所以<strong>我认为一个完整的「智能系统」，是包含了「感知」与「行动」，其中支撑行动的是决策和调度的技术。而衡量这个智能系统是否有价值的标准，是看其解放的生产力的多少。</strong></p>
<p>遗憾的是，到今天为止我认为业界并不存在一个理想的「智能系统」。业界当前的状态我称之为「有智能，没系统」。很多人工智能的创业公司拥有局部的智能能力，比如视觉、语音、NLP、知识图谱、搜索、推荐等中的一项或多项技术，但是很少有公司有完整的技术栈。而像 BAT 等公司具备完整的技术栈，但是却并没有将所有的技术整合成为「感知」+「行动」的一个完整系统，而是各项技术以碎片化的形式存在。尤其是将所有技术应用到某一个具体场景中解决某一个具体问题的，更是寥寥无几，而这正是催生出这一智能系统的关键所在。所以这是一个工程化的问题，工程化的挑战在于整合所有智能技术，实现完整的「感知」+「行动」能力，并有效的控制成本，实现对开发者友好的接口。</p>
<p>在智能技术的角度来看，「自动驾驶」和「智能音箱」是两个完整的从「感知」到「行动」闭环的场景。我认为这两个场景可以用来打磨机器智能技术，但是当前在商业上比较难成功。「自动驾驶」解放了所有的驾驶员，对解放生产力的价值非常明显，但是因为受制于今天城市的道路基础设施，因此对老城市的意义不大。今天城市的道路不是为自动驾驶设计的，也很难容纳下自动驾驶的汽车。因此自动驾驶更适合航空、航海、物流等领域，商业范围一下小了很多。「智能音箱」综合了多项机器智能技术，其核心技术「对话机器人」被称为人工智能领域的圣杯，想要做好难度相当之大。但是「智能音箱」当前的阶段对家庭中各种任务的生产力解放极其有限，价值很难讲清楚，最后沦为玩物的可能性比较大。尽管如此，随着时间的推移，随着基础设施的更新换代，这两项技术也会逐渐焕发出他们的生命力。</p>
<p>如果用航空业来比喻的话，今天的智能技术，就好比造飞机，市面上已经有了很多零件和引擎，但是所有的厂商都拿着零件当飞机卖，客户以为他买了一架飞机，其实只是买了个零件（因为生产力并没有得到多大的解放）。而今天真正的难点在于飞机设计图纸都还没有。</p>
<p>所以我打算先画一张，造架飞机玩玩。</p>
<h4 id="构建智能时代"><a href="#构建智能时代" class="headerlink" title="构建智能时代"></a>构建智能时代</h4><p>飞机想要真正飞上天，还需要几个东西。</p>
<p>首先是飞行员。飞行员不一定要懂得怎么造飞机，造飞机是个门槛很高的活。但是飞行员要懂得怎么开飞机，最后还要让人人都能坐飞机。我认为飞行员就是未来各个企业里智能部门的员工，他们负责训练买来的智能系统，让智能系统真正具备智能。由于各个企业拥有的数据的不同，以及「飞行员」技能的高低和责任心，最后的各个企业的智能系统的聪明程度也会出现差异。世界是丰富多彩的。</p>
<p>其次是航道。我认为航道依然是基础设施提供商的，包括运营商、云计算厂商等。</p>
<p>最后是机场。机场需要负责所有航班的调度和协同，为所有的飞机提供服务。这是最有意思的地方。我认为「机场」是最后真正的商业模式，就像苹果的 AppStore 一样。</p>
<p><strong>我认为在智能时代的「机场」，最重要的工作是给机器智能系统提供服务，而并非给人提供服务。</strong></p>
<p>想象一下未来互联网里，70%-80%的人口是机器智能，他们处理了未来世界的绝大多数工作，而每一个机器智能又是有一个主人的。其主人可以是个人，也可以是组织，但都是有主权的。每一个机器智能存在的目标都是为了完成某个或多个任务。那么为所有的机器智能提供服务，就会是一个巨大的商业模式。</p>
<p><strong>机器智能系统的自动协同是通往未来的关键路径</strong></p>
<p>同时我也认为当前的机器智能产业，过于重视人与机器的交互，而忽视了机器与机器的交互。而后者才是更重要的事情。因为人与机器的交互依然是回到了信息化系统的老路上去，而机器与机器的自动协同，则是在进一步将智能系统的价值实现规模放大。</p>
<p>因此未来有必要给所有的机器智能定义一套语言，他们之间的交流可以像人一样拥有自己的语言，实现简单的逻辑。而所有机器智能之间的交互与协同，是不需要人工干预的，就像你家的孩子与邻居家的孩子自己会去玩耍一样，你不需要干预到他们的交流之中，他们自己会各取所需地完成各自的任务。</p>
<p>以「一网通办」的业务举例。在当前一网通办的主流实现办法是将政府各委办局的数据实现全量汇聚后，进行数据治理，并梳理流程，重塑业务。这种大数据应用的思路依然是停留在信息化建设的老路上，其弊端是想推动新技术落地的前提是流程先改革，同时各个不同地区的高度定制化导致很难在全国实现规模化的产品。但其实也可以有另外一种智能化的建设思路，让每个委办局自己建一个机器智能系统，其任务就是代替公务员处理各自的窗口业务。当市民来提交一个申请时，经过认证后，该委办局的机器智能系统就根据所需材料，自行向其他委办局的机器智能系统发出协同请求，经过几轮机器智能之间的交流和协同之后，市民很快就得到了他想要的结果。这种多个机器智能系统之间自动协同的机制，对流程的冲击明显会小很多。</p>
<p>机器智能之间的交互与协同需要通过网络连接到一起，但安全性是可控的，因为是业务之间的协同，而并非数据本身发生了交换。因为每一个机器智能都有自己的主人，所有的训练过程也都发生在其主体内部，因此数据并不需要被拿出来交换共享。主人可以设定机器智能什么能说，什么不能说，所有的安全控制都发生在智能系统内部，而一旦连接到互联网要与其他机器智能协同或使用「机场」提供的服务，就会转为「默认不信任」模式。</p>
<p>至于机器智能系统到底部署在公共云还是专有云，这并不是一个重要的问题，主人爱部署在哪里就部署在哪里。所以时至今日，云计算依然有被管道化的危险，就像运营商被互联网内容提供商管道化一样，未来云计算厂商也可能会被智能厂商管道化。因为云计算和大数据都不是智能。</p>
<h4 id="A组"><a href="#A组" class="headerlink" title="A组"></a>A组</h4><p>也因此，为了以上这些构想，我受命在阿里云成立「A组」。「A组」成立的使命就是为了构建出这一机器智能系统，让智能时代更快的到来。</p>
<p>我认为这是一件需要整个社会共同努力三十到五十年的事情，就像在过去的三十到五十年我们在信息化建设上付出的所有努力一样。</p>
<p>以上，就是我想对世界说的话。</p>
<p>我说，你听。</p>
<p><strong>阿里云-GTS-A组    吴翰清</strong></p>
]]></content>
      <categories>
        <category>Quote</category>
      </categories>
      <tags>
        <tag>智能</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 ArrayList</title>
    <url>/2019/04/03/about_ArrayList/</url>
    <content><![CDATA[<p>包括之前的 <code>HashMap</code> 和 <code>LinkedList</code>, 都是基于 JDK 7的(应该全面拥抱JDK 8了)。</p>
<h4 id="ArrayList-的-DOC-注释"><a href="#ArrayList-的-DOC-注释" class="headerlink" title="ArrayList 的 DOC 注释"></a>ArrayList 的 DOC 注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Resizable-array implementation of the &lt;tt&gt;List&lt;/tt&gt; interface.  Implements</span><br><span class="hljs-comment"> * all optional list operations, and permits all elements, including</span><br><span class="hljs-comment"> * &lt;tt&gt;null&lt;/tt&gt;.  In addition to implementing the &lt;tt&gt;List&lt;/tt&gt; interface,</span><br><span class="hljs-comment"> * this class provides methods to manipulate the size of the array that is</span><br><span class="hljs-comment"> * used internally to store the list.  (This class is roughly equivalent to</span><br><span class="hljs-comment"> * &lt;tt&gt;Vector&lt;/tt&gt;, except that it is unsynchronized.)</span><br><span class="hljs-comment"> * (ArrayList) 通过 List 接口实现的容量可变数组。实现了 list 的所有可选操作(方法)，并且允许添加所有元素，包括 null。除了实现了 List 的接口，ArrayList 还提供了修改用来容纳 list 的数组的 size 的方法(ArrayList 是非线程安全的，除此以外大致上与 Vector 相同)。</span><br><span class="hljs-comment"> * &lt;p&gt;The &lt;tt&gt;size&lt;/tt&gt;, &lt;tt&gt;isEmpty&lt;/tt&gt;, &lt;tt&gt;get&lt;/tt&gt;, &lt;tt&gt;set&lt;/tt&gt;,</span><br><span class="hljs-comment"> * &lt;tt&gt;iterator&lt;/tt&gt;, and &lt;tt&gt;listIterator&lt;/tt&gt; operations run in constant</span><br><span class="hljs-comment"> * time.  The &lt;tt&gt;add&lt;/tt&gt; operation runs in &lt;i&gt;amortized constant time&lt;/i&gt;,</span><br><span class="hljs-comment"> * that is, adding n elements requires O(n) time.  All of the other operations</span><br><span class="hljs-comment"> * run in linear time (roughly speaking).  The constant factor is low compared</span><br><span class="hljs-comment"> * to that for the &lt;tt&gt;LinkedList&lt;/tt&gt; implementation.</span><br><span class="hljs-comment"> * size，isEmpty，get，set，iterator 方法和 listIterator 操作的时间复杂度是O(1)的(常数级)。add() 方法的时间复杂度是O(1)+的(amortized constant time)(因为涉及到list 扩容，扩容也需要时间，需要把这部分时间平均分摊到每次 add 操作中。)，也就是说，添加元素的时间复杂度为O(n)。其他操作的时间复杂度大致为O(n)，常量值 n 通常要比 LinkedList 的时间复杂度中常量值要小(即，其他操作要比 LinkedList 的其他操作要快一点)。</span><br><span class="hljs-comment"> * &lt;p&gt;Each &lt;tt&gt;ArrayList&lt;/tt&gt; instance has a &lt;i&gt;capacity&lt;/i&gt;.  The capacity is</span><br><span class="hljs-comment"> * the size of the array used to store the elements in the list.  It is always</span><br><span class="hljs-comment"> * at least as large as the list size.  As elements are added to an ArrayList,</span><br><span class="hljs-comment"> * its capacity grows automatically.  The details of the growth policy are not</span><br><span class="hljs-comment"> * specified beyond the fact that adding an element has constant amortized</span><br><span class="hljs-comment"> * time cost.</span><br><span class="hljs-comment"> * 每一个 ArrayList 实例都有一个 capacity(容量)属性，该属性不小于 list 的 size。当向 ArrayList 中添加元素时，它的 capacity 会自动增长。除了添加一个元素具有固定的摊余时间成本之外，增长规则的细节没有被指定。</span><br><span class="hljs-comment"> * &lt;p&gt;An application can increase the capacity of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance</span><br><span class="hljs-comment"> * before adding a large number of elements using the &lt;tt&gt;ensureCapacity&lt;/tt&gt;</span><br><span class="hljs-comment"> * operation.  This may reduce the amount of incremental reallocation.</span><br><span class="hljs-comment"> * 在程序中添加大量元素之前，可以调用 ensureCapacity() 方法来对 ArrayList 进行扩容。这样可以减少多次扩容所花费的时间(可以减少扩容的次数)</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span><br><span class="hljs-comment"> * If multiple threads access an &lt;tt&gt;ArrayList&lt;/tt&gt; instance concurrently,</span><br><span class="hljs-comment"> * and at least one of the threads modifies the list structurally, it</span><br><span class="hljs-comment"> * &lt;i&gt;must&lt;/i&gt; be synchronized externally.  (A structural modification is</span><br><span class="hljs-comment"> * any operation that adds or deletes one or more elements, or explicitly</span><br><span class="hljs-comment"> * resizes the backing array; merely setting the value of an element is not</span><br><span class="hljs-comment"> * a structural modification.)  This is typically accomplished by</span><br><span class="hljs-comment"> * synchronizing on some object that naturally encapsulates the list.</span><br><span class="hljs-comment"> * 需要注意的是，ArrayList 对 List 的实现是非同步的。如果多线程同时请求对 ArrayList 的访问，并且至少会有一个线程对 ArrayList 进行结构性修改(结构性修改是指添加或删除一个以上的元素，或者显式的修改了其数组的大小。仅仅修改元素值并非结构性修改)，那么务必在 ArrayList 外部进行 synchronized 修饰。这通常是通过 synchronized 修饰 封装了 list 的某个对象来实现的。</span><br><span class="hljs-comment"> * If no such object exists, the list should be &quot;wrapped&quot; using the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Collections#synchronizedList Collections.synchronizedList&#125;</span><br><span class="hljs-comment"> * method.  This is best done at creation time, to prevent accidental</span><br><span class="hljs-comment"> * unsynchronized access to the list:&lt;pre&gt;</span><br><span class="hljs-comment"> *   List list = Collections.synchronizedList(new ArrayList(...));&lt;/pre&gt;</span><br><span class="hljs-comment"> * 如果(手头儿)没有这样的对象，那么应该用 Collections.synchronizedList 包裹 list。该操作最好在创建 list 时进行，以防意外的非同步访问 list。</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;a name=&quot;fail-fast&quot;/&gt;</span><br><span class="hljs-comment"> * The iterators returned by this class&#x27;s &#123;<span class="hljs-doctag">@link</span> #iterator() iterator&#125; and</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #listIterator(int) listIterator&#125; methods are &lt;em&gt;fail-fast&lt;/em&gt;:</span><br><span class="hljs-comment"> * if the list is structurally modified at any time after the iterator is</span><br><span class="hljs-comment"> * created, in any way except through the iterator&#x27;s own</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ListIterator#remove() remove&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ListIterator#add(Object) add&#125; methods, the iterator will throw a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of</span><br><span class="hljs-comment"> * concurrent modification, the iterator fails quickly and cleanly, rather</span><br><span class="hljs-comment"> * than risking arbitrary, non-deterministic behavior at an undetermined</span><br><span class="hljs-comment"> * time in the future.</span><br><span class="hljs-comment"> * 通过 ArrayList 的 iterator() 方法，或者 listIterator(int) 方法返回的 iterator 都是 fail-fast(快速失效)的：如果在创建 iterator 之后，任何对 list 的结构性修改，都会抛出 ConcurrentModificationException，除了 iterator 本身的 remove() 和 add() 方法。因此，在面临并发对 list 的修改时，iterator 会快速而干净的失效，而不是在未来不确定的时间冒着任意的、不确定的风险。</span><br><span class="hljs-comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span><br><span class="hljs-comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span><br><span class="hljs-comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span><br><span class="hljs-comment"> * throw &#123;<span class="hljs-doctag">@code</span> ConcurrentModificationException&#125; on a best-effort basis.</span><br><span class="hljs-comment"> * Therefore, it would be wrong to write a program that depended on this</span><br><span class="hljs-comment"> * exception for its correctness:  &lt;i&gt;the fail-fast behavior of iterators</span><br><span class="hljs-comment"> * should be used only to detect bugs.&lt;/i&gt;</span><br><span class="hljs-comment"> * 另外，需要注意的是，，iterator 的 fail-fast 行为是不能被保证的，，通常来说，在并发非同步对 list 的修改时，任何硬性的保证都是不可能的。fail-fast 会让 iterator 尽可能抛出 ConcurrentModificationException。因此，在程序中通过依赖抛出 ConcurrentModificationException 异常来保证自身的正常运行是错误的：fail-fast 行为只应该用来 debug。</span><br><span class="hljs-comment"> * &lt;p&gt;This class is a member of the</span><br><span class="hljs-comment"> * &lt;a href=&quot;&#123;<span class="hljs-doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span><br><span class="hljs-comment"> * Java Collections Framework&lt;/a&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Josh Bloch</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Neal Gafter</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     Collection</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     List</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     LinkedList</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     Vector</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   1.2</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable<br></code></pre></td></tr></table></figure>

<h4 id="ArrayList-的类属性及构造方法"><a href="#ArrayList-的类属性及构造方法" class="headerlink" title="ArrayList 的类属性及构造方法"></a>ArrayList 的类属性及构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Default initial capacity.</span><br><span class="hljs-comment"> * 默认初始 capacity, 10</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Shared empty array instance used for empty instances.</span><br><span class="hljs-comment"> * 对所有由无参构造函数创建的空实例共享的空数组对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The array buffer into which the elements of the ArrayList are stored.</span><br><span class="hljs-comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span><br><span class="hljs-comment"> * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to</span><br><span class="hljs-comment"> * DEFAULT_CAPACITY when the first element is added.</span><br><span class="hljs-comment"> * 临时用来存储 ArrayList 中元素的数组。 ArrayList 对象的长度就是这个缓存数组的长度。任何空 ArrayList ，且 elementData == EMPTY_ELEMENTDATA，在添加第一个元素时，数组将被扩展到默认大小(DEFAULT_CAPACITY, 10)。</span><br><span class="hljs-comment"> * (因为是临时的，所以用 transient 修饰，不会被序列化)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] elementData;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The size of the ArrayList (the number of elements it contains).</span><br><span class="hljs-comment"> * ArrayList 的 size(包含的元素的数量)。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The maximum size of array to allocate.</span><br><span class="hljs-comment"> * Some VMs reserve some header words in an array.</span><br><span class="hljs-comment"> * Attempts to allocate larger arrays may result in</span><br><span class="hljs-comment"> * OutOfMemoryError: Requested array size exceeds VM limit</span><br><span class="hljs-comment"> * 允许分配给数组的最大的容量。</span><br><span class="hljs-comment"> * 一些虚拟机实现会在数组预留一些 header words。</span><br><span class="hljs-comment"> * 视图分配更大的数组可能会造成 OOM：所需数组大小超出虚拟机限制。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty list with the specified initial capacity.</span><br><span class="hljs-comment"> * 通过指定初始 capacity 大小来构造一个空 list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  initialCapacity  the initial capacity of the list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span><br><span class="hljs-comment"> *         is negative</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-comment">// 初始容量小于零时，会抛出 IllegalArgumentException</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+<br>                                           initialCapacity);<br>    <span class="hljs-comment">//  初始化指定大小的临时对象数组                                       </span><br>    <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty list with an initial capacity of ten.</span><br><span class="hljs-comment"> * 构造一个空 list，当向该 list 添加元素时，需先扩展数组到默认初始容量大小，即 10.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-built_in">this</span>.elementData = EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a list containing the elements of the specified</span><br><span class="hljs-comment"> * collection, in the order they are returned by the collection&#x27;s</span><br><span class="hljs-comment"> * iterator.</span><br><span class="hljs-comment"> * 按照 collection 迭代器返回元素的顺序构造包含指定 collection 的元素的 list。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c the collection whose elements are to be placed into this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">// 如果 c 为 null，此处会抛 NPE</span><br>    elementData = c.toArray();<br>    size = elementData.length;<br>    <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br>    <span class="hljs-comment">// 如果 elementData 不是对象数组，还需要将其复制到新的对象数组中。</span><br>    <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].class)<br>        elementData = Arrays.copyOf(elementData, size, Object[].class);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Appends the specified element to the end of this list.</span><br><span class="hljs-comment"> * 添加指定元素到 list 末尾元素后边。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e element to be appended to this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="hljs-doctag">@link</span> Collection#add&#125;)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 确保内部数组容量足够大，初始状态下 size 为 0。</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 如果 ArrayList 由无参构造方法构造，则 minCapacity 为 1。</span><br>    <span class="hljs-keyword">if</span> (elementData == EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-comment">// 确保扩容到指定大小的容量</span><br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 结构修改次数 +1</span><br>    modCount++;<br><br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Increases the capacity to ensure that it can hold at least the</span><br><span class="hljs-comment"> * number of elements specified by the minimum capacity argument.</span><br><span class="hljs-comment"> * 扩容，以容纳指定长度的最小数量的元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> minCapacity the desired minimum capacity</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// overflow-conscious code</span><br>    <span class="hljs-comment">// 原容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 新容量 = oldCapacity * 1.5</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 如果新容量小于指定的最小容量，则新容量为指定的大小</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">// 如果新容量大于允许的最大容量值</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>    <span class="hljs-comment">// 通常 minCapacity = size + 1，所以大部分情况都是执行到这里</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 带符号二进制溢出，符号位为 1，小于零，，即 OOM。</span><br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?<br>       Integer.MAX_VALUE :<br>       MAX_ARRAY_SIZE;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inserts the specified element at the specified position in this</span><br><span class="hljs-comment"> * list. Shifts the element currently at that position (if any) and</span><br><span class="hljs-comment"> * any subsequent elements to the right (adds one to their indices).</span><br><span class="hljs-comment"> * 添加指定元素到指定位置。将当前索引位置的元素(如果有的话)及其后边的元素统一右移。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index index at which the specified element is to be inserted</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> element element to be inserted</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 检查 index 是否不小于零，且小于 size</span><br>    rangeCheckForAdd(index);<br>    <span class="hljs-comment">// list 扩容</span><br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>    <span class="hljs-comment">// 调用 native 方法复制 插入索引位置之后部分的数组 到原数组中</span><br>    System.arraycopy(elementData, index, elementData, index + <span class="hljs-number">1</span>,<br>                     size - index);<br>    elementData[index] = element;<br>    size++;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A version of rangeCheck used by add and addAll.</span><br><span class="hljs-comment"> * 为 add() 和 addAll() 方法准备的另一个版本的 rangeCheck 方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheckForAdd</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (index &gt; size || index &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      src      the source array.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      srcPos   starting position in the source array.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      dest     the destination array.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      destPos  starting position in the destination data.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      length   the number of array elements to be copied.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span>  srcPos,</span><br><span class="hljs-params">                                        Object dest, <span class="hljs-type">int</span> destPos,</span><br><span class="hljs-params">                                        <span class="hljs-type">int</span> length)</span>;<br></code></pre></td></tr></table></figure>

<h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the element at the specified position in this list.</span><br><span class="hljs-comment"> * 返回 list 中指定位置的元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  index index of the element to return</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the element at the specified position in this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    rangeCheck(index);<br>    <span class="hljs-comment">// 如果索引合规，则至今返回数组相应索引位置的元素。</span><br>    <span class="hljs-keyword">return</span> elementData(index);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Checks if the given index is in range.  If not, throws an appropriate</span><br><span class="hljs-comment"> * runtime exception.  This method does *not* check if the index is</span><br><span class="hljs-comment"> * negative: It is always used immediately prior to an array access,</span><br><span class="hljs-comment"> * which throws an ArrayIndexOutOfBoundsException if index is negative.</span><br><span class="hljs-comment"> * 检查指定的索引是否在范围内。如果不在，将抛出合适的运行时异常。该方法不会检查索引是否为负：索引总是在访问数组之前立即使用，，如果在索引为负，会抛出 ArrayIndexOutOfBoundsException 异常。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rangeCheck</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 如果索引大于数组的实际大小，会抛出数组越界异常。</span><br>    <span class="hljs-keyword">if</span> (index &gt;= size)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an IndexOutOfBoundsException detail message.</span><br><span class="hljs-comment"> * Of the many possible refactorings of the error handling code,</span><br><span class="hljs-comment"> * this &quot;outlining&quot; performs best with both server and client VMs.</span><br><span class="hljs-comment"> * 构建数组越界异常的详情信息。在很多错误处理代码可能的重构中，这个详情大纲一直在服务器模式和客户端模式中表现的一直很好。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">outOfBoundsMsg</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Index: &quot;</span>+index+<span class="hljs-string">&quot;, Size: &quot;</span>+size;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Replaces the element at the specified position in this list with</span><br><span class="hljs-comment"> * the specified element.</span><br><span class="hljs-comment"> * 用指定的元素替换 list 中指定位置的元素</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index index of the element to replace</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> element element to be stored at the specified position</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the element previously at the specified position</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    <span class="hljs-comment">// 是否大于数组的 size</span><br>    rangeCheck(index);<br>    <span class="hljs-comment">// 记录数组中当前位置的元素</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    <span class="hljs-comment">// 替换指定索引位置为新元素</span><br>    elementData[index] = element;<br>    <span class="hljs-comment">// 返回原索引位置的元素</span><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the element at the specified position in this list.</span><br><span class="hljs-comment"> * Shifts any subsequent elements to the left (subtracts one from their</span><br><span class="hljs-comment"> * indices).</span><br><span class="hljs-comment"> * 移除当前 list 中指定位置上的元素。将该位置后边的元素左移(当前索引减一)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index the index of the element to be removed</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the element that was removed from the list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 检查索引是否超出数组的 size</span><br>    rangeCheck(index);<br>    <span class="hljs-comment">// list 结构性更改次数 +1</span><br>    modCount++;<br>    <span class="hljs-comment">// 记录数组当前索引原元素</span><br>    <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br>    <span class="hljs-comment">// 计算要移动的数组的长度。</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 如果删除的不是 list 的末尾元素，则将要删除的索引位之后的元素向左移动一位。</span><br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    <span class="hljs-comment">// 数组长度-1，并将更新后的数组末尾元素置空</span><br>    <span class="hljs-comment">// 此处留坑，，在我的印象中，假如数组长度为10，那么即使是只有零索引处有值，其他位置的元素皆为空，其他对象还持有该数组对象的引用，那么GC时也不会将该数组对象回收。</span><br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>    <span class="hljs-comment">// 返回索引位置原元素</span><br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the first occurrence of the specified element from this list,</span><br><span class="hljs-comment"> * if it is present.  If the list does not contain the element, it is</span><br><span class="hljs-comment"> * unchanged.  More formally, removes the element with the lowest index</span><br><span class="hljs-comment"> * &lt;tt&gt;i&lt;/tt&gt; such that</span><br><span class="hljs-comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;</span><br><span class="hljs-comment"> * (if such an element exists).  Returns &lt;tt&gt;true&lt;/tt&gt; if this list</span><br><span class="hljs-comment"> * contained the specified element (or equivalently, if this list</span><br><span class="hljs-comment"> * changed as a result of the call).</span><br><span class="hljs-comment"> * 从当前 list 中删除指定元素的第一个匹配项，如果 list 中存在指定元素的话。严谨来说是删除索引值最小的匹配项，像是满足这样的条件：(o==null?get(i)==null:o.equals(get(i)))，如果 list 中存在 o 的话。如果 list 中存在 o，则返回 true(或者说，本次调用导致了 list 改变)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> o element to be removed from this list, if present</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 遍历删除找到的第一个 o</span><br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (elementData[index] == <span class="hljs-literal">null</span>) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index &lt; size; index++)<br>            <span class="hljs-keyword">if</span> (o.equals(elementData[index])) &#123;<br>                fastRemove(index);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Private remove method that skips bounds checking and does not</span><br><span class="hljs-comment"> * return the value removed.</span><br><span class="hljs-comment"> * 私有删除方法，该方法跳过了索引是否越界的检查，且不返回删除的元素。精简版的 remove()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 结构性更改次数 +1</span><br>    <span class="hljs-comment">// ...</span><br>    modCount++;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>        System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                         numMoved);<br>    elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns an iterator over the elements in this list in proper sequence.</span><br><span class="hljs-comment"> * 以正确的顺序返回该 list 中元素的迭代器</span><br><span class="hljs-comment"> * &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span><br><span class="hljs-comment"> * 返回的 iterator 是 fail-fast 的</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> an iterator over the elements in this list in proper sequence</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Itr</span>();<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * An optimized version of AbstractList.Itr</span><br><span class="hljs-comment"> * AbstractList.Itr 的优化版本</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// index of next element to return 要返回的下一个元素的索引</span><br>    <span class="hljs-type">int</span> cursor;<br>    <span class="hljs-comment">// index of last element returned; -1 if no such 上一个返回元素的索引，如果该元素不复存在(调用iterator.remove()删除当前元素)，则赋值为 -1</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 记录当前 list 结构性修改次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>    <span class="hljs-comment">// 是否还有未迭代过的元素</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果下一个要返回的元素的索引值不等于(即，小于)数组长度，则说明未迭代完成</span><br>        <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回下一个要迭代的元素</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 检查记录 list 结构性更改次数后(即，私有内部类 Itr 初始化完成后)，是否有其他操作对 list 进行过结构性修改。如果有，则抛出 ConcurrentModificationException。</span><br>        checkForComodification();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>        <span class="hljs-comment">// 如果要迭代的下一个元素的索引值不小于数组的长度，则抛出 NoSuchElementException</span><br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        <span class="hljs-comment">// 复制当前 list 的内部实现数组 elementData</span><br>        Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>        <span class="hljs-comment">// 如果要迭代的下一个元素的索引不小于 elementData 的长度，则抛出 ConcurrentModificationException。</span><br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        <span class="hljs-comment">// 将 cursor 指向要迭代的下一个(本次 next 方法调用完成之后)元素的索引</span><br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 更新返回的最后一个元素的索引值，同时返回本次要迭代的元素</span><br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果当前元素(next 方法中，int i = cursor；lastRet = i;)索引小于零，抛出 IllegalStateException，此时 list 处于非法状态。</span><br>        <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        <span class="hljs-comment">// 检查 iterator 初始化之后，是否有其他线程对 list 进行了结构性修改。</span><br>        checkForComodification();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 调用 ArrayList 的 remove() 移除迭代器当前指向的元素</span><br>            ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>            <span class="hljs-comment">// 进行 remove 操作后，目标索引后边的元素左移，即目标索引指向新的(尚未迭代过)元素。将迭代器下次要返回的元素指向目标索引的元素</span><br>            cursor = lastRet;<br>            <span class="hljs-comment">// 本次迭代的元素已被删除，所以为 lastRet 赋值 -1</span><br>            lastRet = -<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">// 更新 list 结构性更改次数</span><br>            expectedModCount = modCount;<br>        &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>ArrayList 是容量可以改变的非线程安全集合。内部实现使用数组进行存储，集合扩容时会创建更大的数组空间，把原有数据复制到新数组中。ArrayList 支持对元素的快速随机访问，但是插入与删除时速度通常很慢，因为这个过程很有可能需要移动其他元素。</p>
<p>– 码出高效 Java 开发手册 P155</p>
</blockquote>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>源码</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>关于获取微信第三方平台的 component_verify_ticket 和 component_access_token</title>
    <url>/2018/05/31/about-wechat-authorize3rd-component_verify_ticket&amp;component_access_token/</url>
    <content><![CDATA[<p>独立的小程序已经满足不了我司的需求了，继而准备做微信第三方平台，，今天主要想总结下获取微信授权第三方平台流程中遇到的一些问题，，主要是Java代码(用php开发的朋友可以 Command + W 了..)。</p>
<h4 id="推送-component-verify-ticket-协议"><a href="#推送-component-verify-ticket-协议" class="headerlink" title="推送 component_verify_ticket 协议"></a>推送 component_verify_ticket 协议</h4><p>这一部分，官方文档真心惜墨。。对首次进行开发第三方授权开发的程序员来说真心不友好，在此提出批评(白天已经骂过无数次娘了🙂)！</p>
<h5 id="关于-POST-数据示例"><a href="#关于-POST-数据示例" class="headerlink" title="关于 POST 数据示例"></a>关于 POST 数据示例</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">xml</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">AppId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">AppId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">CreateTime</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">CreateTime</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">InfoType</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">InfoType</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ComponentVerifyTicket</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ComponentVerifyTicket</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xml</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>👆上边的 XML 其实是解密之后的格式。。推送过来时候我们获取到的数据是经过加密的，，像这样👇<span id="encodedData"></span></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">xml</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">AppId</span>&gt;</span>&lt;![CDATA[wx5a062835463d1c61]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">AppId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Encrypt</span>&gt;</span>&lt;![CDATA[3KAGFTaD32rFYsXMmjK/6Hk7nfJzrgIqQs4tqlFA5ORsuMhFvMM9P0cUKEoW9v+2oJztVFRI/OV09szzN7QqqxgapTGLYcyKnbViqs+uSnVkwc5YBM4YkAKGU2Yyp89/6tXU0FloSfUvM8bHZteed44Wo3B3diuhA3JIOK/viBfdfgODTZCe/q/JFt7yYc2Cr3ojtmR1n2M+PdQTfs3bf7tLlR4yURD5kXYrJkZPK7giNzE+uEgn52SUAAhLnAc68hWm0rnPhvPgVARSqL3sHK5xtxihoXcX0h15j8Al3KbZ3IqIdM/SIJrB0mnDx8hOnoI8UaBmChVWS8iz/Ygp/lr8mT37WK0bVeFKm2PkNBG91/icsxOacEJCuXdj/yD+rthlB2OQbmbdFPXw/8QPCNjHdj2RmEL78flwrRQeoNOHYvmMBtoU9jm0WAix6db8siyCA2CNFsC/QxD84p0N/Q==]]&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">Encrypt</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xml</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那么加密后的数据是怎样获取到的呢？？最开始的时候百思不得其解，要崩溃，都做噩梦了。。其实在后边的<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419318479&token=&lang=zh_CN">消息加解密接入指引</a>提到了一些，，总之呢，我们可以通过<code>request.getParameter(paraName)</code>获取到四个参数，分别是👇</p>
<ul>
<li>时间戳 timestamp</li>
<li>随机数 nonce </li>
<li>加密类型 encrypt_type(值为aes)</li>
<li>消息体签名 msg_signature(用于验证消息体的正确性)</li>
</ul>
<p>这四个参数呢主要用来解密 经过<a href="#encodedData">加密的 xml 数据</a>，即所谓的 postdata。</p>
<p>&#x2F;&#x2F; **说到这儿，，不得不提下官方给出的<a href="https://wximg.gtimg.com/shake_tv/mpwiki/cryptoDemo.zip">加解密示例代码</a>**。<br>其实，这5种语言的示例代码的场景是用来加解密微信公众号与用户互动的消息的，所以xml结构中有<code>ToUserName</code>标签。而实际上在本文的场景中，是不存在<code>ToUserName</code>标签的，取而代之的是<code>AppId</code>标签，，这一点，在官方文档中的<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&id=open1419318479&token=&lang=zh_CN">消息加解密接入指引</a>也有提到，只不过比较隐晦。。👇</p>
<blockquote>
<p>公众号第三方平台可能会接收到两种类型的消息：</p>
</blockquote>
<ol>
<li>用户发送给公众号的消息（由公众号第三方平台代收）。此时，消息XML体中，ToUserName（即接收者）为公众号的原始 ID（可通过《接口说明》中的获取授权方信息接口来获得）。</li>
<li><strong>微信服务器发送给服务自身的事件推送（如取消授权通知，Ticket 推送等）。此时，消息XML体中没有 ToUserName 字段，而是 AppId 字段，即公众号服务的 AppId</strong>。这种系统事件推送通知（现在包括推送 component_verify_ticket 协议和推送取消授权通知），服务开发者收到后也需进行解密，接收到后只需直接返回字符串“success”。</li>
</ol>
<p>(PS: 这个 postdata 在官方给的解密加密示例代码中(Java版)的体现即 <code>replyMsg</code>)</p>
<p>OK, 那么问题来了 postdata 又是怎么获取的嘞？？？文档中好像并没有提到(难道是我没看到？！？) 😤，，无力吐槽，直接甩代码👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取加密后的 postdata</span><br><span class="hljs-type">String</span> <span class="hljs-variable">encodedPostdata</span> <span class="hljs-operator">=</span> HttpKit.readData(getRequest());<br><br><span class="hljs-comment">// readData()方法实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">readData</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>    <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        StringBuilder ret;<br>        br = request.getReader();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> br.readLine();<br>        <span class="hljs-keyword">if</span> (line != <span class="hljs-literal">null</span>) &#123;<br>            ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            ret.append(line);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>            ret.append(<span class="hljs-string">&#x27;\n&#x27;</span>).append(line);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret.toString();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (br != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;br.close();&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;LogKit.error(e.getMessage(), e);&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，，我们就获得了加密后的 postdata 数据了，剩下的就是进行解密了，，解密之后，需要把 xml 格式的数据转为 Map，这样就可以愉快的<code>get(&quot;ComponentVerifyTicket&quot;)</code>了~ 贴下核心代码 👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 部分引入的包</span><br><span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilder;<br><span class="hljs-keyword">import</span> javax.xml.parsers.DocumentBuilderFactory;<br><br><span class="hljs-keyword">import</span> org.w3c.dom.Document;<br><span class="hljs-keyword">import</span> org.w3c.dom.Element;<br><span class="hljs-keyword">import</span> org.w3c.dom.Node;<br><span class="hljs-keyword">import</span> org.w3c.dom.NodeList;<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">WXBizMsgCrypt</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WXBizMsgCrypt</span>(String token, String encodingAesKey, String component_appid);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pc.decryptMsg(msg_signature, timestamp, nonce, encodedPostdata);<br>    Map&lt;String, String&gt; data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>    <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">documentBuilderFactory</span> <span class="hljs-operator">=</span> DocumentBuilderFactory.newInstance();<br>    <span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">documentBuilder</span> <span class="hljs-operator">=</span> documentBuilderFactory.newDocumentBuilder();<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(result.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>    <span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> documentBuilder.parse(stream);<br>    doc.getDocumentElement().normalize();<br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">nodeList</span> <span class="hljs-operator">=</span> doc.getDocumentElement().getChildNodes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; idx &lt; nodeList.getLength(); ++idx) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nodeList.item(idx);<br>        <span class="hljs-keyword">if</span> (node.getNodeType() == Node.ELEMENT_NODE) &#123;<br>            <span class="hljs-type">Element</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> (Element) node;<br>            data.put(element.getNodeName(), element.getTextContent());<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 至此 通过 data.get(&quot;ComponentVerifyTicket&quot;) 就可以获取 component_verify_ticket 了~</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        stream.close();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        <span class="hljs-comment">// do nothing</span><br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="获取第三方平台-component-access-token"><a href="#获取第三方平台-component-access-token" class="headerlink" title="获取第三方平台 component_access_token"></a>获取第三方平台 component_access_token</h4><p>这一步相对来说就没那么复杂了，，只遇到一个问题，就是appid参数缺失，微信返回信息如下👇</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;errcode&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">41002</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;errmsg&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;appid missing hint: [M07502974]&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>这里需要注意的是，，官方文档中是这样写的</p>
<blockquote>
<p>POST数据示例:</p>
<blockquote>
<p>{<br>“component_appid”:”appid_value” ,<br>“component_appsecret”: “appsecret_value”,<br>“component_verify_ticket”: “ticket_value”<br>}</p>
</blockquote>
<p>请求参数说明</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">component_appid</td>
<td align="center">第三方平台appid</td>
</tr>
<tr>
<td align="left">component_appsecret</td>
<td align="center">第三方平台appsecret</td>
</tr>
<tr>
<td align="left">component_verify_ticket</td>
<td align="center">微信后台推送的ticket，此ticket会定时推送，具体请见本页的推送说明</td>
</tr>
</tbody></table>
</blockquote>
<p>所以，，post请求的数据为 json 格式的字符串，f**k。。。代码实现接上文component_verify_ticket部分👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;component_verify_ticket&quot;</span>.equals(data.get(<span class="hljs-string">&quot;InfoType&quot;</span>))) &#123;<br>    <span class="hljs-comment">// 以下涉及到Redis部分，为伪代码，，领会精神即可</span><br>    <span class="hljs-comment">// TODO 把component_verify_ticket保存到 Redis 中</span><br>    redis.set(<span class="hljs-string">&quot;component_verify_ticket&quot;</span>, data.get(<span class="hljs-string">&quot;ComponentVerifyTicket&quot;</span>));<br>    <span class="hljs-comment">// TODO 检查 component_access_token 是否存在(过期)(有效期为两小时，过期前提前申请) 。如果过期，则重新向微信服务器申请。</span><br>    <span class="hljs-keyword">if</span>(!redis.exists(<span class="hljs-string">&quot;component_access_token&quot;</span>)) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.weixin.qq.com/cgi-bin/component/api_component_token&quot;</span>;<br>        Map&lt;String, String&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        params.put(<span class="hljs-string">&quot;component_appid&quot;</span>, component_appid;<br>        params.put(<span class="hljs-string">&quot;component_appsecret&quot;</span>, component_appsecret);<br>        params.put(<span class="hljs-string">&quot;component_verify_ticket&quot;</span>, data.get(<span class="hljs-string">&quot;ComponentVerifyTicket&quot;</span>));<br>        <span class="hljs-comment">// json格式的字符串，mmp</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">para</span> <span class="hljs-operator">=</span> JsonKit.toJson(params);<br>        <span class="hljs-comment">// ApiResult 为 JFinal-weixin 框架工具类</span><br>        <span class="hljs-type">ApiResult</span> <span class="hljs-variable">apiResult</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiResult</span>(HttpUtils.post(url, para));<br>        logger.debug(apiResult.getJson());<br>        <span class="hljs-keyword">if</span> (!apiResult.isSucceed()) &#123;<br>            logger.info(<span class="hljs-string">&quot;微信返回的错误码 &gt;&gt;&quot;</span> + apiResult.getErrorMsg());<br>        &#125;<br>        <span class="hljs-keyword">if</span>(StrKit.notBlank(apiResult.get(<span class="hljs-string">&quot;component_access_token&quot;</span>)+<span class="hljs-string">&quot;&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 提前十分钟失效(默认两个小时(7200s)有效)，申请新的~</span><br>            redis.setex(<span class="hljs-string">&quot;component_access_token&quot;</span>, (Integer.parseInt(apiResult.get(<span class="hljs-string">&quot;expires_in&quot;</span>)+<span class="hljs-string">&quot;&quot;</span>)-<span class="hljs-number">600</span>), apiResult.get(<span class="hljs-string">&quot;component_access_token&quot;</span>)+<span class="hljs-string">&quot;&quot;</span>);<br>            logger.info(<span class="hljs-string">&quot;component_access_token 加入 Redis 成功~&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            logger.debug(<span class="hljs-string">&#x27;wtf?!&#x27;</span>);<br>            <span class="hljs-comment">// renderError(apiResult.getErrorMsg());</span><br>        &#125;<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 未知错误..</span><br>    <span class="hljs-comment">// renderCommonError(9999);</span><br>&#125;<br><span class="hljs-comment">// 至此，以后需要 component_access_token 的时候，直接从 Redis 中取就是啦~ </span><br></code></pre></td></tr></table></figure>

<p>明天修改下小程序模板中登陆部分的代码就好啦，，以上如果有更好的实现方式，欢迎指教~</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 HashSet</title>
    <url>/2019/04/09/about_HashSet/</url>
    <content><![CDATA[<h4 id="HashSet-的-DOC-注释"><a href="#HashSet-的-DOC-注释" class="headerlink" title="HashSet 的 DOC 注释"></a>HashSet 的 DOC 注释</h4><p>-Basic JDK7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This class implements the &lt;tt&gt;Set&lt;/tt&gt; interface, backed by a hash table</span><br><span class="hljs-comment"> * (actually a &lt;tt&gt;HashMap&lt;/tt&gt; instance).  It makes no guarantees as to the</span><br><span class="hljs-comment"> * iteration order of the set; in particular, it does not guarantee that the</span><br><span class="hljs-comment"> * order will remain constant over time.  This class permits the &lt;tt&gt;null&lt;/tt&gt;</span><br><span class="hljs-comment"> * element.</span><br><span class="hljs-comment"> * 该类是由 hash table(实际上是 HashMap 实例) 支持的 Set 接口的实现类。它不能保证 set 的迭代顺序；特别是，它不保证 set 内元素的顺序随着时间的变化不会改变。该类允许(添加) null 元素。</span><br><span class="hljs-comment"> * &lt;p&gt;This class offers constant time performance for the basic operations</span><br><span class="hljs-comment"> * (&lt;tt&gt;add&lt;/tt&gt;, &lt;tt&gt;remove&lt;/tt&gt;, &lt;tt&gt;contains&lt;/tt&gt; and &lt;tt&gt;size&lt;/tt&gt;),</span><br><span class="hljs-comment"> * assuming the hash function disperses the elements properly among the</span><br><span class="hljs-comment"> * buckets.  Iterating over this set requires time proportional to the sum of</span><br><span class="hljs-comment"> * the &lt;tt&gt;HashSet&lt;/tt&gt; instance&#x27;s size (the number of elements) plus the</span><br><span class="hljs-comment"> * &quot;capacity&quot; of the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of</span><br><span class="hljs-comment"> * buckets).  Thus, it&#x27;s very important not to set the initial capacity too</span><br><span class="hljs-comment"> * high (or the load factor too low) if iteration performance is important.</span><br><span class="hljs-comment"> * 该类的基本操作(add，remove，contains 和 size)提供O(1)的级别的性能表现，假设 hash 方法将元素均匀的分布在桶中。遍历整个 set 所需的时间与 HashSet 实例的 size(元素数量) * (底层 HashMap 实例的 capacity(桶的数量)) 成正比。</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span><br><span class="hljs-comment"> * If multiple threads access a hash set concurrently, and at least one of</span><br><span class="hljs-comment"> * the threads modifies the set, it &lt;i&gt;must&lt;/i&gt; be synchronized externally.</span><br><span class="hljs-comment"> * This is typically accomplished by synchronizing on some object that</span><br><span class="hljs-comment"> * naturally encapsulates the set.</span><br><span class="hljs-comment"> * 参见 HashMap</span><br><span class="hljs-comment"> * If no such object exists, the set should be &quot;wrapped&quot; using the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Collections#synchronizedSet Collections.synchronizedSet&#125;</span><br><span class="hljs-comment"> * method.  This is best done at creation time, to prevent accidental</span><br><span class="hljs-comment"> * unsynchronized access to the set:&lt;pre&gt;</span><br><span class="hljs-comment"> *   Set s = Collections.synchronizedSet(new HashSet(...));&lt;/pre&gt;</span><br><span class="hljs-comment"> * 参见 HashMap</span><br><span class="hljs-comment"> * &lt;p&gt;The iterators returned by this class&#x27;s &lt;tt&gt;iterator&lt;/tt&gt; method are</span><br><span class="hljs-comment"> * &lt;i&gt;fail-fast&lt;/i&gt;: if the set is modified at any time after the iterator is</span><br><span class="hljs-comment"> * created, in any way except through the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt;</span><br><span class="hljs-comment"> * method, the Iterator throws a &#123;<span class="hljs-doctag">@link</span> ConcurrentModificationException&#125;.</span><br><span class="hljs-comment"> * Thus, in the face of concurrent modification, the iterator fails quickly</span><br><span class="hljs-comment"> * and cleanly, rather than risking arbitrary, non-deterministic behavior at</span><br><span class="hljs-comment"> * an undetermined time in the future.</span><br><span class="hljs-comment"> * 参见 HashMap</span><br><span class="hljs-comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span><br><span class="hljs-comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span><br><span class="hljs-comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span><br><span class="hljs-comment"> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span><br><span class="hljs-comment"> * Therefore, it would be wrong to write a program that depended on this</span><br><span class="hljs-comment"> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators</span><br><span class="hljs-comment"> * should be used only to detect bugs.&lt;/i&gt;</span><br><span class="hljs-comment"> * 参见 HashMap</span><br><span class="hljs-comment"> * &lt;p&gt;This class is a member of the</span><br><span class="hljs-comment"> * &lt;a href=&quot;&#123;<span class="hljs-doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span><br><span class="hljs-comment"> * Java Collections Framework&lt;/a&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt; the type of elements maintained by this set</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Josh Bloch</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Neal Gafter</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     Collection</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     Set</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     TreeSet</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     HashMap</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   1.2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable<br></code></pre></td></tr></table></figure>

<h4 id="HashSet-的类属性、构造方法及-add-方法"><a href="#HashSet-的类属性、构造方法及-add-方法" class="headerlink" title="HashSet 的类属性、构造方法及 add() 方法"></a>HashSet 的类属性、构造方法及 add() 方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;<br><br><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span><br><span class="hljs-comment">// 由 Map 接口支持的虚拟对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">PRESENT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="hljs-comment"> * default initial capacity (16) and load factor (0.75).</span><br><span class="hljs-comment"> * 构造一个新的空的 set；提供底层支持的 HashMap 实例的 默认初始 capacity 为 16，负载因子为 0.75。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">()</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a new set containing the elements in the specified</span><br><span class="hljs-comment"> * collection.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with default load factor</span><br><span class="hljs-comment"> * (0.75) and an initial capacity sufficient to contain the elements in</span><br><span class="hljs-comment"> * the specified collection.</span><br><span class="hljs-comment"> * 构造一个包含指定 collection 中的元素的新 set 实例。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c the collection whose elements are to be placed into this set</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(Math.max((<span class="hljs-type">int</span>) (c.size()/<span class="hljs-number">.75f</span>) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));<br>    addAll(c);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * 该方法继承自 AbstractCollection(即，HashSet 没有重写 addAll()，直接指向的是 AbstractCollection.addAll()方法) </span><br><span class="hljs-comment"> * &lt;p&gt;This implementation iterates over the specified collection, and adds</span><br><span class="hljs-comment"> * each object returned by the iterator to this collection, in turn.</span><br><span class="hljs-comment"> * 该方法实现遍历整个指定的 collection，并且将 collection 的 iterator 返回的每个 对象按顺序添加到 set 中。</span><br><span class="hljs-comment"> * &lt;p&gt;Note that this implementation will throw an</span><br><span class="hljs-comment"> * &lt;tt&gt;UnsupportedOperationException&lt;/tt&gt; unless &lt;tt&gt;add&lt;/tt&gt; is</span><br><span class="hljs-comment"> * overridden (assuming the specified collection is non-empty).</span><br><span class="hljs-comment"> * 需要注意的是，这个方法实现会抛出一个 UnsupportedOperationException 异常，除非 add() 被重写(假设指定的 collection 是非空的)。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> UnsupportedOperationException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassCastException            &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException          &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException      &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalStateException         &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #add(Object)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">modified</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (E e : c)<br>        <span class="hljs-keyword">if</span> (add(e))<br>            modified = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> modified;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds the specified element to this set if it is not already present.</span><br><span class="hljs-comment"> * More formally, adds the specified element &lt;tt&gt;e&lt;/tt&gt; to this set if</span><br><span class="hljs-comment"> * this set contains no element &lt;tt&gt;e2&lt;/tt&gt; such that</span><br><span class="hljs-comment"> * &lt;tt&gt;(e==null&amp;nbsp;?&amp;nbsp;e2==null&amp;nbsp;:&amp;nbsp;e.equals(e2))&lt;/tt&gt;.</span><br><span class="hljs-comment"> * If this set already contains the element, the call leaves the set</span><br><span class="hljs-comment"> * unchanged and returns &lt;tt&gt;false&lt;/tt&gt;.</span><br><span class="hljs-comment"> * 添加指定元素到 set 中，如果 set 中还没有该元素。严谨来说，添加一个元素 e 到该 set 中，如果 set 中不存在一个满足这样条件的 (e2: e==null ? e2==null : e.equals(e2)).如果 set 中已经存在一个这样的元素，当次调用不会改变 set，并且放回 false。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e element to be added to this set</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set did not already contain the specified</span><br><span class="hljs-comment"> * element</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// map.put() 返回 null，说明添加新值成功；否则说明添加的元素发生哈希碰撞，或者是重复添加相同元素。</span><br>    <span class="hljs-comment">// 另外，需要注意到的是 PRESENT，即影子对象，没有实际意义，纯粹为了填充 value。</span><br>    <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-literal">null</span>;<br>&#125;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="hljs-comment"> * the specified initial capacity and the specified load factor.</span><br><span class="hljs-comment"> * 构建一个新的空的 set；指定构建由底层提供支持的 HashMap 实例时的初始容量，和负载因子。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      loadFactor        the load factor of the hash map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span><br><span class="hljs-comment"> *             than zero, or if the load factor is nonpositive</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has</span><br><span class="hljs-comment"> * the specified initial capacity and default load factor (0.75).</span><br><span class="hljs-comment"> * 构建一个新的空 set；指定构建由底层提供支持的 HashMap 实例时的初始容量，负载因子默认为 0.75.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      initialCapacity   the initial capacity of the hash table</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span><br><span class="hljs-comment"> *             than zero</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashSet</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a new, empty linked hash set.  (This package private</span><br><span class="hljs-comment"> * constructor is only used by LinkedHashSet.) The backing</span><br><span class="hljs-comment"> * HashMap instance is a LinkedHashMap with the specified initial</span><br><span class="hljs-comment"> * capacity and the specified load factor.</span><br><span class="hljs-comment"> * 构建一个新的空 Linked Hash set。(这个包级作用域私有的构造器只能被 LinkedHashSet 使用)。底层提供支持的 HashMap 实例是一个 由指定初始容量和指定负载因子的 LinkedHashMap。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      loadFactor        the load factor of the hash map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>      dummy             ignored (distinguishes this</span><br><span class="hljs-comment"> *             constructor from other int, float constructor.)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span><br><span class="hljs-comment"> *             than zero, or if the load factor is nonpositive</span><br><span class="hljs-comment"> */</span><br>HashSet(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor, <span class="hljs-type">boolean</span> dummy) &#123;<br>    map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the specified element from this set if it is present.</span><br><span class="hljs-comment"> * More formally, removes an element &lt;tt&gt;e&lt;/tt&gt; such that</span><br><span class="hljs-comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;,</span><br><span class="hljs-comment"> * if this set contains such an element.  Returns &lt;tt&gt;true&lt;/tt&gt; if</span><br><span class="hljs-comment"> * this set contained the element (or equivalently, if this set</span><br><span class="hljs-comment"> * changed as a result of the call).  (This set will not contain the</span><br><span class="hljs-comment"> * element once the call returns.)</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> o object to be removed from this set, if present</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the set contained the specified element</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// 见 HashMap.remove()</span><br>    <span class="hljs-keyword">return</span> map.remove(o)==PRESENT;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="iterator"><a href="#iterator" class="headerlink" title="iterator()"></a>iterator()</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns an iterator over the elements in this set.  The elements</span><br><span class="hljs-comment"> * are returned in no particular order.</span><br><span class="hljs-comment"> * 返回 set 中元素的 iterator。(迭代器)返回的元素是无序的。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> an Iterator over the elements in this set</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> ConcurrentModificationException</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> map.keySet().iterator();<br>&#125;<br><span class="hljs-comment">// 最终指向 HashMap 中的 KeyIterator</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span>&lt;K&gt; &#123;<br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextEntry().getKey();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// nextEntry 位于 HashIterator；</span><br><span class="hljs-comment">// getKey() 是 Entry&lt;K,V&gt; 类中 key getter 方法。</span><br><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">nextEntry</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    Entry&lt;K,V&gt; e = next;<br>    <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br><br>    <span class="hljs-keyword">if</span> ((next = e.next) == <span class="hljs-literal">null</span>) &#123;<br>        Entry[] t = table;<br>        <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>)<br>            ;<br>    &#125;<br>    current = e;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以下方法都是对 HashMap 的方法的封装</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the number of elements in this set (its cardinality).</span><br><span class="hljs-comment"> * 返回 set 中元素的个数(它的基数???)。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the number of elements in this set (its cardinality)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// map.size 为 map 中键值对的数量</span><br>    <span class="hljs-keyword">return</span> map.size();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set contains no elements</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// return map.size==0</span><br>    <span class="hljs-keyword">return</span> map.isEmpty();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element.</span><br><span class="hljs-comment"> * More formally, returns &lt;tt&gt;true&lt;/tt&gt; if and only if this set</span><br><span class="hljs-comment"> * contains an element &lt;tt&gt;e&lt;/tt&gt; such that</span><br><span class="hljs-comment"> * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;e==null&amp;nbsp;:&amp;nbsp;o.equals(e))&lt;/tt&gt;.</span><br><span class="hljs-comment"> * 如果 set 中包含指定元素，则返回 true。严谨来说：当且仅当 (o==null ? e==null : o.equals(e))时，返回 true.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> o element whose presence in this set is to be tested</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this set contains the specified element</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-comment">// return map.getEntry(key) != null;</span><br>    <span class="hljs-keyword">return</span> map.containsKey(o);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>数据结构</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 HashMap</title>
    <url>/2019/03/23/about_HashMap/</url>
    <content><![CDATA[<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>关于 HashMap, 有一件事儿一直很困惑，，在『Redis 核心历险』中是这样被提到的:</p>
<blockquote>
<p>Redis 的字典相当于 Java 语言中的 HashMap，它是无序字典，内部存储了很多键值对。实现结构上<strong>与 Java 的 HashMap 也是一样的，都是”数组 + 链表”二维结构。第一维的 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来</strong>。</p>
</blockquote>
<p>嗯，第一句没啥问题，，然而”数组 + 链表”什么鬼？还有 hash 碰撞。。作者并没有详细解释这儿，应该默认是每个 Java 开发者都知道的知识点了。然而我却在这儿卡壳了，心慌慌。。趁着周末赶紧补补课。事实证明，这波补课是很有效果的，在这本书后边的内容中，hash 还将会一直出现。</p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p>在 <a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">Wiki</a> 中的定义为:</p>
<blockquote>
<p>散列函数（英语：Hash function）又称散列算法、哈希函数，<strong>是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来</strong>。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。<strong>在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到</strong>。</p>
</blockquote>
<p>用我自己的话来说就是，，为数据创建指纹摘要，通过该摘要就可以找到原始数据。我觉得更多的场景是为相对大的数据创建摘要。假如有个 hash()，可以为任意数据生成一个32位的摘要。那么我们在互联网下载文件的时候，有的网站会在下来链接处给出该文件的 hash 值，等用户下载完成之后，通过 hash() 对该文件提取摘要，将两个 hash 值，进行对比。如果结果一样，说明文件在下载过程中没有被篡改。</p>
<p>那倘若我们对数字 1 进行 hash()，那应该也会得到一个长度为 32 位的摘要，但这时候还能叫『摘要』么？我感觉是不太合适的。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>-Basic JDK7</p>
<p>OK，back to the point..关于 Hash 我们需要知道👇</p>
<blockquote>
<p>所有散列函数都有如下一个基本特性：<strong>如果两个散列值是不相同的（根据同一函数），那么这两个散列值的原始输入也是不相同的</strong>。这个特性是散列函数具有确定性的结果，具有这种性质的散列函数称为单向散列函数。但另一方面，散列函数的输入和输出不是唯一对应关系的，<strong>如果两个散列值相同，两个输入值很可能是相同的，但也可能不同</strong>，这种情况称为“<strong>散列碰撞</strong>（collision）”。</p>
</blockquote>
<p>按我之前不成熟的想法，，HashMap 中为什么要放链表？直接放数据对象不就够了么。。原因就是当我们通过 get(key) 方法从 HashMap 中获取对象的时候，理论上这个 key 对应的 hash 值和某个 whateverKey 对应的 hash 值是一样的(即，散列碰撞)，，因为『如果两个散列值相同，两个输入值很可能是相同的，但也可能不同(即，key 和 whateverKey)』。此时我们可以通过 key 和 whateverKey 都可以获取到对应的数据对象。如此，为了解决散列碰撞带来的问题，我们需要在 HashMap 中将两个‘key’都指向同一个数据对象，而在 HashMap 中的链表就是用来维护这些‘key’的。下面，我们试着读读 HashMap 源码。</p>
<h4 id="HashMap-的-DOC-注释"><a href="#HashMap-的-DOC-注释" class="headerlink" title="HashMap 的 DOC 注释"></a>HashMap 的 DOC 注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface.  This</span><br><span class="hljs-comment"> * implementation provides all of the optional map operations, and permits</span><br><span class="hljs-comment"> * &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The &lt;tt&gt;HashMap&lt;/tt&gt;</span><br><span class="hljs-comment"> * class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;, except that it is</span><br><span class="hljs-comment"> * unsynchronized and permits nulls.)  This class makes no guarantees as to</span><br><span class="hljs-comment"> * the order of the map; in particular, it does not guarantee that the order</span><br><span class="hljs-comment"> * will remain constant over time.</span><br><span class="hljs-comment"> * 👆散列表也基于对 Map 接口的实现。HashMap 也是对是 Map 接口的实现，提供了所有对 Map 的可选操作(的方法)，并且允许 null 值和 null 键。HashMap 大致相当与 HashTable 相同，除了 HashMap 是非同步的，且接受 null。该类不保证数据对象在内部的顺序，同时也不保证内部的顺序是一成不变的。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * &lt;p&gt;This implementation provides constant-time performance for the basic</span><br><span class="hljs-comment"> * operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming the hash function</span><br><span class="hljs-comment"> * disperses the elements properly among the buckets.  Iteration over</span><br><span class="hljs-comment"> * collection views requires time proportional to the &quot;capacity&quot; of the</span><br><span class="hljs-comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus its size (the number</span><br><span class="hljs-comment"> * of key-value mappings).  Thus, it&#x27;s very important not to set the initial</span><br><span class="hljs-comment"> * capacity too high (or the load factor too low) if iteration performance </span><br><span class="hljs-comment"> * is important.</span><br><span class="hljs-comment"> * 👆HashMap 中 get 和 put 这两项基本操作提供复杂度为常数级别的性能表现，假定 hash 方法把元素均匀的分配到桶中。对整个集合视图进行迭代所需的时间与 HashMap 实例(桶的数量)乘以它的容量(键值对的数量)之积。所以，如果迭代性能很重要的话，不要在初始化 HashMap 的时候设置过高的容量，及太小的负载系数(负载因子)</span><br><span class="hljs-comment"> * * &lt;p&gt;As a general rule, the default load factor (.75) offers a good tradeoff</span><br><span class="hljs-comment"> * between time and space costs.  Higher values decrease the space overhead</span><br><span class="hljs-comment"> * but increase the lookup cost (reflected in most of the operations of the</span><br><span class="hljs-comment"> * &lt;tt&gt;HashMap&lt;/tt&gt; class, including &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The</span><br><span class="hljs-comment"> * expected number of entries in the map and its load factor should be taken</span><br><span class="hljs-comment"> * into account when setting its initial capacity, so as to minimize the</span><br><span class="hljs-comment"> * number of rehash operations.  If the initial capacity is greater</span><br><span class="hljs-comment"> * than the maximum number of entries divided by the load factor, no</span><br><span class="hljs-comment"> * rehash operations will ever occur.</span><br><span class="hljs-comment"> * 👆一般，默认的负载系数（0.75）在时间和空间成本之间提供了很好的平衡。更高的值会减少了空间开销，但同时会增加查找成本（反映在 Hashmap 的大多数操作中，包括 get 和 put）。在设置初始容量时，应考虑到 Map 中预期的条目数量及其负载系数，以尽量减少 rehash 的次数。如果初始容量大于最大条目数除以负载系数的值，则不会发生 rehash 操作。</span><br><span class="hljs-comment"> * &lt;p&gt;If many mappings are to be stored in a &lt;tt&gt;HashMap&lt;/tt&gt; instance,</span><br><span class="hljs-comment"> * creating it with a sufficiently large capacity will allow the mappings to</span><br><span class="hljs-comment"> * be stored more efficiently than letting it perform automatic rehashing as</span><br><span class="hljs-comment"> * needed to grow the table.</span><br><span class="hljs-comment"> * 👆如果要在一个 HashMap 实例中存储多个键值对，那么创建实例时指定足够大的容量将比让它根据需要 rehash 以扩充容量的效率更高。</span><br><span class="hljs-comment"> * &lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span><br><span class="hljs-comment"> * If multiple threads access a hash map concurrently, and at least one of</span><br><span class="hljs-comment"> * the threads modifies the map structurally, it &lt;i&gt;must&lt;/i&gt; be</span><br><span class="hljs-comment"> * synchronized externally.  (A structural modification is any operation</span><br><span class="hljs-comment"> * that adds or deletes one or more mappings; merely changing the value</span><br><span class="hljs-comment"> * associated with a key that an instance already contains is not a</span><br><span class="hljs-comment"> * structural modification.)  This is typically accomplished by</span><br><span class="hljs-comment"> * synchronizing on some object that naturally encapsulates the map.</span><br><span class="hljs-comment"> * 👆需要注意的是，HashMap 是非线程安全的。如果多线程同时请求访问 HashMap，并且有至少一条线程改变了 HashMap 实例的结构，那么必须在 HashMap 外层对它添加 synchronized 修饰。（结构修改是指任何添加或删除一个或多个键值对的操作；仅更改实例已包含的键关联的值不是结构修改。）（这一句不太懂诶。。。）</span><br><span class="hljs-comment"> * If no such object exists, the map should be &quot;wrapped&quot; using the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Collections#synchronizedMap Collections.synchronizedMap&#125;</span><br><span class="hljs-comment"> * method.  This is best done at creation time, to prevent accidental</span><br><span class="hljs-comment"> * unsynchronized access to the map:&lt;pre&gt;</span><br><span class="hljs-comment"> *   Map m = Collections.synchronizedMap(new HashMap(...));&lt;/pre&gt;</span><br><span class="hljs-comment"> * 👆如果这样的对象不存在，则该 HashMap 应该被Collections.synchronizedMap()方法包裹起来。最好在对象初创建的时候就这样做，以免发生不可预知的对 HashMap 的访问。</span><br><span class="hljs-comment"> * &lt;p&gt;The iterators returned by all of this class&#x27;s &quot;collection view methods&quot;</span><br><span class="hljs-comment"> * are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally modified at any time after</span><br><span class="hljs-comment"> * the iterator is created, in any way except through the iterator&#x27;s own</span><br><span class="hljs-comment"> * &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span><br><span class="hljs-comment"> * modification, the iterator fails quickly and cleanly, rather than risking</span><br><span class="hljs-comment"> * arbitrary, non-deterministic behavior at an undetermined time in the</span><br><span class="hljs-comment"> * future.</span><br><span class="hljs-comment"> * 👆HashMap 的迭代器返回的这个类的所有集合视图方法都是‘快速失效’的: 所有在迭代器创建之后对 HashMap 进行结构性修改，除了迭代器自己的 remove()方法外，会抛出 ConcurrentModificationException。在面对并发对 HashMap 的修改时，迭代器会快速彻底的失效，而不会选择在之后冒不确定的、未知的风险。</span><br><span class="hljs-comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span><br><span class="hljs-comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span><br><span class="hljs-comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span><br><span class="hljs-comment"> * throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a best-effort basis.</span><br><span class="hljs-comment"> * Therefore, it would be wrong to write a program that depended on this</span><br><span class="hljs-comment"> * exception for its correctness: &lt;i&gt;the fail-fast behavior of iterators</span><br><span class="hljs-comment"> * should be used only to detect bugs.&lt;/i&gt;</span><br><span class="hljs-comment"> * 👆需要注意的是，迭代器的快速失效并不能被保证(一定发生)，，通常来讲，在非同步并发修改 HashMap 的情况下，无法(对快速失效)做出硬性保证。迭代器快速失效后会尽最大努力抛出 ConcurrentModificationException 异常。因此，不能依靠是否抛出该异常来确定写的程序是否是正确的：迭代器的快速失效行为只能被用来查明bug。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The default initial capacity - MUST be a power of two.</span><br><span class="hljs-comment"> * HashMap 的默认初始容量--必须是 2 的 N 次方</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16 (Also Known As, 即初始值为 16)</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The maximum capacity, used if a higher value is implicitly specified</span><br><span class="hljs-comment"> * by either of the constructors with arguments.</span><br><span class="hljs-comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span><br><span class="hljs-comment"> * 最大容量，在带参构造函数中隐式判断指定的容量是否超出最大容量时使用。</span><br><span class="hljs-comment"> * 必须是 2 的 N 次方，且不大于 2^30</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor used when none specified in constructor.</span><br><span class="hljs-comment"> * 构造器未指定负载系数时，使用该默认值</span><br><span class="hljs-comment"> * (当 HashMap 的 size 大于 HashMap 的 capacity * loadFactor 时，HashMap 扩容，即 capacity *= 2，并 rehash())</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * An empty table instance to share when the table is not inflated.</span><br><span class="hljs-comment"> * 在表还没有扩容之前，共享该空数组实例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Entry&lt;?,?&gt;[] EMPTY_TABLE = &#123;&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The table, resized as necessary. Length MUST Always be a power of two.</span><br><span class="hljs-comment"> * 整个表的容量，如果有必要的话(键值对条数/负载系数 &gt;= table.length)会进行扩容。容量大小必须是 2 的幂次方</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The number of key-value mappings contained in this map.</span><br><span class="hljs-comment"> * map 中键值对的条数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The next size value at which to resize (capacity * load factor).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> * 下一次扩容后的大小(容量*负载系数)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">int</span> threshold;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The load factor for the hash table.</span><br><span class="hljs-comment"> * table 的负载系数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 无参构造方法，使用默认初始容量(16)，默认负载系数(.75)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 带参构造方法，指定初始容量为initialCapacity</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 带参构造方法，指定初始容量和负载系数</span><br><span class="hljs-comment"> * 最终所有构造函数都指向该构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;<br>    <span class="hljs-comment">// 如果指定的初始容量 &lt;0，则抛出不合法参数异常</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>    <span class="hljs-comment">// 如果指定的容量大于最大容量，则使用最大容量为初始容量</span><br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-comment">// 如果指定的负载系数不大于零或不是浮点数，则抛出不合法参数异常</span><br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br><br>    <span class="hljs-built_in">this</span>.loadFactor = loadFactor;<br>    threshold = initialCapacity;<br>    init();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 组建一个与指定 map 相同的 HashMap，使用默认负载系数，初始容量足以盛下该 Map。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;<br>    <span class="hljs-comment">// 如果初始容量大于允许的最大容量，则使用最大容量；否则初始容量为指定 Map 的大小除以负载系数后加一</span><br>    <span class="hljs-built_in">this</span>(Math.max((<span class="hljs-type">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="hljs-number">1</span>,<br>                  DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);<br>    <span class="hljs-comment">// HashMap扩容到指定容量</span><br>    inflateTable(threshold);<br><br>    putAllForCreate(m);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inflates the table.</span><br><span class="hljs-comment"> * 表扩容</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inflateTable</span><span class="hljs-params">(<span class="hljs-type">int</span> toSize)</span> &#123;<br>    <span class="hljs-comment">// Find a power of 2 &gt;= toSize</span><br>    <span class="hljs-comment">// 找到大于 toSize 的最小的2的幂次方的值(因为容量只能为2的幂次方)</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> roundUpToPowerOf2(toSize);<br>    <span class="hljs-comment">// 下次扩容时创建表的初始大小</span><br>    threshold = (<span class="hljs-type">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>    table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[capacity];<br>    initHashSeedAsNeeded(capacity);<br>&#125;<br><span class="hljs-comment">// 寻找大于某个非负数的的最小的2的幂次方的值(eg. roundUpToPowerOf2(5)=8)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">roundUpToPowerOf2</span><span class="hljs-params">(<span class="hljs-type">int</span> number)</span> &#123;<br>    <span class="hljs-comment">// assert number &gt;= 0 : &quot;number must be non-negative&quot;;</span><br>    <span class="hljs-comment">// 断言 number 为非负数</span><br>    <span class="hljs-keyword">return</span> number &gt;= MAXIMUM_CAPACITY<br>            ? MAXIMUM_CAPACITY<br>            : (number &gt; <span class="hljs-number">1</span>) ? Integer.highestOneBit((number - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>) : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 当 number 不小于允许的最大容量时，直接返回最大值；</span><br>    <span class="hljs-comment">// 当 number = 1 时，直接返回 1。</span><br>    <span class="hljs-comment">// 否则返回 Integer.highestOneBit((number - 1) &lt;&lt; 1)：</span><br>    <span class="hljs-comment">// (number - 1) &lt;&lt; 1) = (number - 1)*2</span><br>    <span class="hljs-comment">// Integer.highestOneBit(i): 取 i 这个数的二进制形式最左边的最高一位且高位后面全部补零，最后返回int型的结果。</span><br><br>    <span class="hljs-comment">// 假设 number 值为 5；那么十进制 5 减去 1 之后得 4，4 的二进制带符号左移一位，得十进制 8；8 的二进制为：1000；经过 Integer.highestOneBit 处理后值还是 8。</span><br>    <span class="hljs-comment">// 假设 number 值为 6，那么十进制 6 减去 1 之后得 5，5 的二进制带符号左移一位，得十进制 10；10 的二进制为 1010；取最高位 1，其余 3 位补零，得 1000，即十进制 8。</span><br>&#125;<br><br><span class="hljs-comment">// 再看看 HashMap 的静态内部类 Entry&lt;K,V&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> K key;<br>    V value;<br>    <span class="hljs-comment">// 只有 next，没有 prev，即单向链</span><br>    Entry&lt;K,V&gt; next;<br>    <span class="hljs-type">int</span> hash;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates new entry.</span><br><span class="hljs-comment">     */</span><br>    Entry(<span class="hljs-type">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;<br>        value = v;<br>        next = n;<br>        key = k;<br>        hash = h;<br>    &#125;<br><br>    <span class="hljs-comment">// key 的 getter 方法..略</span><br>    <span class="hljs-comment">// value 的 getter 方法..略</span><br>    <span class="hljs-comment">// value 的 setter 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V newValue)</span> &#123;<br>        <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> value;<br>        value = newValue;<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><br>    <span class="hljs-comment">// Entry 的 key 和 value 与 o 的 key 和 value 都相等，则return true，否则return false</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Map.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (Map.Entry)o;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">k1</span> <span class="hljs-operator">=</span> getKey();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">k2</span> <span class="hljs-operator">=</span> e.getKey();<br>        <span class="hljs-keyword">if</span> (k1 == k2 || (k1 != <span class="hljs-literal">null</span> &amp;&amp; k1.equals(k2))) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">v1</span> <span class="hljs-operator">=</span> getValue();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">v2</span> <span class="hljs-operator">=</span> e.getValue();<br>            <span class="hljs-keyword">if</span> (v1 == v2 || (v1 != <span class="hljs-literal">null</span> &amp;&amp; v1.equals(v2)))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getKey() + <span class="hljs-string">&quot;=&quot;</span> + getValue();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is invoked whenever the value in an entry is</span><br><span class="hljs-comment">     * overwritten by an invocation of put(k,v) for a key k that&#x27;s already</span><br><span class="hljs-comment">     * in the HashMap.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordAccess</span><span class="hljs-params">(HashMap&lt;K,V&gt; m)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This method is invoked whenever the entry is</span><br><span class="hljs-comment">     * removed from the table.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordRemoval</span><span class="hljs-params">(HashMap&lt;K,V&gt; m)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>    <span class="hljs-comment">// 如果这是空表，则首先为表进行扩容，threshold 初始值为 DEFAULT_INITIAL_CAPACITY，即 16</span><br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>        inflateTable(threshold);<br>    &#125;<br>    <span class="hljs-comment">// 如果 key 为 null</span><br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 该方法进行的操作与下面对非 null key值的操作逻辑基本一致，只不过是在 for 循环中的 判断条件改为了 e.key == null</span><br>        <span class="hljs-keyword">return</span> putForNullKey(value);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> hash(key);<br>    <span class="hljs-comment">// 通过 Hash 值找到在数组中的索引值</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>    <span class="hljs-comment">// 遍历索引指向的单向链表，查看 key 在当前 Map 中是否存在</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        Object k;<br>        <span class="hljs-comment">// 如果 当前 Entry 对象 e 的 hash 值与 key 的 hash 值相等，且 e.key 与 key 相等，则覆盖原有 e.value</span><br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>            <span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果要插入的 key 在 map 中不存在，，</span><br>    <span class="hljs-comment">// 结构修改次数 ++</span><br>    modCount++;<br>    <span class="hljs-comment">// 在 HashMap 的 Entry 数组中添加新的 Entry 对象</span><br>    addEntry(hash, key, value, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns index for hash code h.</span><br><span class="hljs-comment"> * 找到 hash 值在 table 中的索引值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexFor</span><span class="hljs-params">(<span class="hljs-type">int</span> h, <span class="hljs-type">int</span> length)</span> &#123;<br>    <span class="hljs-comment">// assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br>    <span class="hljs-comment">//Integer.bitCount(length) 用于计算十进制 length 值的二进制值中 &#x27;1&#x27; 的个数；Integer.bitCount(length) == 1，即断言 length 值(HashMap 中Entry&lt;?,?&gt;[]的length，即 HashMap capacity)为 2 的幂次方。</span><br>    <br>    <span class="hljs-comment">// 刚开始是没有看明白这行代码的，求助搜索引擎之后，才有些眉目。</span><br>    <span class="hljs-comment">// 首先，这是按位与操作，，因为 length 值为 2 的幂次方，所以 length - 1后，其二进制的值除高位外全为1(eg. 假设length 值为 8(二进制表现为 1000)， 减 1 得 7；7 的二进制为 0111)</span><br>    <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds a new entry with the specified key, value and hash code to</span><br><span class="hljs-comment"> * the specified bucket.  It is the responsibility of this</span><br><span class="hljs-comment"> * method to resize the table if appropriate.</span><br><span class="hljs-comment"> * 通过指定的 key、value、hash code 向指定的 bucket 添加一个新的 entry 对象。在适当的时候扩容 table 也是该方法的主要责任。</span><br><span class="hljs-comment"> * Subclass overrides this to alter the behavior of put method.</span><br><span class="hljs-comment"> * 子类重写该方法可以修改 put() 方法的行为。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">addEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>    <span class="hljs-comment">// 如果当前 HashMap 的 size 大于等于扩容临界值，且当前 Entry 不为 null 的时候</span><br>    <span class="hljs-comment">// 当 table 的 capacity 等于 Integer.MAX_VALUE时，int 类型的 size 最多与 threshold(此时 threshold = Integer.MAX_VALUE)相等，而且 null != table[bucketIndex] 肯定为 true。所以，当 table 达到最大容量后，再调用 put() 会一直覆盖原有的值。</span><br>    <span class="hljs-keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="hljs-literal">null</span> != table[bucketIndex])) &#123;<br>        <span class="hljs-comment">// 2 倍扩容</span><br>        resize(<span class="hljs-number">2</span> * table.length);<br>        <span class="hljs-comment">// key 为 null，则 hash 值为 0；否则 通过 hash() 方法计算 hash 值</span><br>        hash = (<span class="hljs-literal">null</span> != key) ? hash(key) : <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 计算扩容之后 entry 将要被放在的 bucket 索引</span><br>        bucketIndex = indexFor(hash, table.length);<br>    &#125;<br>    <span class="hljs-comment">// 实际添加 entry 对象的方法</span><br>    createEntry(hash, key, value, bucketIndex);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rehashes the contents of this map into a new array with a</span><br><span class="hljs-comment"> * larger capacity.  This method is called automatically when the</span><br><span class="hljs-comment"> * number of keys in this map reaches its threshold.</span><br><span class="hljs-comment"> * Rehash 当前 map 对象到一个新的更大的数组中去；该方法在 map.size() 达到临界值时自动调用</span><br><span class="hljs-comment"> * If current capacity is MAXIMUM_CAPACITY, this method does not</span><br><span class="hljs-comment"> * resize the map, but sets threshold to Integer.MAX_VALUE.</span><br><span class="hljs-comment"> * This has the effect of preventing future calls.</span><br><span class="hljs-comment"> * 如果当前容量达到允许的最大容量时，该方法不会再进行扩容操作，而是直接将临界值设置为 Integer.MAX_VALUE。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> newCapacity the new capacity, MUST be a power of two;</span><br><span class="hljs-comment"> *        must be greater than current capacity unless current</span><br><span class="hljs-comment"> *        capacity is MAXIMUM_CAPACITY (in which case value</span><br><span class="hljs-comment"> *        is irrelevant).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;<br>    Entry[] oldTable = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;<br>    <span class="hljs-comment">// MAXIMUM_CAPACITY = 2^30，即 oldCapacity 最大值为 2^30</span><br>    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;<br>        <span class="hljs-comment">// Integer.MAX_VALUE = 2^31 - 1，之后不可能再进行扩容操作了</span><br>        threshold = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Entry[] newTable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>[newCapacity];<br>    transfer(newTable, initHashSeedAsNeeded(newCapacity));<br>    table = newTable;<br>    threshold = (<span class="hljs-type">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Like addEntry except that this version is used when creating entries</span><br><span class="hljs-comment"> * as part of Map construction or &quot;pseudo-construction&quot; (cloning,</span><br><span class="hljs-comment"> * deserialization).  This version needn&#x27;t worry about resizing the table.</span><br><span class="hljs-comment"> * 本方法与 addEntry() 类似，只不过是用于&#x27;伪构造方法时&#x27;(克隆、反序列化)，而且该方法不用担心扩容的问题~</span><br><span class="hljs-comment"> * Subclass overrides this to alter the behavior of HashMap(Map),</span><br><span class="hljs-comment"> * clone, and readObject.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">createEntry</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">int</span> bucketIndex)</span> &#123;<br>    <span class="hljs-comment">// 在未发生散列碰撞时，e 为 null；否则 e 为 entry 实例</span><br>    Entry&lt;K,V&gt; e = table[bucketIndex];<br>    <span class="hljs-comment">// 构建新的Entry对象，并其属性 next 指向 e，，即在发生散列碰撞的情况下，每次添加 entry 实例时，都是 insert(添加到单向链开始位置)，而非 append。</span><br>    table[bucketIndex] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>&lt;&gt;(hash, key, value, e);<br>    size++;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transfers all entries from current table to newTable.</span><br><span class="hljs-comment"> * 将现在的 table 转移到新的 table中</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry[] newTable, <span class="hljs-type">boolean</span> rehash)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> newTable.length;<br>    <span class="hljs-comment">// 遍历原 Entry 数组中所有对象</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;<br>        <span class="hljs-comment">// 遍历每个槽位的 entry 单向链</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123;<br>            <span class="hljs-comment">// ① 👉 记录下 e.next 先</span><br>            Entry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-keyword">if</span> (rehash) &#123;<br>                e.hash = <span class="hljs-literal">null</span> == e.key ? <span class="hljs-number">0</span> : hash(e.key);<br>            &#125;<br>            <span class="hljs-comment">// 计算 e.hash 在新 entry 数组中 bucket 索引</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, newCapacity);<br>            <span class="hljs-comment">// ② 👉 将原槽位的 entry 单向链添加到当前 e 的 next 属性中。</span><br>            e.next = newTable[i];<br>            <span class="hljs-comment">// ③ 👉 将 新数组的指定索引的值 指向 拼接过的新的 entry 单向链。</span><br>            newTable[i] = e;<br>            <span class="hljs-comment">// ④ 👉 将之前记录下来的 e.next 值重新赋给 e，开始下一轮循环(类似 for 循环中的 i++)。</span><br>            e = next;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 👆 transfer() 方法中 将while 循环转成 for 循环，①、④ 处可能会更好理解一点； ②、③ 位置不太好理解，我也是反复咀嚼了好多遍才大概明白一点。</span><br><span class="hljs-comment">// eg. 我们假设在索引为 i 的槽位处有个 entry 对象 e0，它链接的 entry 对象结构大概为：e0 -&gt; e1 -&gt; e2 -&gt; e3；现在有个 entry 对象 e，e 的 hash 值在新数组中计算得到的索引值同样为 i(即，散列碰撞)；此时需将 e 添加到 e0 的单向链中，③、④ 操作执行过后，该槽位的单向链结构变为：e -&gt; e0 -&gt; e1 -&gt; e2 -&gt; e3。</span><br></code></pre></td></tr></table></figure>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="@加张图片会不会更容易理解些~"></p>
<h5 id="get-方法👇"><a href="#get-方法👇" class="headerlink" title="get() 方法👇"></a>get() 方法👇</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(Object key)</span> &#123;<br> <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> getForNullKey();<br>    Entry&lt;K,V&gt; entry = getEntry(key);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span> == entry ? <span class="hljs-literal">null</span> : entry.getValue();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Offloaded version of get() to look up null keys.  Null keys map</span><br><span class="hljs-comment"> * to index 0.  This null case is split out into separate methods</span><br><span class="hljs-comment"> * for the sake of performance in the two most commonly used</span><br><span class="hljs-comment"> * operations (get and put), but incorporated with conditionals in</span><br><span class="hljs-comment"> * others.</span><br><span class="hljs-comment"> * key 值为 null 的指向 map 中 Entry 数组 index 为 0 的 entry 对象。为了更高的性能表现，在 get 和 put 请求中，key 为 null 的情况被分支出单独的方法来处理，但在其他方法中并没有这样去做。</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">private</span> V <span class="hljs-title function_">getForNullKey</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="hljs-number">0</span>]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>        <span class="hljs-keyword">if</span> (e.key == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> e.value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">getEntry</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : hash(key);<br>    <span class="hljs-comment">// 遍历指定 index 位置的的单项链</span><br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];<br>         e != <span class="hljs-literal">null</span>;<br>         e = e.next) &#123;<br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove() 方法"></a>remove() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">remove</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-comment">// 直接看关键方法</span><br>    Entry&lt;K,V&gt; e = removeEntryForKey(key);<br>    <span class="hljs-keyword">return</span> (e == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value);<br>&#125;<br><br><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">removeEntryForKey</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">hash</span> <span class="hljs-operator">=</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : hash(key);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(hash, table.length);<br>    <span class="hljs-comment">// ①看到这儿时候我是有些懵哔的..</span><br>    Entry&lt;K,V&gt; prev = table[i];<br>    Entry&lt;K,V&gt; e = prev;<br><br>    <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;<br>        Entry&lt;K,V&gt; next = e.next;<br>        Object k;<br>        <span class="hljs-comment">// ③ 关键在这儿</span><br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k)))) &#123;<br>            modCount++;<br>            size--;<br>            <span class="hljs-comment">// ②直到看到了这儿，我意识到我刚才懵逼早了...</span><br>            <span class="hljs-comment">// 由 ① 很容易得出结论啊，妥妥相等</span><br>            <span class="hljs-keyword">if</span> (prev == e)<br>                table[i] = next;<br>            <span class="hljs-keyword">else</span><br>                prev.next = next;<br>            e.recordRemoval(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span> e;<br>        &#125;<br>        ④<br>        prev = e;<br>        e = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br><span class="hljs-comment">// 👆在上面的代码中，如果只看①②，会蒙圈的，，关键在③的分支判断。</span><br><span class="hljs-comment">// 在发生散列碰撞(由不同的 key，生成了相同的 hash 值)情况下，e.hash == hash 是成立的，但 (k = e.key) == key 或 key.equals(k)就不成立了。</span><br><span class="hljs-comment">// eg. 如果要删除的单向链节点在链的开头，则直接走 (prev == e) 分支，将 table[i] 指向 其 next 属性的节点；如果要删除的单向链节点位于第二，则在直接将第一个节点的 next 属性指向第 3 个节点即可。</span><br></code></pre></td></tr></table></figure>
<h5 id="entrySet-方法"><a href="#entrySet-方法" class="headerlink" title="entrySet() 方法"></a>entrySet() 方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a &#123;<span class="hljs-doctag">@link</span> Set&#125; view of the mappings contained in this map.</span><br><span class="hljs-comment"> * The set is backed by the map, so changes to the map are</span><br><span class="hljs-comment"> * reflected in the set, and vice-versa.  If the map is modified</span><br><span class="hljs-comment"> * while an iteration over the set is in progress (except through</span><br><span class="hljs-comment"> * the iterator&#x27;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span><br><span class="hljs-comment"> * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span><br><span class="hljs-comment"> * iterator) the results of the iteration are undefined.  The set</span><br><span class="hljs-comment"> * supports element removal, which removes the corresponding</span><br><span class="hljs-comment"> * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span><br><span class="hljs-comment"> * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span><br><span class="hljs-comment"> * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span><br><span class="hljs-comment"> * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span><br><span class="hljs-comment"> * 返回当前 map 键值对映射的 set 快照(??)。该集合由 map 支持，所以对 map 的修改会反映到 set中，反之亦然。</span><br><span class="hljs-comment"> * 如果 map 在 set 迭代的过程中被修改(除了迭代器本身的remove()和迭代器返回的 map entry的 setValue()操作)话，其结果是未知(??)的。</span><br><span class="hljs-comment"> * set 支持移除元素， Set.remove(),removeAll(), retainAll() 和 clear() 会直接影响到相关的 map。set 不知道 add()和 addAll() 操作。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a set view of the mappings contained in this map</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;<br>    <span class="hljs-keyword">return</span> entrySet0();<br>&#125;<br>(实测，在 <span class="hljs-keyword">for</span>(Map.Entry&lt;String,String&gt; m:map.entrySet()) 循环中，通过 map.put() 方法放入新的值，会抛出 ConcurrentModificationException：👇<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.ConcurrentModificationException<br>    at java.util.HashMap$HashIterator.nextEntry(HashMap.java:<span class="hljs-number">922</span>)<br>    at java.util.HashMap$EntryIterator.next(HashMap.java:<span class="hljs-number">962</span>)<br>    at java.util.HashMap$EntryIterator.next(HashMap.java:<span class="hljs-number">960</span>)<br>    at Test.main(Test.java:<span class="hljs-number">12</span>)<br>如果放入 map 中已存在的 key，不会抛出 ConcurrentModificationException。)<br><br> <span class="hljs-keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;<br>    Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;<br>    <span class="hljs-keyword">return</span> es != <span class="hljs-literal">null</span> ? es : (entrySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntrySet</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到这里之后是有点儿懵的，，因为 entrySet0() 方法中第一行代码，<code>entrySet</code>在 HashMap 中是这样<span id="entrySetAnnounce">声明</span>的：👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>
<p>之后在其他地方没有明确对其进行赋值的代码，然鹅我们在 <code>Test</code> 类进行 <code>for(Map.Entry&lt;String,String&gt; m: map.entrySet())</code> 循环时，<code>entrySet</code>明明是有值的。那么 <code>map.entrySet()</code> 到底是在什么时候进行赋值的呢？！这个问题困扰了我很久，在 HashMap 显式继承的 AbstractMap 类和实现的 Map&lt;K,V&gt; 接口中，也没有找到答案。出门遛了一圈，突然想到了 <code>Test</code> 类被编译之后的 class 文件！！然后用 JD-JUI 反编译之后，终于有些发现了：👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// class 文件反编译之后的 forEach 循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">Iterator</span> <span class="hljs-variable">i$</span> <span class="hljs-operator">=</span> map.entrySet().iterator(); i$.hasNext(); localEntry = (Map.Entry)i$.next())<br></code></pre></td></tr></table></figure>
<p>👆我们可以看到，虽说用的是 forEach 循环，但在编译之后还是通过 Iterator 迭代器进行遍历的。首先初始条件 <code>Iterator i$ = map.entrySet().iterator()</code>，我们可以看到  <code>map.entrySet()</code> 返回的是一个 <code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code>，所以其 <code>iterator()</code> 是 <code>Set</code> 接口实现类的 <code>iterator()</code> 方法。我们继续看 <code>entrySet0()</code> 方法的第二行代码，在 <code>entrySet</code> 为空的情况下，会初始化一个新的 <code>Set&lt;Map.Entry&lt;K,V&gt;&gt;</code> 对象，即 <code>new EntrySet()</code>，我们看看 <code>EntrySet</code> 类：👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntrySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;<br>        <span class="hljs-keyword">return</span> newEntryIterator();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;<br>        Entry&lt;K,V&gt; candidate = getEntry(e.getKey());<br>        <span class="hljs-keyword">return</span> candidate != <span class="hljs-literal">null</span> &amp;&amp; candidate.equals(e);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> removeMapping(o) != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        HashMap.<span class="hljs-built_in">this</span>.clear();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// EntrySet 类集成了 AbstractSet 类，而 AbstractSet 类又实现了 Set&lt;E&gt; 接口，那么 EntrySet 类中的 iterator() 方法就是我们要找的。我们继续顺着往下看 newEntryIterator ：👇</span><br>Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EntryIterator</span>();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EntryIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HashIterator</span>&lt;Map.Entry&lt;K,V&gt;&gt; &#123;<br>    <span class="hljs-keyword">public</span> Map.Entry&lt;K,V&gt; <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nextEntry();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 形式渐渐明朗，，再看 nextEntry()</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    Entry&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span><br>    <span class="hljs-type">int</span> expectedModCount;   <span class="hljs-comment">// For fast-fail</span><br>    <span class="hljs-type">int</span> index;              <span class="hljs-comment">// current slot</span><br>    Entry&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span><br><br>    HashIterator() &#123;<br>        expectedModCount = modCount;<br>        <span class="hljs-keyword">if</span> (size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry</span><br>            Entry[] t = table;<br>            <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>)<br>                ;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> next != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title function_">nextEntry</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        Entry&lt;K,V&gt; e = next;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br><br>        <span class="hljs-keyword">if</span> ((next = e.next) == <span class="hljs-literal">null</span>) &#123;<br>            Entry[] t = table;<br>            <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-literal">null</span>)<br>                ;<br>        &#125;<br>        current = e;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> current.key;<br>        current = <span class="hljs-literal">null</span>;<br>        HashMap.<span class="hljs-built_in">this</span>.removeEntryForKey(k);<br>        expectedModCount = modCount;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 至此，所有问题解决~ 在 Iterator i$ = map.entrySet().iterator() 中，i$ 为 HashIterator，i$.hasNext() 调用的是 HashIterator.hasNext()，(Map.Entry)i$.next() 调用的是 EntryIterator.next()，而 EntryIterator.next() 最终还是调用了 HashIterator.nextEntry()。</span><br></code></pre></td></tr></table></figure>

<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 2019-04-02.update</p>
<p>上个月末的时候，花了一个晚上更新了下简历，但并没有到处去投，只是对外可见。陆陆续续开始有公司接触，其中还接到一个电话面试，，是某外包公司的。突如其来的电话面试，有点仓促，但好在前端时间也一直在看书恶补。其中有个很基础的问题，，『简单说下 Java 集合框架各容器类之间的关系』。多亏了学习 『Redis 核心历险』时，对 <a href="https://someoneiscoding.com/2019/03/17/about_LinkedList/">LinkedList</a> 多看了一眼，也经受住了超越妹妹的考验。当中面试官特地提到 <code>Map</code> 和 <code>Collection</code> 有没有关系? 可以确定是肯定有关系，但有什么关系呢？没有答上来。。那时还没有整理 HashMap 这篇文章，只有 LinkedList。其实在整理这篇文章时也没找到两者之间的关系，因为 <code>interface Map&lt;K,V&gt;</code> 与 <code>interface Collection&lt;E&gt;</code>并没有直接的继承关系。。这时候需要感谢的是『码出高效 Java 开发手册』了，平时把这本书放在了床头，睡前会翻一翻<del>从此再无失眠</del>，并没有从第一张开始读，而是直接挑了最薄弱的数据结构与集合这一章。</p>
<p>OK，下面来说说 <code>Map</code> 和 <code>Collection</code> 的关系！在书中是这样描述的: 👇</p>
<blockquote>
<p>在数据元素的存储、查找、修改和遍历中，Java 中的 Map 类集合都与 Collection 类集合存在很大的不同。它是与 Collection 类平级的一个接口，在集合框架图上，它有一条微弱的依赖线月 Collection 类产生联系，那是因为<strong>部分方法返回 Collection 视图，比如 values() 方法返回的所有 values 的列表</strong></p>
</blockquote>
<p>我们先看 <code>Map</code> 接口的 <code>values()</code> 方法：👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Map 接口类</span><br>Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p>非常明显，，说到<code>values()</code>方法，肯定会想到 <code>keySet()</code> 和 <code>entrySet()</code> ，毕竟这三个方法在 <code>HashMap</code> 迭代的时候可是肩并肩的~👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Map 接口类</span><br>Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span>;<br>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();<br></code></pre></td></tr></table></figure>
<p>我们再看看，这三个方法在 <code>HashMap</code> 中的实现~ 👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// values 方法</span><br><span class="hljs-keyword">public</span> Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span> &#123;<br>    Collection&lt;V&gt; vs = values;<br>    <span class="hljs-keyword">return</span> (vs != <span class="hljs-literal">null</span> ? vs : (values = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Values</span>()));<br>&#125;<br><span class="hljs-comment">// Values 类，AbstractCollection 类实现类了 Collection 接口</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Values</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;V&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> newValueIterator();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> containsValue(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        HashMap.<span class="hljs-built_in">this</span>.clear();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// keySet 方法</span><br><span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span> &#123;<br>    Set&lt;K&gt; ks = keySet;<br>    <span class="hljs-keyword">return</span> (ks != <span class="hljs-literal">null</span> ? ks : (keySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">KeySet</span>()));<br>&#125;<br><span class="hljs-comment">// KeySet 类，abstract class AbstractSet&lt;E&gt; 继承了 AbstractCollection&lt;E&gt; 实现了 Set&lt;E&gt;，而抽象类 AbstractCollection 和 Set 接口 都继承了 Collection 接口。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSet</span>&lt;K&gt; &#123;<br>    <span class="hljs-keyword">public</span> Iterator&lt;K&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> newKeyIterator();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> containsKey(o);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">return</span> HashMap.<span class="hljs-built_in">this</span>.removeEntryForKey(o) != <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>        HashMap.<span class="hljs-built_in">this</span>.clear();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 至于 entrySet() 方法，我们在分析 HashMap 的 forEach 循环时已经挖过源码了。EntrySet 类与 KeySet 类一样，都继承了 AbstractSet 抽象类。</span><br></code></pre></td></tr></table></figure>



<ol>
<li><a href="https://zhuanlan.zhihu.com/p/30543726">米一–Hash表的前世今生</a></li>
<li><a href="https://blog.csdn.net/j1231230/article/details/78072115">追逐盛夏流年–HashMap中的indexFor方法分析</a></li>
<li><a href="https://blog.csdn.net/strivenoend/article/details/80397825">March@dhyin.top--hashmap的实现原理 数组 entry</a></li>
<li><a href="http://www.cnblogs.com/sanjianghuiliu/p/6524895.html">哈希拉链法</a></li>
<li><a href="https://www.cnblogs.com/Capricorn-HCL/articles/5039123.html">贝壳风铃–Java遍历HashMap并修改(remove)</a></li>
</ol>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>数据结构</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 LinkedList</title>
    <url>/2019/03/17/about_LinkedList/</url>
    <content><![CDATA[<h4 id="LinkedList-的-DOC-注释"><a href="#LinkedList-的-DOC-注释" class="headerlink" title="LinkedList 的 DOC 注释"></a>LinkedList 的 DOC 注释</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Doubly-linked list implementation of the &#123;<span class="hljs-doctag">@code</span> List&#125; and &#123;<span class="hljs-doctag">@code</span> Deque&#125;</span><br><span class="hljs-comment"> * interfaces.  Implements all optional list operations, and permits all</span><br><span class="hljs-comment"> * elements (including &#123;<span class="hljs-doctag">@code</span> null&#125;).</span><br><span class="hljs-comment"> * 该双向链表实现了 List 接口和 Deque 接口。实现了 list 的所有可选操作，并且允许(添加)所有元素(包括 null)。</span><br><span class="hljs-comment"> * &lt;p&gt;All of the operations perform as could be expected for a doubly-linked</span><br><span class="hljs-comment"> * list.  Operations that index into the list will traverse the list from</span><br><span class="hljs-comment"> * the beginning or the end, whichever is closer to the specified index.</span><br><span class="hljs-comment"> * 对于该双向链表，所有操作都是可预期的。如果对 list 的操作涉及到指定索引位置的元素，那么将判断指定的索引离 begin 更近，还是离 end 更近。这样能进行更少次数的迭代，性能更好。</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span><br><span class="hljs-comment"> * If multiple threads access a linked list concurrently, and at least</span><br><span class="hljs-comment"> * one of the threads modifies the list structurally, it &lt;i&gt;must&lt;/i&gt; be</span><br><span class="hljs-comment"> * synchronized externally.  (A structural modification is any operation</span><br><span class="hljs-comment"> * that adds or deletes one or more elements; merely setting the value of</span><br><span class="hljs-comment"> * an element is not a structural modification.)  This is typically</span><br><span class="hljs-comment"> * accomplished by synchronizing on some object that naturally</span><br><span class="hljs-comment"> * encapsulates the list.</span><br><span class="hljs-comment"> * 需要注意的是 LinkedList 类并不是线程安全的。如果多线程同时访问 linked list，而且至少一个线程会修改 list 的结构，那么它的外部必须使用 synchronized 关键字。(结构性修改指的是 插入(add)或者删除(remove)操作，修改一个元素的值并不是结构性修改)。这通常通过同步(synchronized 修饰)一个 封装了 list 的对象来实现。</span><br><span class="hljs-comment"> * If no such object exists, the list should be &quot;wrapped&quot; using the</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Collections#synchronizedList Collections.synchronizedList&#125;</span><br><span class="hljs-comment"> * method.  This is best done at creation time, to prevent accidental</span><br><span class="hljs-comment"> * unsynchronized access to the list:&lt;pre&gt;</span><br><span class="hljs-comment"> *   List list = Collections.synchronizedList(new LinkedList(...));&lt;/pre&gt;</span><br><span class="hljs-comment"> * 如果手头儿没有这样的对象，list 应该被 Collections.synchronizedList() 包裹起来。最好在初始化 LinkedList 对象时候就这样去做，以免不可预知的对 list 的非同步访问。</span><br><span class="hljs-comment"> * &lt;p&gt;The iterators returned by this class&#x27;s &#123;<span class="hljs-doctag">@code</span> iterator&#125; and</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> listIterator&#125; methods are &lt;i&gt;fail-fast&lt;/i&gt;: if the list is</span><br><span class="hljs-comment"> * structurally modified at any time after the iterator is created, in</span><br><span class="hljs-comment"> * any way except through the Iterator&#x27;s own &#123;<span class="hljs-doctag">@code</span> remove&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> add&#125; methods, the iterator will throw a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span><br><span class="hljs-comment"> * modification, the iterator fails quickly and cleanly, rather than</span><br><span class="hljs-comment"> * risking arbitrary, non-deterministic behavior at an undetermined</span><br><span class="hljs-comment"> * time in the future.</span><br><span class="hljs-comment"> * 通过LinkedList 的 iterator() 方法，或者 listIterator(int) 方法返回的 iterator 都是 fail-fast(快速失效)的：如果在创建 iterator 之后，任何对 list 的结构性修改，都会抛出 ConcurrentModificationException，除了 iterator 本身的 remove() 和 add() 方法。因此，在面临并发对 list 的修改时，iterator 会快速而干净的失效，而不是在未来不确定的时间冒着任意的、不确定的风险。</span><br><span class="hljs-comment"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span><br><span class="hljs-comment"> * as it is, generally speaking, impossible to make any hard guarantees in the</span><br><span class="hljs-comment"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span><br><span class="hljs-comment"> * throw &#123;<span class="hljs-doctag">@code</span> ConcurrentModificationException&#125; on a best-effort basis.</span><br><span class="hljs-comment"> * Therefore, it would be wrong to write a program that depended on this</span><br><span class="hljs-comment"> * exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators</span><br><span class="hljs-comment"> * should be used only to detect bugs.&lt;/i&gt;</span><br><span class="hljs-comment"> * 另外，需要注意的是，，iterator 的 fail-fast 行为是不能被保证的，，通常来说，在并发非同步对 list 的修改时，任何硬性的保证都是不可能的。fail-fast 会让 iterator 尽可能抛出 ConcurrentModificationException。因此，在程序中通过依赖抛出 ConcurrentModificationException 异常来保证自身的正常运行是错误的：fail-fast 行为只应该用来 debug。</span><br><span class="hljs-comment"> * &lt;p&gt;This class is a member of the</span><br><span class="hljs-comment"> * &lt;a href=&quot;&#123;<span class="hljs-doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span><br><span class="hljs-comment"> * Java Collections Framework&lt;/a&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  Josh Bloch</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     List</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>     ArrayList</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.2</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;E&gt; the type of elements held in this collection</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable<br></code></pre></td></tr></table></figure>

<h4 id="LinkedList-的类属性及构造方法"><a href="#LinkedList-的类属性及构造方法" class="headerlink" title="LinkedList 的类属性及构造方法"></a>LinkedList 的类属性及构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Pointer to first node. // 指向 LinkedList 的第一个节点</span><br><span class="hljs-comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="hljs-comment"> *            (first.prev == null &amp;&amp; first.item != null)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Pointer to last node. // 指向 LinkedList 的最后一个节点</span><br><span class="hljs-comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span><br><span class="hljs-comment"> *            (last.next == null &amp;&amp; last.item != null)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty list.</span><br><span class="hljs-comment"> * 构造一个空 list</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs a list containing the elements of the specified</span><br><span class="hljs-comment"> * collection, in the order they are returned by the collection&#x27;s</span><br><span class="hljs-comment"> * iterator.</span><br><span class="hljs-comment"> * 通过指定的 collection 构造一个包含元素的 list，其顺序由 collection 的迭代器决定。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  c the collection whose elements are to be placed into this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">LinkedList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    addAll(c);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Appends all of the elements in the specified collection to the end of</span><br><span class="hljs-comment"> * this list, in the order that they are returned by the specified</span><br><span class="hljs-comment"> * collection&#x27;s iterator.  The behavior of this operation is undefined if</span><br><span class="hljs-comment"> * the specified collection is modified while the operation is in</span><br><span class="hljs-comment"> * progress.  (Note that this will occur if the specified collection is</span><br><span class="hljs-comment"> * this list, and it&#x27;s nonempty.)</span><br><span class="hljs-comment"> * 将指定的 collection 的所有元素拼接到 list 的末尾元素之后，顺序由指定的 collection 的迭代器决定。在执行该操作(addAll())的时候，如果 collection 被修改了，该操作的行为将不可预知(请注意，如果指定的 collection 正好是该 list 对象自己，那么这种情况将会发生)。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c collection containing elements to be added to this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if this list changed as a result of the call</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-keyword">return</span> addAll(size, c);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inserts all of the elements in the specified collection into this</span><br><span class="hljs-comment"> * list, starting at the specified position.  Shifts the element</span><br><span class="hljs-comment"> * currently at that position (if any) and any subsequent elements to</span><br><span class="hljs-comment"> * the right (increases their indices).  The new elements will appear</span><br><span class="hljs-comment"> * in the list in the order that they are returned by the</span><br><span class="hljs-comment"> * specified collection&#x27;s iterator.</span><br><span class="hljs-comment"> * 从指定的位置开始将指定 collection 中的所有元素插入到该 list 中。指定位置的元素(如果有的话)及其右边的元素将会右移(原索引值增大)。新的元素将会以指定 collection 的迭代器 返回的顺序出现在 list 中。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> index index at which to insert the first element</span><br><span class="hljs-comment"> *              from the specified collection</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> c collection containing elements to be added to this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if this list changed as a result of the call</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if the specified collection is null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addAll</span><span class="hljs-params">(<span class="hljs-type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;<br>    <span class="hljs-comment">// 判断索引是否非法</span><br>    checkPositionIndex(index);<br><br>    <span class="hljs-comment">// 将 collection 转为数组</span><br>    Object[] a = c.toArray();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> a.length;<br>    <span class="hljs-comment">// 如果为空数组，返回 false</span><br>    <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    Node&lt;E&gt; pred, succ;<br>    <span class="hljs-comment">// 如果索引值与容器的大小相同，即当前 LinkedList 实例中无任何元素</span><br>    <span class="hljs-keyword">if</span> (index == size) &#123;<br>        succ = <span class="hljs-literal">null</span>;<br>        pred = last;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        succ = node(index);<br>        pred = succ.prev;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (Object o : a) &#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) o;<br>        <span class="hljs-comment">// 构建 Node 节点对象 newNode</span><br>        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, <span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 如果指定位置的元素位于列表头部，则 newNode 为 first 节点</span><br>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>            first = newNode;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 否则，前一个节点的 next 属性指向 newNode</span><br>            pred.next = newNode;<br>        <span class="hljs-comment">// pred 指向 newNode，开始下一轮遍历(相当于常规 for 循环的 i++)</span><br>        pred = newNode;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果原 list 为空列表，则经过遍历之后，last 指向 pred</span><br>    <span class="hljs-keyword">if</span> (succ == <span class="hljs-literal">null</span>) &#123;<br>        last = pred;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果指定索引位置有值，遍历添加 collection 中的元素之后，指定索引位置的元素及其右侧的所有元素统一右移，，将新增的所有元素中的最后一个元素的 next 指向 右移的元素中的第一个元素；右移的元素中的第一个元素的 prev 属性指向新增元素中的最后一个。</span><br>        pred.next = succ;<br>        succ.prev = pred;<br>    &#125;<br><br>    <span class="hljs-comment">// 原 size 加上 新增元素的数量</span><br>    size += numNew;<br>    <span class="hljs-comment">// list 的结构性更改次数 +1</span><br>    modCount++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkPositionIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isPositionIndex(index))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Tells if the argument is the index of a valid position for an</span><br><span class="hljs-comment"> * iterator or an add operation.</span><br><span class="hljs-comment"> * 判断参数代表的索引位置在 iterator 或者 add() 中是否可用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPositionIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// 不小于零，且不大于 size</span><br>    <span class="hljs-keyword">return</span> index &gt;= <span class="hljs-number">0</span> &amp;&amp; index &lt;= size;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the (non-null) Node at the specified element index.</span><br><span class="hljs-comment"> * 返回指定位置的非空节点</span><br><span class="hljs-comment"> * 此处遍历 list 查找指定位置的元素时，先判断 index 距离 begin 节点近还是 end 节点。如此可以减少遍历次数，有助于性能表现。大概这就是维护成双向列表而非单向列表的原因吧。</span><br><span class="hljs-comment"> */</span><br>Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br><br>    <span class="hljs-comment">// 指定的索引值是否小于中位数(翻译成人话就是，判断索引是否在列表的前半段)</span><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-comment">// 就是硬遍历，直到指定索引位置</span><br>        <span class="hljs-comment">//  因为 i &lt; index，所以会遍历到指定索引位置的前一个节点，这时取其 next 指向的节点即可。</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 私有静态内部类</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-comment">// item 为当前节点的值</span><br>        <span class="hljs-built_in">this</span>.item = element;<br>        <span class="hljs-comment">// next 指向当前节点的下一个节点</span><br>        <span class="hljs-built_in">this</span>.next = next;<br>        <span class="hljs-comment">// prev 指向当前节点的前一个节点</span><br>        <span class="hljs-built_in">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>关于关键字 transient，，<br>一个对象只要实现了 Serializable 接口，该对象就可以被序列化。然而在实际开发过程中，常常会遇到这样的问题，该类有些属性需要序列化，其他属性不需要被序列化。例如一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及序列化）中被传输，这些信息对应的变量就可以加上 transient 关键字，这样变量的生命周期仅存在于调用者的内存中而不会被写到磁盘里持久化。)</p>
</blockquote>
<h4 id="首尾节点的操作"><a href="#首尾节点的操作" class="headerlink" title="首尾节点的操作"></a>首尾节点的操作</h4><p>因为 first 和 last 属性的存在，所以在 LinkedList 中首尾节点的操作效率很高，以 getFirst() 和 removeFirst() 方法为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the first element in this list.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the first element in this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NoSuchElementException if this list is empty</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> f.item;<br>&#125;<br><br><span class="hljs-comment">// 删</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes and returns the first element from this list.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the first element from this list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NoSuchElementException if this list is empty</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">removeFirst</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-keyword">return</span> unlinkFirst(f);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Unlinks non-null first node f.</span><br><span class="hljs-comment"> * 首先 first 节点的 prev 肯定是 null，先复制它的 next 节点，然后将它的 item 和 next 置空，至此，，first 节点就是一个空的 Node 对象了，最终被 GC。然后判断 next 节点，如果它为null，则说明该 LinkedList 对象只有一个 Node，否则将 first 指向 刚才复制的 next 节点。最后 size 减 1，modCount 加 1。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> E <span class="hljs-title function_">unlinkFirst</span><span class="hljs-params">(Node&lt;E&gt; f)</span> &#123;<br>    <span class="hljs-comment">// assert f == first &amp;&amp; f != null;</span><br>    <span class="hljs-comment">// 断言 f 为 first 节点，且 f 不为空</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> f.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = f.next;<br>    f.item = <span class="hljs-literal">null</span>;<br>    f.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>    first = next;<br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>        last = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">else</span><br>        next.prev = <span class="hljs-literal">null</span>;<br>    size--;<br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><span class="hljs-comment">// &#x27;改&#x27;就不说了</span><br><span class="hljs-comment">// &#x27;增&#x27;其实是 removeFirst() 反向操作，略。</span><br></code></pre></td></tr></table></figure>
<p>关于 modCount 👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The number of times this list has been structurally modified.</span><br><span class="hljs-comment"> * 该列表在结构上被修改的次数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">modCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>modCount 为 AbstractList(<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable =&gt;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; =&gt;<br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractCollection</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">List</span>&lt;E&gt;)的属性<br></code></pre></td></tr></table></figure>

<h4 id="非首尾节点的操作"><a href="#非首尾节点的操作" class="headerlink" title="非首尾节点的操作"></a>非首尾节点的操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the element at the specified position in this list.</span><br><span class="hljs-comment"> * 删除该列表指定位置的元素</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br> checkElementIndex(index);<br>    <span class="hljs-keyword">return</span> unlink(node(index));<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the (non-null) Node at the specified element index.</span><br><span class="hljs-comment"> * 返回指定位置的非空node，，判断 index 在 LinkedList 的前半部分还是后半部分，然后取循环次数少的分支进行遍历。</span><br><span class="hljs-comment"> */</span><br>Node&lt;E&gt; <span class="hljs-title function_">node</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-comment">// assert isElementIndex(index);</span><br>    <span class="hljs-comment">// 保证不会抛出 IndexOutOfBoundsException 异常</span><br><br>    <span class="hljs-comment">// &gt;&gt;：带符号右移。正数右移高位补0，负数右移高位补1。</span><br>    <span class="hljs-comment">// 比如：4 &gt;&gt; 1，4 的二进制为 100，移位之后变为 10，即十进制 2。</span><br>    <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>        Node&lt;E&gt; x = first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++)<br>            x = x.next;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;E&gt; x = last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt; index; i--)<br>            x = x.prev;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Unlinks non-null node x.</span><br><span class="hljs-comment"> */</span><br>E <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>    <span class="hljs-comment">// assert x != null;</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">E</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> x.item;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br><br>    <span class="hljs-comment">// 如果要移除的元素位于头节点，则直接将头节点指向下一个节点。</span><br>    <span class="hljs-comment">// 否则将前一个节点的 next 属性指向下一个节点，并将当前节点的 prev 属性置空</span><br>    <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>        first = next;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev.next = next;<br>        x.prev = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果要移除的元素位于尾节点，则直接将尾节点指向前一个节点。</span><br>    <span class="hljs-comment">// 否则将下一个节点的 prev 属性指向前一个节点，并将当前节点的 next 属性置空</span><br>    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>        last = prev;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        next.prev = prev;<br>        x.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 将当前节点的 item 属性置空</span><br>    x.item = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 长度 -1</span><br>    size--;<br>    <span class="hljs-comment">// 结构性修改次数 +1</span><br>    modCount++;<br>    <span class="hljs-keyword">return</span> element;<br>&#125;<br><br><span class="hljs-comment">// 增</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>    checkPositionIndex(index);<br><br>    <span class="hljs-keyword">if</span> (index == size)<br>        linkLast(element);<br>    <span class="hljs-keyword">else</span><br>        linkBefore(element, node(index));<br>&#125;<br><span class="hljs-comment">// linkLast 与 linkBefore 方法类似，以 linkBefore 为例</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<br>    <span class="hljs-comment">// assert succ != null;</span><br>    <span class="hljs-comment">// succ 为插入前 index 位置的节点，需要做的是将新节点的 prev 属性指向 succ.prev，将新节点的 next 属性指向 succ。</span><br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br>    <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br>    succ.prev = newNode;<br>    <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>)<br>        first = newNode;<br>    <span class="hljs-keyword">else</span><br>        pred.next = newNode;<br>    size++;<br>    modCount++;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>另外值得注意的是，<strong>LinkedList 支持插入 null 值，原因在于 Node 的构造方法。插入 null 值时，其实是将 null 值给了 node 节点的 item 属性，node 节点的 prev 和 next 还是 非 null 的</strong>。</p>
<p>—- update@2019-03-18 22：23：47 下面—-<br>发现个知识点，，今天点开 LinkedList 中实现的 <code>Deque</code>接口，DOC注释中这样写道：👇</p>
<blockquote>
<p>A linear collection that supports element insertion and removal at both ends.  The name deque is short for “double ended queue” and is usually pronounced “deck”.<br>Deque 是支持双端插入和删除元素的线性集合，<strong>deque</strong> 是 <em>double ended queue</em> 的缩写，通常读作 <strong>deck</strong>。</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p><code>LinkedList</code> 的本质是双向链表。与 <code>ArrayList</code> 相比，<code>LinkedList</code> 的插入和删除速度更快，但是随机访问速度则很慢。测试表明，对于 10 万条的数据，与 <code>ArrayList</code> 相比，随机提取元素时存在数百倍的差距。除继承 <code>AbstractList</code> 抽象外，<code>LinkedList</code> 还实现了另一个接口 <code>Deque</code>，即 <code>double-ended-queue</code>。这个接口同时具有队列和栈的性质。<code>LinkedList</code> 包含 3 个重要的成员：<code>size</code>、<code>first</code>、<code>last</code>。<code>size</code> 是双向链表中节点的个数。<code>first</code> 和 <code>last</code> 分别指向第一个和最后一个节点的引用。<code>LinkedList</code> 的优点在于可以将零散的内存单元附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存利用率较高。</p>
<p>码出高效 Java 开发手册 P156</p>
</blockquote>
<hr>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/28101975">清浅池塘—LinkedList 初探</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33733931">何柄融—ArrayList 和 LinkedList 的区别和使用场景</a>(有删改)</li>
</ol>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>数据结构</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>关于微观下i++的并发执行</title>
    <url>/2019/03/08/about_java_microcosmic_i++/</url>
    <content><![CDATA[<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>最近一直没有更新文章是因为过得很充实，，<br>一方面，现在在做小程序的线上商城，小程序这边倒没什么难的，难的是服务器端怎么设计架构，涉及到不同的客户,不同的客户门店组织架构又不一样，硬件条件也不一样，商品也不一样，还需要跟 ERP 的同事进行沟通。。<br>另一方面，一直计划在房子合同到期(2019-04-04)之后换工作，所以积极准备面试，查漏补缺什么的。去年12月份时候，买了『深入理解Java虚拟机』和『Java并发编程的艺术』。前者全是干货，干到没法儿写博客做笔记，否则就是在照搬书上的内容了。后者，，额，有点晦涩，没有读下去的欲望，然后就放在省图计算机科学分类下的书架上了，嗯，上周末去省图发现那本书已经不见了🤣。<br>对了，与此同时，，发现了 vue-element-admin 框架，一直想试试 webpack，然后就在不忙的时候慢慢重构现有的后台页面。用封装好的组件写页面真省心，爽的飞起~</p>
<p>嗯，，今天的主要内容来自『深入理解Java虚拟机』的第五部分第一章–<strong>Java内存模型与线程</strong>。</p>
<p>这是第二次读这一部分了，，第一次读的时候大水漫灌囫囵吞枣，全局把握(大误)。这次读的时候主要的是抠细节，温故知新，受益匪浅！下面进入正题儿~</p>
<h4 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h4><h5 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h5><blockquote>
<p>由于计算机的存储设备与处理器的运算速度有几个量级的差距，所以<strong>现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存(Cache)来作为内存与处理器之间的缓冲</strong>：将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
</blockquote>
<blockquote>
<p><strong>基于高速缓存的存储交互很好的解决了处理器与内存之间的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性(Cache Coherence)。</strong>在多处理器系统中，每个处理器都有自己的高速缓存，而他们又共享同一主存。</p>
</blockquote>
<blockquote>
<p>– Page 361</p>
</blockquote>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-%E5%A4%84%E7%90%86%E5%99%A8%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%BB%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="处理器、高速缓存、主内存间的交互关系"></p>
<h5 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h5><blockquote>
<p><strong>Java 虚拟规范试图定义一种 Java 内存模型 (Java Memory Model, JMM) 来屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p>
</blockquote>
<blockquote>
<p><strong>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</strong>　</p>
</blockquote>
<blockquote>
<p><strong>Java 内存模型规定了所有的变量都存储在主内存(Main Memory)中，每条线程还有自己的工作内存(Working Memory)，线程中保存了被该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量。</strong>不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br>– Page 362-363<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-java%E7%BA%BF%E7%A8%8B%E3%80%81%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92.png" alt="Java线程、工作内存、主内存间的交互关系"></p>
</blockquote>
<blockquote>
<p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java 内存模型中定义了一下 8 种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的( double 和 long 例外)。</p>
<ul>
<li><span id="lock"><strong>lock</strong>(锁定)</span>：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><span id="unlock"><strong>unlock</strong>(解锁)</span>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><strong>read</strong>(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li>
<li><strong>load</strong>(载入): 作用于工作内存的变量，它把read操作的从主内存中得到的变量值放入工作的变量副本中。</li>
<li><strong>use</strong>(使用)：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li><strong>assign</strong>(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><strong>write</strong>(写入)：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
</blockquote>
<blockquote>
<p>– Page 365</p>
</blockquote>
<p>需要注意的是，上面👆提及的每一种操作都是原子的，，而不是『从内存中读取变量，然后修改变量，然后回写到内存』这整个过程是原子的。这意味着多线程情况下，不加干预时上面8种操作在线程间是交替进行的。如对主内存中的变量a、b 进行访问时，一种可能出现的顺序是 read a, read b, load b, load a..<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png" alt="@内存间交互操作"></p>
<h5 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h5><blockquote>
<p>当一个变量定义为 volatile 之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是立即得知的。而普通变量无法做到这一点，普通变量的值，在线程间传递均需要通过主内存来完成。例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程A回写完成之后再从主内存进行读取操作，新变量的值才会对线程 B 可见。</p>
</blockquote>
<blockquote>
<p>– Page 366</p>
</blockquote>
<p>不得不说的是，读到这里的时候很困惑，，volatile 是如何让被修改后的变量值立即被其他线程得知的呢？？？<br>这就不得不提到<a href="https://baike.baidu.com/item/MESI%E5%8D%8F%E8%AE%AE/22742331">MESI协议</a>，MESI协议使用四个状态位描述每一个<a href="http://ifeve.com/disruptor-cacheline-padding/">缓存行(Cache Line)</a>。关于缓存行，在这篇文章中只需要知道它是 <strong>cache 和 RAM 交换数据的最小单位,通常为 64 Byte</strong>就可以了。</p>
<p>ok，下面简单说说MESI协议。</p>
<ul>
<li>**M(Modified)**：表示当前 Cache 行中包含的数据与内存中的数据不一致，而且它仅在本 CPU 的 Cache 中有效，其他 CPU 的 Cache 中不存在拷贝，即这个 Cache 行的数据是当前处理器系统中最新的数据拷贝。当 CPU 对这个 Cache 行进行替换操作时，必然会引发系统总线的写周期，将 Cache 行中数据与内存中的数据同步。</li>
<li>**E(Exclusive)**：与 Modified 状态类似，唯一的区别是 Modified 状态表示当前 Cache Line 中的数据与内存中的数据不一致，而 Exclusive 状态下的 Cache 与内存中的数据一致。</li>
<li>**S(Shared)**：表示缓存行中包含的数据有效，而且在当前 CPU 和其他 CPU 中至少存在一个副本。在该缓存行中的数据是当前处理器系统中最新的数据拷贝，而且与内存中的数据一致。<br>**I(Invalid)**：表示当前缓存行中数据无效。</li>
</ul>
<p>在 MESI 缓存一致性协议下，我们看看在Java中 i++ 操作是怎么执行的。</p>
<blockquote>
<p>两个 CPU A、B(即多核多线程)同时执行 i++ 的操作，假设 i 初始值为0：</p>
</blockquote>
<ol>
<li>CPU A 从主内存中读入(read) i 到工作内存，并载入(load)到副本，此时其他 CPU 的缓存中并不存在变量 i，所以 CPU A 中缓存行状态为 Exclusive。</li>
<li>CPU B 从主内存中读入(read) i 到工作内存，并载入(load)到副本，发现 CPU A 的缓存中已经存在变量 i 了，那么CPU B 中工作缓存的相关缓存行设置为 Shared，CPU A 中的相关缓存行也设置为 Shared。</li>
<li>CPU A 开始执行 i++，i 值加一等于一，但是只是在寄存器中，并未写入缓存，此时状态还是 Shared。</li>
<li>CPU B 开始执行 i++，i值加一等于一，同上，还是 Shared。</li>
<li>CPU A 将计算后的值重新赋值(assign)给缓存中的副本，i 值为1，缓存行状态改为 Modified，此时 CPU B 的缓存行状态改为 Invalid。</li>
<li>CPU B 准备比赋值给缓存中 i 的副本时，发现缓存行已处于无效(Invalid)状态，需要从内存中重新读取(read)，又因为 CPU A 中相关缓存行中有变量 i 且为 Modified 状态，那么要求CPU A 将计算后的 i 值回写入(write)内存，内存中的 i 值为1，CPU A的缓存行状态为 Exclusive，CPU B 将内存中的 i 值读入(read+load)自己的缓存中的变量i的副本，此时CPU A、B 的缓存行都为 Shared，i 值都为1。</li>
<li>CPU B 将 工作内存中的 i 值副本写入(write)到内存中，i 值副本此时为1，内存中的 i 值亦为1，即把1赋值给1，CPU B 中缓存行的状态变为 Modified，CPU A中的缓存行值变为Invalid。</li>
</ol>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131637-MESI%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B.png" alt="@MESI缓存一致性模型"></p>
<p>以上👆即为不加人为干预情况(使用volatile、synchronized关键字)下 i++ 在多核多线程架构中可能产生的执行结果。所以 MESI 缓存一致性协议并不能保证<em>内存一致性</em>。另外，在上面的例子中，表述并不算太严谨，，比如关于提到的『工作内存』，在『深入理解Java虚拟机』中是这么说的：</p>
<blockquote>
<p>为了获取更好的运行速度，虚拟机(甚至是硬件系统本身的优化措施)可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。<br>– Page 364</p>
</blockquote>
<p>还有，在1、2中，CPU A、B read 并 load i 到工作内存中的副本中，在书中是这样说的：</p>
<blockquote>
<p>Java 内存模型只要求read、load和store、write操作必须按顺序执行，而没有保证是连续执行。也就是说，read与Load之间、stire与write之间是可插入其他质量的。如对内存中的变量a、b进行访问时，一种可能出现的顺序是read a、read b、load b、load a。<br>– Page365</p>
</blockquote>
<p>👆诸如此类，，所以，嗯，注意领会精神。</p>
<p>OK，进行下一话题..<br>倘若此时我们使用 volatile 关键字修饰变量 i。因为 volatile 表示不使用寄存器的值，每次都从内存读(不包括缓存)。所以，在上边例子中的第三步，assign 工作内存中 i 的副本之后，立即将值回写到主内存中。书中的表述为：</p>
<blockquote>
<p>有 volatile 修饰的变量，在编译成汇编语言之后，比不使用 volatile 修饰变量多了一行<code>lock addl $0x0,(%esp)</code>,查询 IA32 手册得知，它的作用是使得本 CPU 的 Cache 写入了内存，该写入动作也会引起别的 CPU 或者别的内核无效化(Invalidate)其 Cache，这种操作相当于对 Cache 中的变量做了一次前面介绍Java内存模式中所说的“store”和“write”操作。所以通过这样一个操作，可让前面 volatile 变量的修改对其他 CPU 立即可见。</p>
</blockquote>
<p>写到这里，我们可能会觉得 i++ 被 volatile 修饰过之后，就可得到期望的 i 值。然而即使这样，我们得到的 i 值依然比期望值要小。</p>
<blockquote>
<p>问题就出在自增运算“i++”之中，我们用 javap 反编译这段代码后会发现只有一行 i++ 的代码在 Class 文件中是由4条字节码指令构成的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// i 为静态变量<br>0:  getstatic<br>3:  iconst_1<br>4:  iadd<br>5:  putstatic<br></code></pre></td></tr></table></figure>
<p>从字节码层面上很容易就分析出并发失败的原因了：当 getstatic 指令把 i 值取到操作栈时，volatile 关键字保证了 i 的值在此时是正确的，但是在执行 iconst_1、iadd 这些指令的时候，其他线程可能已经把 i 的值加大了，而在操作栈顶的值就变成了过期的数据，所以 putstatic 指令执行后就可能把较小的 i 值同步回主内存之中。<br>(PS: 一条字节码指令，也并不意味着执行这条指令就是一个原子操作。一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化为若干条本地机器码指令。)</p>
</blockquote>
<blockquote>
<p>由于 volatile 变量只能保证可见性，在不符合一下两条规则的运算场景中，我们仍要通过锁(使用synchronized和java.util.conrurrent中的原子类)来保证原子性。</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
</blockquote>
<p>所以，，此时如果要解决 i++ 的问题，靠 volatile 关键字是不行的，要么将 volatile 关键字改为 synchronized 关键字上锁(lock 作用于主内存，它把一个变量标识为一条线程独占的状态。)；要么，将 i++ 替换为 Java 并发工具包中的 AtomicInteger 类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>...<br>AtomicInteger.incrementAndGet();<br></code></pre></td></tr></table></figure>

<hr>
<p>参考链接：</p>
<ol>
<li><a href="https://tech.meituan.com/2018/11/15/java-lock.html">不可不说的Java“锁”事</a></li>
<li><a href="https://www.cnblogs.com/chuliang/p/8206748.html">缓存一致性协议 mesi</a></li>
<li><a href="https://blog.csdn.net/nch_ren/article/details/78924808">volatile实现可见性的原理</a></li>
<li><a href="https://blog.csdn.net/atsky0328/article/details/80422183">cache一致性协议，MESI和MOESI</a></li>
<li><a href="http://item.jd.com/11252778.html">周志明-深入理解Java虚拟机</a></li>
<li>[一针见血系列[8]: 什么叫内存可见性？什么叫寄存器可见性？(<a href="http://swiftlet.net/archives/3024">http://swiftlet.net/archives/3024</a>)</li>
<li><a href="https://zhuanlan.zhihu.com/p/43624414">MESI与内存屏障</a></li>
</ol>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>关于语码转换</title>
    <url>/2018/05/04/about_code_switch/</url>
    <content><![CDATA[<h3 id="关于语码转换"><a href="#关于语码转换" class="headerlink" title="关于语码转换"></a>关于语码转换</h3><p>最近发现自己有一个习惯，就是在聊天的时候总是『不经意间』在普通话中夹杂着英语『表达式(expression)』或者单词什么的。其实，以前也在别人身上遇到过这种情况，当时可能只感觉到『挺装哔』的吧，没往多了想。但是，如今自己身上也出现了这个现象，不免忍不住自省：『我真的只是在装哔么？』</p>
<h4 id="What"><a href="#What" class="headerlink" title="What."></a>What.</h4><p><a href="http://www.baike.com/wiki/%E8%AF%AD%E7%A0%81%E8%BD%AC%E6%8D%A2">语码转换</a>-（<em>Code Switching</em>）是指说话者在对话或交谈中，从使用一种语言或方言转换到使用另一种语言或方言。</p>
<h4 id="Why？？？"><a href="#Why？？？" class="headerlink" title="Why？？？"></a>Why？？？</h4><p>– <em>以前为什么没有这个习惯，为什么是最近？</em></p>
<p>认真想了下，，可能是『职业病』。程序员，平时编码时都是用各种高级计算机编程语言，绝大部分以英语为主(目前所知，除『<a href="https://baike.baidu.com/item/%E6%98%93%E8%AF%AD%E8%A8%80/292481?fr=aladdin">易语言</a>』用汉语之外)。所以工作中时时刻刻都在写英语单词&#x2F;表达式，不光是写，，编程环境也是英语。比如主力写 Java 用的 Eclipse，还有最近写微信小程序用的 Sublime Text，，当然这些也有汉化版的，但总感觉怪怪的，，所以除了写英文，还好读(识记)英文。因为大家都在同样的环境下写代码，所以沟通起来经常会这样『你把 Tomcat clean 一下』、『把这个 jar 包 build path 一下』、『把这个 maven 项目重新 update project 一下』诸如此类。还有各种异常 NullPointerException、ClassNotFoundException 等等,,要想 debug 只能逼自己去识记这些 expression (包括英文单词、短语、短句..)。时间久了，英文大家都是这样过来的，所以用这些英文 expression 丝毫不影响沟通，而且某种程度上比(强行)翻译过来的汉语表达更『准确』。<br>以前也学英语，但是并没有这样高频的使用场景，，除了上英语课，还有英语考试。。。论英语语境的重要性(敲黑板 knock, knock..)。</p>
<h4 id="And"><a href="#And" class="headerlink" title="And.."></a>And..</h4><p>我觉得，，<strong>大部分时候，一种语言被翻译成另一种语言的时候，多多少少会有些信息上的损耗</strong>。这也是『译事三难(<em><a href="https://baike.baidu.com/item/%E4%BF%A1%E8%BE%BE%E9%9B%85/10899200?fr=aladdin">信达雅</a>-严复【天演论】:内容忠实于原文谓信，文辞畅达谓达，有文采谓雅。</em>)』中的信之难。比如，『4』在某种语言中对应的表达方式是『1 + 3』，OK，那么我们现在需要把『4』这样一种东西翻译成另外一种语言。倘若，这种语言中刚好也存在『1』和『3』这样的expression，OK，那么我们直接翻译成对应语言中的『1 + 3』就好。若是不存在『1』和『3』，只存在『2』这种expression，那我们只能先保证『信』，把『4』翻译成『2 + 2』。抑或，对应语言中不存在『+』这种expression，只存在『×』，那只好翻译成『2 × 2』咯。以这个例子来看，虽然最后都表达了『4』，但显然达成『4』的方式是不一样的。</p>
<p>我想说的是，很多时候<strong>有那么一种场景，对应语言中并没有很合适的expression，，这个时候，倘若对方刚好知道你想表达的是什么，或者说能 get 到，总感觉比硬生生解释更有趣</strong>。像是讲(冷)笑话，直接将笑点讲出来，可能会非常无聊，完全失去了『笑话』的意义。但倘若，将笑点包装在『笑话』中，对方听了可以 get 到那个点，这时候才有『会心一笑』(捧腹大笑，，总之是笑了)。这个思考 translate&#x2F;convert 的过程，或者说转得那弯儿才是最有趣儿的~事实上，我非常喜欢 enjoy 这个单词，但我真的想不到汉语语境中与之对应的expression。。</p>
<p>或者，，像上边提到过的『4』一样，我们再谈论的『4』的时候，我们不直接谈论『4』，，而是，我说『1 + 3』的时候，你可以 get 到我在谈『4』，你在说『2 + 2』的时候，我也可以 get 到。这个『4』就像<a href="https://baike.baidu.com/item/%E7%99%BD%E9%A9%AC%E9%9D%9E%E9%A9%AC/464?fr=aladdin">白马非马</a>中的马，像 Java 中的抽象类，，而『1 + 3』和『2 + 2』就像白马非马中的白马，Java 中的实例化对象。<br>总之，，有时候，抽象的东西的确比具象的东西更美~</p>
<p>另外，，<strong>语码转换也是有成本的</strong>，需要花额外的时间去 translate，找到对应语言中的 expression。而且，还不一定能找到。。</p>
<h4 id="What’s-more"><a href="#What’s-more" class="headerlink" title="What’s more~"></a>What’s more~</h4><p>姑且再发散一下，，<strong>有时候聊天中会夹杂很多『(专业)术语』。看上去是纯装哔，但其实有可能只是想降低沟通成本</strong>。也可能是对方这样表述惯了，一时并未 switch 过来。<br>举个稍微极端一点的例子，，我们都知道椅子是什么，所以我们在谈到椅子的时候，不需要按照百度百科中词条解释那样去说：『一种日常生活家具，一种有靠背、还有扶手的坐具。』，，直接说椅子就好，准确、高效~</p>
<h4 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h4><p>有一天和同事去吃饭，地下的美食广场，各种档口的那种。饭点儿，人巨多，桌子长凳密密麻麻，我们在里边找到一空位。<br>…<br>吃完了，起身准备离开，，我在前，同事在后。没走几步，我望着出口的方向顿了一下，，然后离开。<br>从美食广场出来之后，我问同事，，<br><code>Me</code> –『晓得刚才我为什么顿一下么？』<br><code>同事</code> – 『？？？』<br><code>Me</code> – 『因为我刚才在【规划路径】，哈哈』<br><code>同事</code>– 『好冷..』</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>沟通</tag>
        <tag>术语</tag>
      </tags>
  </entry>
  <entry>
    <title>about_newSingleThreadExecutor</title>
    <url>/2021/09/04/about_newSingleThreadExecutor/</url>
    <content><![CDATA[<h4 id="关于-Executors-newSingleThreadExecutor"><a href="#关于-Executors-newSingleThreadExecutor" class="headerlink" title="关于 Executors.newSingleThreadExecutor()"></a>关于 Executors.newSingleThreadExecutor()</h4><p>本以为只是一个简单的单线程线程池，与 <code>Executors.newFixedThreadExecutor(1)</code> 类似，但它的 <code>DOC</code> 注释中又显式提到：</p>
<blockquote>
<p>Unlike the otherwise equivalent  {@code newFixedThreadPool(1)} the returned executor is guaranteed not to be <strong>reconfigurable to use additional threads</strong>.</p>
<p>与类似功能的 <code>newFixedThreadPool(1) </code>不一样，该方法返回的线程池执行器不可以被重新配置以使用额外的线程。</p>
</blockquote>
<p>关键在于<strong>不可以重新配置</strong>。来看看它的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// FinalizableDelegatedExecutorService 装饰器</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * FinalizableDelegatedExecutorService 装饰器，普普通通。但多了一个 finalize() 方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DelegatedExecutorService</span> &#123;<br>    FinalizableDelegatedExecutorService(ExecutorService executor) &#123;<br>        <span class="hljs-built_in">super</span>(executor);<br>    &#125;<br>    <span class="hljs-comment">// 关于 finalize()，在『深入理解Java虚拟机』中有提到：可达性分析后，没有与 GC Roots 相连接的对象</span><br>    <span class="hljs-comment">// 如果 Override 了 finalize()，且该方法还没有被执行过，则该对象会被添加到 F-Queue 的队列中，并</span><br>    <span class="hljs-comment">// 稍后在一个由虚拟机发起的自动建立的、低优先级的 Finalizer 线程中去执行 finalize()，但并不承诺会</span><br>    <span class="hljs-comment">// 等到该方法执行完成。</span><br>    <span class="hljs-comment">// FinalizableDelegatedExecutorService 会尝试在被 GC 时关闭线程池。</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * A wrapper class that exposes only the ExecutorService methods</span><br><span class="hljs-comment">  * of an ExecutorService implementation.</span><br><span class="hljs-comment">  * 仅暴露 ExecutorService 接口的方法</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelegatedExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService e;<br>    <span class="hljs-comment">// 构造方法</span><br>    DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123; e.execute(command); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123; e.shutdown(); &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>再看看 <code>ThreadPoolExecutor</code> 的实现：👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ThreadPoolExecutor 和 DelegatedExecutorService 一样都是 AbstractExecutorService 抽象类的子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span><br></code></pre></td></tr></table></figure>

<p>那我们试试，<code>reconfigurable newSingleThreadExecutor</code> 会怎样：👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">singleThreadPoolExecutorTest</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixed</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor)fixed;<br>    <span class="hljs-comment">// 正常执行</span><br>    t1.setCorePoolSize(<span class="hljs-number">2</span>);<br>  <br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>    <span class="hljs-comment">// 强转报错:java.lang.ClassCastException: java.util.concurrent.Executors$FinalizableDelegatedExecutorService cannot be cast to java.util.concurrent.ThreadPoolExecutor</span><br>    <span class="hljs-comment">// 都是 AbstractExecutorService 的子类，没法儿强转</span><br>    <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor)single;<br>    t2.setCorePoolSize(<span class="hljs-number">2</span>);<br>&#125; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * newFixedThreadPool 返回的是 ThreadPoolExecutor，ThreadPoolExecutor 有 setCorePoolSize()，</span><br><span class="hljs-comment"> * 自然没问题。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>ThreadPoolExecutor，线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>关于 nginx 日志分析</title>
    <url>/2018/11/10/about_nginx_log_analyse/</url>
    <content><![CDATA[<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>这次是自己的需求，刚好周六，闲来无事来公司加班，好好总结下。</p>
<p>自己做了个小程序，用来收集平时的位置信息，还有微信步数什么的，租的国外的服务器，，翻墙和部署项目两不误，顺便做做linux的练习，完美~ 在初期，部署项目以及一些静态资源时，经常404，肯定nginx哪里配置错了，，直接在linux服务器上用命令行翻日志又很麻烦，ssh还总断(扶额)。把nginx日志文件当静态资源访问好啦，这样直接在浏览器就可以访问，完美~这一步并不难，好好配置<code>nginx.conf</code>中的location属性就好，略过不表。</p>
<p>但我担心的是访问路径暴露了怎么办。。有必要加上基础的访问限制，验证用户名密码什么的。还要自己写个页面？在数据库配置用户名密码？太不优雅了。还好有nginx的<code>auth_basic</code>模块，完美解决问题~</p>
<p>这之后，有一次闲来没事，翻翻nginx日志，，呦，被吓一跳！👇</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:25-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">195</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/dbadmin/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:26-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">202</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/web/phpMyAdmin/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:26-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">197</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/admin/pma/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:26-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">197</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/admin/PMA/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:26-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">199</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/admin/mysql/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:26-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">200</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/admin/mysql2/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:27-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">204</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/admin/phpmyadmin/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:27-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">204</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/admin/phpMyAdmin/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:27-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">205</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/admin/phpmyadmin2/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2018-11-09T19:58:27-05:00&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;180.180.243.223&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">162</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">198</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">0.000</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;66.98.120.58&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;/mysqladmin/index.php&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;404&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;-&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>👆以上是今天nginx日志中的一部分，，谢谢来自IP<code>180.180.243.223</code>(泰国)朋友的问候，，嗯，访问的路径都是<code>/mysqladmin/index.php</code>、<code>/admin/mysql/index.php</code>、<code>/admin/PMA/index.php</code>什么的，太暴力了！！我还是个孩子呀。。啥都别说了，nginx必须配置动态黑名单！</p>
<h4 id="basic-auth"><a href="#basic-auth" class="headerlink" title="basic_auth"></a>basic_auth</h4><p>直接看nginx官方文档就好<a href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html">ngx_http_auth_basic_module</a>，教程也很多，比较简单，，也是略过不表。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 关于配置访问用户名和密码，，</span><br><span class="hljs-comment"># 第一次需要创建密码文件，加 -c 参数</span><br>htpasswd -c 密码文件路径 用户名<br><br><span class="hljs-comment"># 生成密码文件之后，再添加用户名密码</span><br>htpasswd 密码文件路径 用户名<br></code></pre></td></tr></table></figure>

<h4 id="添加动态ip黑名单"><a href="#添加动态ip黑名单" class="headerlink" title="添加动态ip黑名单"></a>添加动态ip黑名单</h4><p>这一块，最早是想用<a href="https://www.elastic.co/cn/products">ELK</a>的，，然后服务器崩溃了。嗯，1G内存，放弃了。<br>还是用<a href="http://www.runoob.com/linux/linux-comm-awk.html">awk</a>吧，之前看到 awk 的时候，命令那么长，看都没看直接略过了。后来拖太久又没找到好的解决方案，硬着头皮上吧，，花点时间读一读文档，其实也没太难(至少实现本节内容不算太难)。这儿主要参考了 <a href="http://www.hjqjk.com/2017/Nginx-auto-add-blacklist.html">Hjqjk’s Blog-Nginx动态黑名单</a>，这位仁兄的博客看样子也是用的<a href="https://hexo.io/zh-cn/docs/">HEXO</a>框架，哈哈同道中人~</p>
<p>需要说明的是，，因为还想过用Java IO将日志持久化到数据库，这样就可以用语句分析访问行为了，生成图表也方便。想想，工程量有点大，，后期日志数据可能比较收集到的位置信息和微信步数数据还要大，嗯排期吧先(笑哭)。所以，将nginx日志格式配置成了<code>json</code>格式👇</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"># json 格式配置<br>log_format logstash_json &#x27;<span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;timestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$time_iso8601&quot;</span><span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$server_addr&quot;</span><span class="hljs-punctuation">,</span>&#x27;<br>                             &#x27;<span class="hljs-attr">&quot;client&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$remote_addr&quot;</span><span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span>$body_bytes_sent<span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;requestlengh&quot;</span><span class="hljs-punctuation">:</span>$request_length<span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;requesttime&quot;</span><span class="hljs-punctuation">:</span>$request_time<span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;responsetime&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$upstream_response_time&quot;</span><span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;domain&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$host&quot;</span><span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$request_uri&quot;</span><span class="hljs-punctuation">,</span>&#x27;<br>                            &#x27;<span class="hljs-attr">&quot;referer&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$http_referer&quot;</span><span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;agent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$http_user_agent&quot;</span><span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$status&quot;</span><span class="hljs-punctuation">,</span>&#x27;<br>                          &#x27;<span class="hljs-attr">&quot;x_forwarded_for&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;$http_x_forwarded_for&quot;</span><span class="hljs-punctuation">&#125;</span>&#x27;;<br># 启用logstash_json日志格式配置<br>access_log  /var/log/nginx/access.log  logstash_json;<br></code></pre></td></tr></table></figure>
<p>以下是我筛选IP的脚本👇</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin.bash</span><br><span class="hljs-comment"># (每天)对用户真实ip访问量做统计，粗略统计每天大于20次的加入 nginx 黑名单</span><br><span class="hljs-comment"># @latest_date 2018-11-2</span><br><span class="hljs-comment"># @author Shang</span><br><br><span class="hljs-comment"># 黑名单文件</span><br>conf_path=/pathToBlockips/blockips.conf<br><span class="hljs-comment"># nginx 日志文件</span><br>log_path=<span class="hljs-string">&#x27;/pathToAccessLog/access.log-&#x27;</span>$(<span class="hljs-built_in">date</span> +%Y%m%d)<br><span class="hljs-comment"># nginx 命令绝对路径</span><br>nginx_command=/usr/sbin/nginx<br><span class="hljs-comment"># 过滤掉正常的蜘蛛访问 grep -i -v -E $&#123;spider&#125;|</span><br><span class="hljs-comment"># spider=&quot;Google|Baidu|msnbot|FeedSky|Sogou|360|bing|yahoo&quot;</span><br><br><span class="hljs-comment"># 因为我的nginx使用yum安装的，会自动按日期切割日志，文件也不大，所以一次性全部读入日志文件</span><br><span class="hljs-built_in">cat</span> <span class="hljs-variable">$&#123;log_path&#125;</span>| \<br><span class="hljs-comment"># 指定&#x27;,&#x27;为分割符(认按空格分割)，输出第三个field，即 &quot;client&quot;:&quot;180.180.243.223&quot;</span><br>awk -F<span class="hljs-string">&#x27;[,]&#x27;</span> <span class="hljs-string">&#x27;&#123;print $3&#125;&#x27;</span> | \<br><span class="hljs-comment"># 指定&#x27;:&#x27;为分割符，将第二个field(即&quot;180.180.243.223&quot;)去掉首尾&#x27;&quot;&#x27;后输出</span><br>awk -F: <span class="hljs-string">&#x27;&#123;print substr($2,2,length($2)-2)&#125;&#x27;</span>| \<br><span class="hljs-comment"># 计数，类SQL中的count(ip) group by ip</span><br><span class="hljs-built_in">uniq</span> -c| \<br><span class="hljs-comment"># 倒叙排列，类SQL中的order by count(ip) desc</span><br><span class="hljs-built_in">sort</span> -rn| \<br><span class="hljs-comment"># 如果计数大于20次，以apeend的方式添加到ip黑名单文件中</span><br>awk <span class="hljs-string">&#x27;&#123; if($1 &gt; 20) print &quot;deny &quot;$2 &quot;;&quot;&#125;&#x27;</span> &gt;&gt; <span class="hljs-variable">$&#123;conf_path&#125;</span><br><br><span class="hljs-comment"># 检查nginx.conf是否正确</span><br><span class="hljs-variable">$&#123;nginx_command&#125;</span> -t<br><span class="hljs-keyword">if</span> [ $? -eq 0 ]<br><span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># 如果返回结果正常，则重新载入nginx.conf文件</span><br>    <span class="hljs-variable">$&#123;nginx_command&#125;</span> -s reload<br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure>

<p>创建好该脚本(auto_add_nginx_blockips.sh)，，记得赋予它可执行的权限，，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加 x 权限</span><br><span class="hljs-built_in">chmod</span> u=rwx pathToAuto_add_nginx_blockips.sh<br><br><span class="hljs-comment"># 测试下先</span><br>./auto_add_nginx_blockips.sh<br><br><span class="hljs-comment"># 如果一切正常的话，就可以添加定时任务了~</span><br><span class="hljs-comment"># 编辑当前用户下的定时任务文件</span><br>crontab -e<br><span class="hljs-comment"># 然后添加定时任务，每天23:50执行脚本(顺便将正常执行之后的输出内容重定向到&#x27;无底洞&#x27;中，否则每天一封邮件，受不鸟..)</span><br>50 23 * * * /bin/sh /path/to/auto_add_nginx_blockips.sh 1&gt;/dev/null<br><span class="hljs-comment"># :wq后会自动保存到`/var/spool/cron/$user`中</span><br></code></pre></td></tr></table></figure>

<p>刚开始，制定的执行计划并不是在23:50，，唉，都是因为自动切割日志，切割也就算了，关键还有压缩成<code>.gz</code>文件，这样脚本的复杂度就上升了，又一直搞不明白<code>logrotate</code>什么时候执行切割任务，，费解。所以，最初一直<code>blockips.conf</code>一直没反应，后来开始查<code>/var/log/cron</code>，发现任务也执行了👇</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><code class="hljs accesslog">Nov  <span class="hljs-number">9</span> <span class="hljs-number">23</span>:<span class="hljs-number">01</span>:<span class="hljs-number">01</span> host run-parts(/etc/cron.hourly)<span class="hljs-string">[6988]</span>: starting 0anacron<br>Nov  <span class="hljs-number">9</span> <span class="hljs-number">23</span>:<span class="hljs-number">01</span>:<span class="hljs-number">01</span> host run-parts(/etc/cron.hourly)<span class="hljs-string">[6997]</span>: finished 0anacron<br>## auto_add_nginx_blockips 脚本已执行<br>Nov  <span class="hljs-number">9</span> <span class="hljs-number">23</span>:<span class="hljs-number">50</span>:<span class="hljs-number">01</span> host CROND<span class="hljs-string">[9407]</span>: (root) CMD (/bin/sh /etc/nginx/conf.d/auto_add_nginx_blockips.sh)<br>Nov <span class="hljs-number">10</span> <span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">02</span> host CROND<span class="hljs-string">[9975]</span>: (root) CMD (run-parts /etc/cron.hourly)<br>Nov <span class="hljs-number">10</span> <span class="hljs-number">00</span>:<span class="hljs-number">01</span>:<span class="hljs-number">02</span> host run-parts(/etc/cron.hourly)<span class="hljs-string">[9975]</span>: starting 0anacron<br>...<br></code></pre></td></tr></table></figure>
<p>后来也不记得在哪看到的，如果定时任务执行的执行情况，会发送到mail，，可以去<code>/var/spool/mail/当前用户名</code>中查看👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">From root@host.localdomain  Tue Nov  6 01:30:02 2018<br>Return-Path: &lt;root@host.localdomain&gt;<br>X-Original-To: root<br>Delivered-To: root@host.localdomain<br>Received: by host.localdomain (Postfix, from userid 0)<br>    id 0CF4D4E1C; Tue,  6 Nov 2018 01:30:02 -0500 (EST)<br>From: &quot;(Cron Daemon)&quot; &lt;root@host.localdomain&gt;<br>To: root@host.localdomain<br>Subject: Cron &lt;root@host&gt; /bin/sh /etc/nginx/conf.d/auto_add_nginx_blockips.sh<br>Content-Type: text/plain; charset=UTF-8<br>Auto-Submitted: auto-generated<br>Precedence: bulk<br>X-Cron-Env: &lt;XDG_SESSION_ID=567&gt;<br>X-Cron-Env: &lt;XDG_RUNTIME_DIR=/run/user/0&gt;<br>X-Cron-Env: &lt;LANG=en_US.UTF-8&gt;<br>X-Cron-Env: &lt;SHELL=/bin/sh&gt;<br>X-Cron-Env: &lt;HOME=/root&gt;<br>X-Cron-Env: &lt;PATH=/usr/bin:/bin&gt;<br>X-Cron-Env: &lt;LOGNAME=root&gt;<br>X-Cron-Env: &lt;USER=root&gt;<br>Message-Id: &lt;20181106063002.0CF4D4E1C@host.localdomain&gt;<br>Date: Tue,  6 Nov 2018 01:30:02 -0500 (EST)<br><br># 日志文件路径出问题了，，估计是已经压缩成.gz文件了。。<br>cat: /var/log/nginx/access.log-20181106: No such file or directory<br>nginx: the configuration file /etc/nginx/nginx.conf syntax is ok<br>nginx: configuration file /etc/nginx/nginx.conf test is successful<br></code></pre></td></tr></table></figure>
<p>如果你也遇到了类似的问题，可以尝试去mail中找找线索~ Done！</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>关于TCP协议</title>
    <url>/2017/10/18/about_tcp/</url>
    <content><![CDATA[<h3 id="关于TCP"><a href="#关于TCP" class="headerlink" title="关于TCP"></a>关于TCP</h3><h4 id="TCP-简介"><a href="#TCP-简介" class="headerlink" title="TCP 简介"></a>TCP 简介</h4><p><strong>TCP协议</strong>具体是什么，不赘述，百度之。</p>
<p>我们经常听人说 TCP 是一个<strong>面向连接的</strong>(<em>connection-oriented</em>)、<strong>可靠的</strong>(<em>reliable</em>)、<strong>字节流式</strong>(<em>byte stream</em>)传输协议，TCP 的这三个特性该怎么理解呢？</p>
<ul>
<li><p>面向连接：<strong>在应用 TCP 协议进行通信之前双方通常需要通过三次握手来建立 TCP 连接，连接建立后才能进行正常的数据传输，因此广播和多播不会承载在 TCP 协议上。</strong>(谷歌提交了一个 RFC 文档，建议在 TCP 三次握手的过程允许 SYN 数据包中带数据，即 TFO(<em>TCP Fast Open</em>)，目前 ubuntu 14.04已经支持该 TFO 功能)。但是同时面向连接的特性给 TCP 带来了复杂的连接管理以及用于检测连接状态的存活检测机制。</p>
</li>
<li><p>可靠性：由于 TCP 处于多跳通信的 IP 层之上，而 IP 层并不提供可靠的传输，因此<strong>在TCP层看来就有四种常见传输错误问题，分别是比特错误(<em>packet bit errors</em>)、包乱序(<em>packet reordering</em>)、包重复(<em>packet duplication</em>)、丢包(<em>packet erasure</em>或称为<em>packet drops</em>)，TCP 要提可靠的传输，就需要有额外的机制处理这几种错误。</strong>因此可靠性体现在三个方面：</p>
<ol>
<li><strong>TCP 通过超时重传和快速重传两个常见手段来保证数据包的正确传输</strong>，也就是说接收端在没有收到数据包或者收到错误的数据包的时候会触发发送端的数据包重传(处理比特错误和丢包)。</li>
<li>**TCP 接收端会缓存接收到的乱序到达数据，重新排序后再向应用层提供有序的数据(处理包乱序)**。</li>
<li>**TCP 发送端会维持一个发送『窗口』动态的调整发送速率以适用接收端缓存限制和网络拥塞情况，避免了网络拥塞或者接收端缓存满而大量丢包的问题(降低丢包率)**。<br>因此可靠性需要 TCP 协议具有超时与重传管理、窗口管理、流量控制、拥塞控制等功能。另外 TFO 下 TCP 有可能向应用层提供重复的数据，也就是不可靠传输，但是只会发生在连接建立阶段。</li>
</ol>
</li>
<li><p>字节流式：<strong>应用层发送的数据会在 TCP 的发送端缓存起来，统一分片(例如一个应用层的数据包分成两个 TCP 包)或者打包(例如两个或者多个应用层的数据包打包成一个 TCP 数据包)发送，到接收端的时候接收端也是直接按照字节流将数据传递给应用层</strong>。作为对比，同样是传输层的协议，UDP 并不会对应用层的数据包进行打包和分片的操作，一般一个应用层的数据包就对应一个 UDP 包。这个也是伴随 TCP 窗口管理、拥塞控制等。</p>
</li>
</ul>
<h4 id="TCP-的封装和协议头格式"><a href="#TCP-的封装和协议头格式" class="headerlink" title="TCP 的封装和协议头格式"></a>TCP 的封装和协议头格式</h4><h5 id="TCP-封装在IP报文中，如下图所示"><a href="#TCP-封装在IP报文中，如下图所示" class="headerlink" title="TCP 封装在IP报文中，如下图所示"></a>TCP 封装在IP报文中，如下图所示</h5><p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131900-TCP_in_IP.png" alt="TCP_in_IP"></p>
<h5 id="TCP-的协议头格式"><a href="#TCP-的协议头格式" class="headerlink" title="TCP 的协议头格式"></a>TCP 的协议头格式</h5><p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131900-TCP-Header.png" alt="TCP-Header"></p>
<ul>
<li><strong><code>Source Port</code></strong>(源端口号)和**<code>Destination Port</code><strong>(目标端口号):各2字节<br>用于区别主机中的不同进程。IP 地址用来区分不同的主机。</strong>如此，源 IP 地址+源端口号与目标 IP 地址+目标端口号就能确定唯一的 TCP 连接；**</li>
<li><span id="jump_seq"> <strong><code>Sequence Number</code></strong>(序列号&amp;封包序号):4字节<br>定义了指派给本报文段第一个数据字节的编号。用来标识从TCP发送端向TCP接收端发送的数据字节流，它表示在这个报文段中的第一个数据字节在数据流中的序号。由于 TCP 封包必须要带入 IP 封包当中，所以如果 TCP 数据太大时(大于 IP 封包的容许程度)，就得要进行分段。这个 Sequence Number 就是记录每个封包的序号，可以让收收端重新将 TCP 的数据组合起来。<strong>建立连接时，双方使用各自的随机数生成器生产一个初始序号(inital squence number，ISN)，通常两个方向上的 ISN 是不同的。</strong>主要用来解决网络报乱序(reordering)的问题。</span></li>
<li><span id="jump_ack"><strong><code>Acknowledgment Number</code></strong>(确认号):4字节<br>确认号包含发送确认一端所期望收到的下一个序列号。即如果报文段的接收方成功地接收了对方发来的编号为x的字节，那么它就返回 x+1 作为确认号。不过，<strong>只有当编码位中的</strong><code>ACK</code><strong>为1时，该确认序列号的字段才有效。</strong>所以，<strong>当 client 端收到服务端响应的这个确认码时，就能确定之前发出的封包数据已经被完整的收到了。</strong></span></li>
<li><strong><code>Data Offset</code></strong>(数据偏移):4比特<br>和IP数据包头部一样，TCP头部也有个Options字段，长度可变。为了确认整个TCP包大小，就需要这个标志来说明整个封包区段的起始位置。偏移量每增加1，报头长度就增加4字节，最小为5，最大15，即4*15&#x3D;60个字节的头部长度。没有任何选项字段(TCP option)的TCP头部长度为20字节。</li>
<li><strong><code>reserved</code></strong>(保留字段):4比特<br>供将来使用。</li>
<li><strong><code>Code Bits</code></strong>(编码位):8比特<ul>
<li><code>CWR</code>(Congestion Window Reduce):拥塞窗口减少标志,由发送主机设置，用来表明它接收到了设置ECE标志的TCP包，发送端通过降低发送窗口的大小来降低发送速率；</li>
<li><code>ECE</code>(ECN Echo)：被用来在TCP3次握手时表明一个TCP端是具备ECN功能的，并且表明接收到的TCP包的IP头部的ECN被设置为11；</li>
<li><span id="jump_URG"><code>URG</code>(urgent):取值1时，表明紧急指针字段(Urgent Pointer)有效,代表该封包为紧急封包。用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；</span></li>
<li><span id="jump_ACK"><code>ACK</code>(Acknowledge):取值1代表Acknowledgment Number字段有效，这是一个确认的TCP包，取值0则不是确认包。后续文章介绍中当ACK标志位有效的时候我们称呼这个包为<code>ACK</code>包，使用大写的<code>ACK</code>称呼。</span></li>
<li><code>PSH</code>:(Push):取值1时，代表要求对方立即传送缓冲区内的其他对应封包转由应用处理，而不用进行队列处理，无需等缓冲满了再传送。</li>
<li><code>RST</code>(Reset)：用于复位相应的TCP连接。通常在发生异常或者错误的时候会触发复位TCP连接,也被用来拒绝错误和非法的数据包。必须释放连接，然后再重新建立运输连接。</li>
<li><span id="jump_SYN"><code>SYN</code>(Synchronize)：表示同步序号，仅在三次握手建立TCP连接时有效，用来建立连接(SYN置为1，就表示这是一个连接请求或连接接受报文)。<code>SYN</code>标志位和<a href="#jump_ACK"><code>ACK</code></a>标志位搭配使用。当连接请求的时候，<code>SYN</code>&#x3D;1，<a href="#jump_ACK"><code>ACK</code></a>&#x3D;0；连接被响应的时候，<code>SYN</code>&#x3D;1，<a href="#jump_ACK"><code>ACK</code></a>&#x3D;1；这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有<code>SYN</code>的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行TCP三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行TCP的三次握手；当这个<code>SYN</code>标志位有效的时候我们称呼这个包为<code>SYN</code>包。</span></li>
<li><span id="jump_FIN"><code>FIN</code>(Finish)：带有该标志置位的数据包用来结束一个TCP会话(连接)，但对应端口仍处于开放状态，准备接收后续数据。当<code>FIN</code>标志有效的时候我们称呼这个包为<code>FIN</code>包。这个标志的数据包也经常被用于进行端口扫描。</span></li>
</ul>
</li>
<li><strong><code>Window</code></strong>(滑动窗口):2字节<br>用来控制对方发送的数据量，可以告知对方目前本身有的缓冲器容量(Receive Buffer) 还可以接收封包。当 Window&#x3D;0 时，代表缓冲器已经额满，所以应该要暂停传输数据。传输数据单位为字节。TCP连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知对方以确定对方的发送窗口的上限,这个值是本机期望一次接收的字节数。用于TCP的流量控制；<br>在TCP的发送端和接收端都会维持一个窗口，因为一个 TCP 连接是双向的，因此实际上一个 TCP 连接一共有四个窗口。此处我们先简单介绍一个发送端的窗口如下。图中的数字表示 byte 也就是和上面介绍的TCP协议头中的SN是对应的，3号 byte 以及3号之前的数据表示已经发送并且收到了接收端的<a href="#jump_ACK"><code>ACK</code></a>确认包的数据；4、5、6三个 byte 表示当前可以发送的数据包，也有可能已经已经发送了但是还没有收到<a href="#jump_ACK"><code>ACK</code></a>确认包；7号 byte 及之后的数据表示为了控制发送速率暂时不能发送的数据。其中4-6这三个 byte 就称呼为窗口大小(<em>window size</em>)。当 TCP 连接建立的时候，双方会通过 TCP 头中的窗口大小字段向对方通告自己接收端的窗口大小，发送端依据接收端通告的窗口大小来设置发送端的发送窗口大小，另外在拥塞控制的时候也是通过调整发送端的发送窗口来调整发送速率的。窗口这个词的来源就是当我们从这一个数据序列中单独看4、5、6这几个 byte 的时候，我们仿佛是从一个”窗口”中观察的一样。<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131900-TCP_%E6%BB%91%E7%AA%97.png" alt="TCP_滑窗"></li>
<li><strong><code>Checksum</code></strong>(校验位):2字节<br>发送端基于数据内容计算一个数值，接收端要与发送端数值结果完全一样，才能证明数据的有效性。接收端checksum校验失败的时候会直接丢掉这个数据包。CheckSum是根据伪头+TCP头+TCP数据三部分进行计算的。另外对于大的数据包，checksum并不能可靠的反应比特错误，应用层应该再添加自己的校验方式；</li>
<li><strong><code>Urgent Pointer</code></strong>(紧急指针):2字节<br>指向后面是优先数据的字节,指出在本报文段中的紧急数据的最后一个字节的序号，在<a href="#jump_URG"><code>URG</code></a>&#x3D;1时有效。如果URG标志没有被设置，紧急域作为填充。加快处理标示为紧急的数据段;</li>
<li><strong><code>Options</code></strong>(选项):TCP首部可以有多达40字节的可选信息，用于把附加信息传递给终点，或用来对齐其它选项。</li>
</ul>
<p>另外，我们一般称呼链路层的发出去的数据包为<strong>帧</strong>(<em>frame</em>)，称呼网络层发给链路层的数据包为<strong>包</strong>(<em>packet</em>)，称呼传输层发给网络层的数据包为<strong>段</strong>(<em>segment</em>)。但是正如我们描述所用，段、包、帧也经常统称为数据包或者数据报文。<br>对应用层来说 <strong>TCP 是一个双向对称的全双工(<em>full-duplex</em>)协议，也就是说应用层可以同时发送数据和接收数据</strong>。这就意味着<strong>数据流在一个方向上的传输是独立于另一个方向的传输的，每个方向上都有独立的SN</strong>。</p>
<!-- 留坑 -->

<hr>
<p>参考链接：<br><a href="http://www.imooc.com/article/17411">http://www.imooc.com/article/17411</a> 作者：江户川秋风<br><a href="http://www.jellythink.com/archives/705">http://www.jellythink.com/archives/705</a> 作者：果冻想<br><a href="http://www.cnblogs.com/lshs/p/6038458.html">http://www.cnblogs.com/lshs/p/6038458.html</a> 作者：lshs</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>理解与使用Javascript中的回调函数</title>
    <url>/2017/12/07/callback_function_in_javascript/</url>
    <content><![CDATA[<h3 id="理解与使用Javascript中的回调函数"><a href="#理解与使用Javascript中的回调函数" class="headerlink" title="理解与使用Javascript中的回调函数"></a>理解与使用Javascript中的回调函数</h3><h4 id="有点小感慨"><a href="#有点小感慨" class="headerlink" title="有点小感慨"></a>有点小感慨</h4><p>在这不得不提一下Python，在人工智能火起来之前就在断断续续的看教程。现在因为人工智能的原因，更要好好学习一下，，在学习的过程中了，第一次好像明白『函数式编程』到底是怎么一回事儿了。放张图，各位体会下，，👇<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901132806-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%B1%82%E6%AC%A1.png" alt="编程语言的抽象层次"><br>因为最近工作的原因，先后遇到了几个关于js的问题，没想到需要阅读的Tab页越来越多，需要总结的页是越来越多。这个过程中，没想到朝夕相处的js中也有类似的特性，，比如闭包，之前特地去了解，可还是半知半解，，如今从Python反观js，一下子通透了~哈哈，下面进入正文</p>
<hr>
<p>Javascript中，函数是<a href="http://cnodejs.org/topic/545ca6be0ed03d8070d09992">第一类对象</a>，这意味着函数可以像对象一样按照第一类管理被使用。既然函数实际上是对象：它们能被“存储”在变量中，能作为函数参数被传递，能在函数中被创建，能从函数中返回。</p>
<p>因为函数是第一类对象，我们可以在Javascript使用回调函数。在下面的文章中，我们将学到关于回调函数的方方面面。回调函数可能是在Javascript中使用最多的函数式编程技巧，虽然在字面上看起来它们一直一小段Javascript或者jQuery代码，但是对于许多开发者来说它任然是一个谜。在阅读本文之后你能了解怎样使用回调函数。</p>
<p>回调函数是从一个叫<strong>函数式编程</strong>的编程范式中衍生出来的概念。<strong>简单来说，函数式编程就是使用函数作为变量</strong>。函数式编程过去 - 甚至是现在，依旧没有被广泛使用 - 它过去常被看做是那些受过特许训练的，大师级别的程序员的秘传技巧。</p>
<p>幸运的是，函数是编程的技巧现在已经被充分阐明因此像我和你这样的普通人也能去轻松使用它。函数式编程中的一个主要技巧就是回调函数。在后面内容中你会发现实现回调函数其实就和普通函数传参一样简单。这个技巧是如此的简单以致于我常常感到很奇怪为什么它经常被包含在讲述Javascript高级技巧的章节中。</p>
<h4 id="什么是回调或者高阶函数"><a href="#什么是回调或者高阶函数" class="headerlink" title="什么是回调或者高阶函数"></a>什么是回调或者高阶函数</h4><p>一个回调函数，也被称为<strong>高阶函数，是一个被作为参数传递给另一个函数</strong>（在这里我们把另一个函数叫做“otherFunction”）的函数，回调函数在otherFunction中被调用。一个回调函数本质上是一种编程模式（为一个常见问题创建的解决方案），因此，使用回调函数也叫做回调模式。</p>
<ul>
<li>变量可以指向函数</li>
<li>函数的参数可以接收变量</li>
<li>一个函数可以接收另一个函数做参数</li>
<li>能接收函数做参数的函数就是高阶函数</li>
</ul>
<p>下面是一个在jQuery中使用回调函数简单普遍的例子：👇</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//注意到click方法中是一个函数而不是一个变量</span><br><span class="hljs-comment">//它就是回调函数</span><br>$(<span class="hljs-string">&quot;#btn_1&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Btn 1 Clicked&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>正如你在例子中看到的，我们将一个函数作为参数传递给了click方法。click方法会调用（或者执行）我们传递给它的函数。这是Javascript中回调函数的典型用法，它在jQuery中广泛被使用。</p>
<p>关于回调函数的运作方式，详见<a href="https://someoneiscoding.github.io/2017/12/06/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3JavaScript%E5%90%8C%E6%AD%A5%7C%E5%BC%82%E6%AD%A5%7C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%28EventLoop%29/#%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6">异步机制</a></p>
<p>除了在参数位置定义匿名函数作为回调函数之外，另一种常见的模式是定义一个命名函数并将函数名作为变量传递给函数。比如下面的例子：👇</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//全局变量</span><br><span class="hljs-keyword">var</span> allUserData = [];<br><br><span class="hljs-comment">//普通的logStuff函数，将内容打印到控制台     </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">logStuff</span> (userData)&#123;<br>    <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> userData === <span class="hljs-string">&quot;string&quot;</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userData);<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> userData === <span class="hljs-string">&quot;object&quot;</span>)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> userData)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item + <span class="hljs-string">&quot;: &quot;</span> + userData[item]);<br>        &#125;<br>    &#125;<br>&#125; <br><br><span class="hljs-comment">//一个接收两个参数的函数，后面一个是回调函数     </span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getInput</span> (options, callback)&#123;<br>    allUserData.<span class="hljs-title function_">push</span>(options);<br>    <span class="hljs-comment">//确保callback是一个函数    </span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&quot;function&quot;</span>)&#123;<br>        <span class="hljs-title function_">callback</span>(options);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//当我们调用getInput函数时，我们将logStuff作为一个参数传递给它     </span><br><span class="hljs-comment">//因此logStuff将会在getInput函数内被回调（或者执行）     </span><br><span class="hljs-title function_">getInput</span>(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;Rich&quot;</span>,<span class="hljs-attr">speciality</span>:<span class="hljs-string">&quot;Javascript&quot;</span>&#125;, logStuff);<br><span class="hljs-comment">//name:Rich</span><br><span class="hljs-comment">//speciality:Javascript</span><br></code></pre></td></tr></table></figure>

<h4 id="使用this对象的方法作为回调函数时的问题"><a href="#使用this对象的方法作为回调函数时的问题" class="headerlink" title="使用this对象的方法作为回调函数时的问题"></a>使用<code>this</code>对象的方法作为回调函数时的问题</h4><p>当回调函数是一个<code>this</code>对象的方法时，我们必须改变执行回调函数的方法来保证this对象的上下文。否则如果回调函数被传递给一个全局函数，<code>this</code>对象要么指向全局<code>window</code>对象（在浏览器中）,要么指向包含方法的对象。 我们在下面的代码中说明：👇</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> clientData = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">094545</span>,<br>    <span class="hljs-attr">fullName</span>: <span class="hljs-string">&quot;Not Set&quot;</span>,<br>    <span class="hljs-comment">//setUsrName是一个在clientData对象中的方法</span><br>    <span class="hljs-attr">setUserName</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">firstName, lastName</span>)&#123;<br>        <span class="hljs-comment">//这指向了对象中的fullName属性</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">fullName</span> = firstName + <span class="hljs-string">&quot; &quot;</span> + lastName;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInput</span>(<span class="hljs-params">firstName, lastName, callback</span>)&#123;<br>    <span class="hljs-comment">//在这做些什么来确认firstName/lastName</span><br><br>    <span class="hljs-comment">//现在存储names</span><br>    <span class="hljs-title function_">callback</span>(firstName, lastName);<br>&#125;<br><br><span class="hljs-comment">//当clientData.setUsername被执行时，this.fullName并没有设置clientData对象中的fullName属性。</span><br><span class="hljs-comment">//相反，它将设置window对象中的fullName属性，因为getUserInput是一个全局函数。这是因为全局函数中的this对象指向window对象。</span><br><span class="hljs-title function_">getUserInput</span>(<span class="hljs-string">&quot;Barack&quot;</span>,<span class="hljs-string">&quot;Obama&quot;</span>,clientData.<span class="hljs-property">setUserName</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clientData,fullName);  <span class="hljs-comment">//Not Set</span><br><span class="hljs-comment">//fullName属性将在window对象中被初始化     </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">fullName</span>);  <span class="hljs-comment">//Barack Obama</span><br></code></pre></td></tr></table></figure>
<h4 id="使用Call和Apply函数来保存this"><a href="#使用Call和Apply函数来保存this" class="headerlink" title="使用Call和Apply函数来保存this"></a>使用<code>Call</code>和<code>Apply</code>函数来保存<code>this</code></h4><p>我们知道每个Javascript中的函数都有两个方法:<code>Call</code>和<code>Apply</code>。这些方法被用来设置函数内部的<code>this</code>对象以及给此函数传递变量。</p>
<p><code>call</code>接收的第一个参数为被用来在函数内部当做<code>this</code>的对象，传递给函数的参数被挨个传递（当然使用逗号分开）。<code>Apply</code>函数的第一个参数也是在函数内部作为<code>this</code>的对象，然而最后一个参数确是传递给函数的值的数组。</p>
<p>听起来很复杂，那么我们来看看使用<code>Apply</code>和<code>Call</code>有多么的简单。为了修复前面例子的问题，我将在👇下面你的例子中使用<code>Apply</code>函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//注意到我们增加了新的参数作为回调对象，叫做“callbackObj”</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUserInput</span>(<span class="hljs-params">firstName, lastName, callback, callbackObj</span>)&#123;<br>    <span class="hljs-comment">//在这里做些什么来确认名字</span><br>    <br>    <span class="hljs-comment">//apply</span><br>    callback.<span class="hljs-title function_">apply</span>(callbackObj, [firstName, lastName]);<br>    <span class="hljs-comment">//等价call</span><br>    <span class="hljs-comment">//callback.call(callbackObj, firstName, lastName);</span><br>&#125;<br><br><span class="hljs-comment">//我们将clientData.setUserName方法和clientData对象作为参数，clientData对象会被Apply方法使用来设置this对象     </span><br><span class="hljs-title function_">getUserInput</span>(<span class="hljs-string">&quot;Barack&quot;</span>, <span class="hljs-string">&quot;Obama&quot;</span>, clientData.<span class="hljs-property">setUserName</span>, clientData);<br><br><span class="hljs-comment">//clientData中的fullName属性被正确的设置</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(clientUser.<span class="hljs-property">fullName</span>); <span class="hljs-comment">//Barack Obama</span><br></code></pre></td></tr></table></figure>

<h4 id="回调地狱问题以及解决方案"><a href="#回调地狱问题以及解决方案" class="headerlink" title="回调地狱问题以及解决方案"></a>回调地狱问题以及解决方案</h4><p>在执行异步代码时，无论以什么顺序简单的执行代码，经常情况会变成许多层级的回调函数堆积以致代码变成下面的情形。这些杂乱无章的代码叫做回调地狱因为回调太多而使看懂代码变得非常困难。我从node-mongodb-native，一个适用于Node.js的MongoDB驱动中拿来了一个例子。这段位于下方的代码将会充分说明回调地狱：👇</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p_client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Db</span>(<span class="hljs-string">&#x27;integration_tests_20&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">27017</span>, &#123;&#125;), &#123;<span class="hljs-string">&#x27;pk&#x27;</span>:<span class="hljs-title class_">CustomPKFactory</span>&#125;);<br>    p_client.<span class="hljs-title function_">open</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, p_client</span>) &#123;<br>        p_client.<span class="hljs-title function_">dropDatabase</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, done</span>) &#123;<br>            p_client.<span class="hljs-title function_">createCollection</span>(<span class="hljs-string">&#x27;test_custom_key&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, collection</span>) &#123;<br>                collection.<span class="hljs-title function_">insert</span>(&#123;<span class="hljs-string">&#x27;a&#x27;</span>:<span class="hljs-number">1</span>&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, docs</span>) &#123;<br>                    collection.<span class="hljs-title function_">find</span>(&#123;<span class="hljs-string">&#x27;_id&#x27;</span>:<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectID</span>(<span class="hljs-string">&quot;aaaaaaaaaaaa&quot;</span>)&#125;, <span class="hljs-keyword">function</span>(<span class="hljs-params">err, cursor</span>) &#123;<br>                        cursor.<span class="hljs-title function_">toArray</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">err, items</span>) &#123;<br>                            test.<span class="hljs-title function_">assertEquals</span>(<span class="hljs-number">1</span>, items.<span class="hljs-property">length</span>);<br><br>                            <span class="hljs-comment">// Let&#x27;s close the db</span><br>                            p_client.<span class="hljs-title function_">close</span>();<br>                        &#125;);<br>                    &#125;);<br>                &#125;);<br>            &#125;);<br>        &#125;);<br>    &#125;);<br></code></pre></td></tr></table></figure>
<p>你应该不想在你的代码中遇到这样的问题，当你遇到了–你将会时不时的遇到这种情况–这里有关于这个问题的两种解决方案。</p>
<ol>
<li>给你的函数命名并传递它们的名字作为回调函数，而不是主函数的参数中定义匿名函数。</li>
<li>模块化L将你的代码分隔到模块中，这样你就可以到处一块代码来完成特定的工作。然后你可以在你的巨型应用中导入模块。</li>
</ol>
<p>Javascript回调函数非常美妙且功能强大，它为web应用和代码提供了诸多好处。我们应该在有需求时使用它，或者为了代码的抽象性、可维护性以及可读性而使用回调函数来重构你的代码。</p>
<p>本文译自<a href="http://javascriptissexy.com/understand-javascript-callback-functions-and-use-them/">understand Javascript callback functions and use them</a>，有删改。</p>
<hr>
<p>节选自：前端乱炖-<a href="http://www.html-js.com/article/1592">http://www.html-js.com/article/1592</a> 有删改
　
　</p>
<p>　</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>关于局部性原理</title>
    <url>/2018/06/25/branch_prediction/</url>
    <content><![CDATA[<p>因为之前一直在关注『<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513504&idx=1&sn=25dd6420e3056101dd3f6fdaedacaa2a&chksm=80d67a63b7a1f37572a5159ff6f53810467c15c8beec94770e8360c45f45036360d77755ee78&scene=21#wechat_redirect">码农翻身</a>』公众号，作者以很基础的文字构建关于计算机关于编程的小故事，由浅入深，，其中的知识点可以自己延伸阅读，还是非常不错的，很适合入门~后来，作者出书了，支持了一波，，毕竟纸质书翻起来比较方便。<br>OK，进入正题，，在『<a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513017&idx=1&sn=5550ee714abd36d0b580713f673e670b&scene=21#wechat_redirect">CPU阿甘</a>』中有提到『局部性原理』，，有必要延伸阅读下。网上找到了Stack Overflow中一篇文章-<a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array">Why is it faster to process a sorted array than an unsorted array?</a>-本文是对这篇文章的简单翻译，四级水平，还请多包涵 哈哈。</p>
<hr>
<h4 id="为什么排序后的数组比乱序的数组执行起来要快？"><a href="#为什么排序后的数组比乱序的数组执行起来要快？" class="headerlink" title="为什么排序后的数组比乱序的数组执行起来要快？"></a>为什么排序后的数组比乱序的数组执行起来要快？</h4><p>这是一段看起来非常奇怪的C++代码，因为某些原因，将数组排序之后奇迹般的将运行速度提高了将近六倍。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#include &lt;algorithm&gt;<br>#include &lt;ctime&gt;<br>#include &lt;iostream&gt;<br><br>int main()&#123;<br>    // 生成数据(数组)<br>    const unsigned arraySize = 32768;<br>    int data[arraySize];<br><br>    for (unsigned c = 0; c &lt; arraySize; ++c)<br>        data[c] = std::rand() % 256;<br><br>    // !!! 因为这一行代码，下边的循环运行的更快了<br>    std::sort(data, data + arraySize);<br><br>    // 测试<br>    clock_t start = clock();<br>    long long sum = 0;<br><br>    for (unsigned i = 0; i &lt; 100000; ++i)&#123;<br>        // Primary loop<br>        for (unsigned c = 0; c &lt; arraySize; ++c)&#123;<br>            if (data[c] &gt;= 128)<br>                sum += data[c];<br>        &#125;<br>    &#125;<br><br>    double elapsedTime = static_cast&lt;double&gt;(clock() - start) / CLOCKS_PER_SEC;<br><br>    std::cout &lt;&lt; elapsedTime &lt;&lt; std::endl;<br>    std::cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>如果没有<code>std::sort(data, data + arraySize);</code>(即数组数据大小乱序), 代码运行11.54秒。</li>
<li>数组元素排序之后，运行只用了1.93秒。</li>
</ul>
<p>起初，我以为这种现象与编程语言或者编译器什么的有关系，，所以，我把代码移植到Java中试了一下👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import java.util.Arrays;<br>import java.util.Random;<br><br>public class Main&#123;<br>    public static void main(String[] args)&#123;<br>        // Generate data<br>        int arraySize = 32768;<br>        int data[] = new int[arraySize];<br><br>        Random rnd = new Random(0);<br>        for (int c = 0; c &lt; arraySize; ++c)<br>            data[c] = rnd.nextInt() % 256;<br><br>        // !!! With this, the next loop runs faster<br>        Arrays.sort(data);<br><br>        // Test<br>        long start = System.nanoTime();<br>        long sum = 0;<br><br>        for (int i = 0; i &lt; 100000; ++i)&#123;<br>            // Primary loop<br>            for (int c = 0; c &lt; arraySize; ++c)&#123;<br>                if (data[c] &gt;= 128)<br>                    sum += data[c];<br>            &#125;<br>        &#125;<br><br>        System.out.println((System.nanoTime() - start) / 1000000000.0);<br>        System.out.println(&quot;sum = &quot; + sum);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果有点类似，但没有像在C++中差很多。</p>
<p>我刚开始想到的是把数组排序之后，将数组载入到内存中了，，转念一想，这忒蠢了，数组明明是刚生成的(一直在内存中)。</p>
<ul>
<li>到底发生了神马？</li>
<li>为什么排序后的数组比乱序时处理速度快很多？</li>
<li>代码中求和项是相对独立的，应该跟数组数据没什么关系。。(存疑)</li>
</ul>
<hr>
<h4 id="高票回答"><a href="#高票回答" class="headerlink" title="高票回答"></a>高票回答</h4><p><em>你可能是分支预测失败的受害者</em>。。</p>
<p>那么什么是分支预测呢？？</p>
<p>想象铁路的岔口，，👇<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/cf/Entroncamento_do_Transpraia.JPG/1600px-Entroncamento_do_Transpraia.JPG" alt="railroad junction"><br>@(Image by Mecanismo, via Wikimedia Commons. Used under the CC-By-SA 3.0 license.)</p>
<p>现在为了方便讨论，假想我们回到了19世纪，那时候还无法进行远距离无线通讯。</p>
<p>你作为这个岔路口的操作员，听到一辆货车正在驶来，但又完全不知道它想去哪条分支路线。这时，你示意货车停下来，问他你想去哪个方向，然后将开关设置为正确的位置。</p>
<p><em>火车很笨重，因为惯性的原因，它们在启动和停下来的时候通常要花很长时间。</em></p>
<p>有没有更好的办法嗫？(办法是)猜测它会去往哪个方向！</p>
<ul>
<li>如果你猜对了，它继续行驶~</li>
<li>如果你猜错了，火车司机会向你大喊大叫，让你重置开关，，然后TA重新启动，驶向另一方向。</li>
</ul>
<p><strong>如果你每次都猜对</strong>，火车就永远不需要停下来~<br><strong>如果你总是都猜错</strong>，火车会花费很长时间停下来，后退，重新启动。。</p>
<p><strong>把它看做一个 if 代码块</strong>：在芯片级别，这是一个分支指令👇<br><img src="https://i.stack.imgur.com/pyfwC.png" alt="if-statement"><br>作为一个处理器，你看到一个分支结构，，完全不知道它将要怎么运行？你怎么做？等判断条件先运行结束，然后根据正确的结果选择合适的分支运行。</p>
<p><em>现代处理器(通常)很复杂，有很长的流水线级数。所以，会像火车一样话很长的时间『启动』和『刹车』。</em></p>
<p>有没有更好的办法嗫？(答案是)猜测程序会运行哪个分支的代码。</p>
<ul>
<li>如果猜对了，程序继续执行~</li>
<li>如果猜错了，需要清空流水线(的所有任务)，回滚到分支结构开始的位置。然后重新启动执行另一个分支。</li>
</ul>
<p><strong>如果每次都猜对</strong>，你永远不需要被迫停下~<br><strong>如果总是猜错</strong>，你会花费很长时间减速，回滚，重启。。</p>
<p>这就是<strong>分支预测</strong>，，我承认这不是最好的比喻，因为火车可以用旗子作为指示方向的信号。但是在计算机中，处理器直到最后一刻才知道最终会运行哪个分支(的代码)。</p>
<p>那么，你如何策略性地猜测，以尽量减少火车必须后退才能才能驶向正确的方向的次数？观察过去的执行历史！如果99%的情况，火车都向驶向左侧，那么你(肯定)猜测(下一次)火车(同样)驶向左侧。如果它(驶向左侧或者右侧的情况)交替出现，那么你(根据情况)交替改变你的猜测。如果每三次就会驶向某一特定的方向，那么你也会据此作出合理的猜测..</p>
<p>换句话说，你试图抽象出一个模型并据此作出猜测。这或多或少是分支预测器的工作原理。</p>
<p>大多数应用程序具有良好表现(well-behaved 具体指什么??)的分支。所以现代分支预测器通常会达到大于90％的命中率。但是当面对不可识别的模型时，我们无法预测将要执行的分支，这时分支预测器实际上是毫无用处的。</p>
<p><strong>正如上边我们猜测的那样，罪魁祸首是这个if代码块</strong>👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">if (data[c] &gt;= 128)<br>    sum += data[c];<br></code></pre></td></tr></table></figure>

<p>我们可以注意到，数据均匀分布在0和255之间。数组中的所有元素排序之后，大致前半部分元素迭代时不会进入if语句。剩下后半部分的元素，它们将全部进入if语句。</p>
<p>分支连续多次走向相同的方向时，这对于分支预测器非常友好。即使是简单的饱和计数器也能正确预测分支，除了饱和后改变方向后的少数迭代。</p>
<p><strong>快速预览</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">T = branch taken<br>N = branch not taken<br><br>data[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...<br>branch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...<br><br>       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)<br></code></pre></td></tr></table></figure>

<p>但是，当数据是完全随机的时，分支预测器将无法发挥作用，因为它无法预测随机数据。因此，可能会有大约50％的预测失误。(比随机乱猜好不到哪而去..)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, 133, ...<br>branch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N  ...<br><br>       = TTNTTTTNTNNTTTN ...   (completely random - hard to predict)<br></code></pre></td></tr></table></figure>

<p><strong>那么，我们能做些什么呢？</strong></p>
<p>如果编译器无法将分支优化为条件转移(conditional move???)，那么如果您愿意为了提高性能而牺牲可读性，则可以尝试一些风骚的操作。<br>👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">if (data[c] &gt;= 128)<br>    sum += data[c];<br>    <br>// 将上面👆的代码修改为下面👇的，，<br><br>int t = (data[c] - 128) &gt;&gt; 31;<br>sum += ~t &amp; data[c];<br></code></pre></td></tr></table></figure>

<p>这样，用一些位操作代替分支(判断)。<br>(PS:需要注意的是，这种风骚的操作并不完全等同于原始的if语句。但在这个例子中，它对数据的所有输入值都有效[])。</p>
<p><strong>基于: Core i7 920 @ 3.5 GHz</strong></p>
<p>C++ - Visual Studio 2010 - x64 Release 👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//  Branch - Random<br>seconds = 11.777<br><br>//  Branch - Sorted<br>seconds = 2.352<br><br>//  Branchless - Random<br>seconds = 2.564<br><br>//  Branchless - Sorted<br>seconds = 2.587<br></code></pre></td></tr></table></figure>

<p>Java - Netbeans 7.1.1 JDK 7 - x64</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//  Branch - Random<br>seconds = 10.93293813<br><br>//  Branch - Sorted<br>seconds = 5.643797077<br><br>//  Branchless - Random<br>seconds = 3.113581453<br><br>//  Branchless - Sorted<br>seconds = 3.186068823<br></code></pre></td></tr></table></figure>

<ul>
<li>分支：排序后的数组与乱序的数组之间(执行速度)有巨大的差异。</li>
<li>风骚の操作：排序后的数组与乱序的数组之间(执行速度)无明显差异。</li>
<li>在C++中，排序后的数组用风骚的位操作甚至比分支预测有些慢。。</li>
</ul>
<p>一般情况下应该避免 data-dependent branching in critical loops. (such as in this example)</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>计算机系统</tag>
        <tag>branch prediction</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP连接的建立与释放</title>
    <url>/2017/10/19/establishment_release_of_tcp-connections/</url>
    <content><![CDATA[<h3 id="TCP-连接的建立与释放"><a href="#TCP-连接的建立与释放" class="headerlink" title="TCP 连接的建立与释放"></a>TCP 连接的建立与释放</h3><p>TCP 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP&#x2F;IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。</p>
<p>TCP 连接的三个阶段：</p>
<ol>
<li>连接建立。</li>
<li>数据传送。</li>
<li>连接释放。</li>
</ol>
<p>TCP 连接建立过程中要解决的问题：</p>
<ol>
<li>每一方能够确知对方的存在。</li>
<li>允许双方协商参数。如：Sequence Number初始值，最大窗口值，是否使用窗口扩大选项，是否使用时间戳选项，服务质量…</li>
<li>能够对运输实体资源进行分配。如：缓存大小，连接表中的项目…</li>
</ol>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131900-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP三次握手"></p>
<h4 id="建立TCP连接-三次握手"><a href="#建立TCP连接-三次握手" class="headerlink" title="建立TCP连接-三次握手"></a>建立TCP连接-三次握手</h4><ol>
<li>最初两端的 TCP 都处在 <code>CLOSED</code>状态。</li>
<li>**<code>B</code>*<em>的 TCP 服务器进程创建传输控制块 TCB，服务器进程进入LISTEN（收听）状态，等待客户的连接请求。<br>传输控制块：</em>Transmission Control Block,TCB*，存储连接中的信息。如：TCP 连接表，到发送和接收缓存的指针，到重传队列的指针，当前发送和接收序号…</li>
<li>**<code>A</code>**的 TCP 客户进程创建传输控制块 TCB ，向<code>B</code>发出连接请求报文段。这时，首部中同步位<code>SYN</code>&#x3D;1，初始序号<code>seq</code>&#x3D;x。<a href="#jump_SYN"><code>SYN</code></a>报文段不携带数据，但要消耗一个序号。TCP 客户进程进入<code>SYN-SENT</code>（同步已发送）状态。</li>
<li>**<code>B</code>**收到连接请求报文段，如果同意建立连接，则向A发送确认。确认报文段中，<code>SYN</code>和<code>ACK</code>都为1，确认号<code>ack</code>&#x3D;x+1，并选择自己的初始序号<code>seq</code>&#x3D;y。此报文段同样不携带数据，但要消耗一个序号。TCP服务器进程进入<code>SYN-RCVD</code>(同步接收)状态。</li>
<li>TCP 客户进程收到<code>B</code>的确认后，向<code>B</code>发出确认。确认报文段的<code>ACK</code>&#x3D;1，确认号<code>ack</code>&#x3D;y+1，自己的<code>seq</code>&#x3D;x+1。<code>ACK</code>报文段可携带数据，不携带数据则不消耗序号。TCP 连接已建立，<code>A</code>进入<code>ESTABLISHED</code>(已连接)状态。</li>
<li><code>B</code>收到<code>A</code>的确认，也进入<code>ESTABLISHED</code>状态。</li>
</ol>
<blockquote>
<p><strong>A 收到 B 的确认，为什么还要再次向 B 发送确认？</strong><br>为了防止已失效的连接请求报文段突然又传送到了服务端，而产生错误。</p>
</blockquote>
<p>举个栗子:</p>
<blockquote>
<p>A 向 B 发出连接请求报文段，如果 client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server 。本来这是一个早已失效的报文段，但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有请求建立连接，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用『三次握手』的办法可以防止上述现象发生。例如刚才那种情况， client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。<br><span align="center"> —— 谢希仁的《计算机网络》</span></p>
</blockquote>
<h4 id="释放TCP连接-四次挥手"><a href="#释放TCP连接-四次挥手" class="headerlink" title="释放TCP连接-四次挥手"></a>释放TCP连接-四次挥手</h4><p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131900-TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<ol>
<li>开始时，<code>A</code>和<code>B</code>都处在<code>ESTABLISHED</code>状态。</li>
<li><code>A</code>的应用进程向 TCP 发出连接释放连接报文段，停止发送数据，关闭 TCP 连接。<code>A</code>把报文段头部中<code>FIN</code>置为1，序号<code>seq</code>&#x3D;u，u是已传送的数据的最后一个字节序号加1。<code>A</code>进入<code>FIN-WAIT-1</code>状态，等待<code>B</code>的确认。<code>FIN</code>报文段即使不携带数据，也要消耗一个序号。</li>
<li><code>B</code>收到连接释放报文段向<code>A</code>发出确认，确认号<code>ack</code>&#x3D;u+1，<code>B</code>自己的序号是v，v是已传送过的数据的最后一个字节加1。<code>B</code>进入<code>CLOSE-WAIT</code>状态。TCP 服务器进程通知高层应用进程，从<code>A</code>到<code>B</code>的连接被释放。TCP 进入<code>half-close</code>状态。</li>
<li><code>A</code>收到<code>B</code>的确认，进入<code>FIN-WAIT-2</code>状态，等待<code>B</code>发出连接释放报文段。</li>
<li><code>B</code>应用进程通知 TCP 释放连接，报文段首部<code>FIN</code>&#x3D;1，序号为w（半关闭状态时B可能又发送了一些数据），<code>B</code>重复上次发送的确认号<code>ack</code>&#x3D;u+1。<code>B</code>进入<code>LAST-ACK</code>(最后确认)状态，等待<code>A</code>的确认。</li>
<li><code>A</code>收到<code>B</code>的连接释放报文段，向<code>B</code>发出确认。确认报文段中<code>ACK</code>&#x3D;1，确认号<code>ack</code>&#x3D;w+1，<code>A</code>自己的序号<code>seq</code>&#x3D;u+1(发送的<code>FIN</code>报文段使用一个序号)。<code>A</code>进入<code>TIME-WAIT</code>(时间等待)状态。</li>
<li>经过时间等待计时器（<em>TIME-WAIT timer</em>）设置的时间2 MSL 后，<code>A</code>进入<code>CLOSED</code>状态。<br>最长报文段寿命：<em>Maximum Segment Lifetime,MSL</em>，TCP 允许根据不同情况调整此值，RFC 793建议时间2分钟。</li>
<li><code>B</code>收到<code>A</code>的确认，进入<code>CLOSED</code>状态，撤销传输控制块 TCB，TCP 连接释放成功。</li>
</ol>
<p>对于4次挥手，其实是2次，因为 TCP 是全双工的。所以，发送方和接收方都需要<code>FIN</code>和<code>ACK</code>。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。<img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131900-TCP_%E4%B8%A4%E7%AB%AF%E5%90%8C%E6%97%B6%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5.png" alt="TCP两端同时断开连接"><br>@(TCP两端同时断开连接)</p>
<p><strong>A 为什么在 <em>TIME-WAIT</em> 状态等待2 MSL 时间?</strong><br>保证<code>A</code>发送的最后一个<a href="#jump_ACK"><code>ACK</code></a>报文段能够到达<code>B</code>。若此报文段丢失，处在<code>LAST-ACK</code>状态的<code>B</code>收不到<a href="#jump_FIN"><code>FIN</code></a>+<a href="#jump_ACK"><code>ACK</code></a>报文段的确认，<code>B</code>将超时重传<a href="#jump_FIN"><code>FIN</code></a>+<a href="#jump_ACK"><code>ACK</code></a>报文段，<code>A</code>可在2 MSL 时间内收到重传的<a href="#jump_FIN"><code>FIN</code></a>+<a href="#jump_ACK"><code>ACK</code></a>报文段。<code>A</code>重传确认，重新启动2MSL计时器，保证<code>A</code>和<code>B</code>顺利进入<code>CLOSED</code>状态，防止“已失效连接请求报文段”。<code>A</code>等待2 MSL，可使本连接持续时间内所产生的所有报文段全部从网络中消失。**</p>
<p><strong>什么是时间保活计时器？为什么设置时间保活计时器？</strong><br>时间保活计时器(<em>keepalive timer</em>)：服务器每收到一次数据，就重新设置保活计时器，时间2小时。超时后还未收到客户数据，服务器发送探测报文段，以后每隔75分钟发送一次。连续发送10个探测报文段客户仍无响应，服务器关闭 TCP 连接。<br>设置保活计时器的原因：处在 TCP 连接状态时，若<code>A</code>出现故障，防止<code>B</code>一直等待下去。</p>
<p><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131900-TCP%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="TCP有限状态机"><br>方框：TCP状态。<br>箭头：状态变迁。<br>箭头旁边的字：1.引起状态变迁的原因。2.发生状态变迁后出现的动作。<br>粗实线箭头：客户进程的正常变迁。<br>粗虚线箭头：服务器进程的正常变迁。<br>细线箭头：异常变迁。</p>
<h4 id="另外…"><a href="#另外…" class="headerlink" title="另外…"></a>另外…</h4><ol>
<li>关于建连接时SYN超时。试想一下，如果 serve r端接到了 clien 发的<code>SYN</code>后回了<code>SYN-ACK</code>后 client 掉线了，server 端没有收到 client 回来的<code>ACK</code>，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server 端如果在一定时间内没有收到的 TCP 会重发<code>SYN-ACK</code>。在 Linux 下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s &#x3D; 2^6 -1 &#x3D; 63s，TCP 才会把断开这个连接。</li>
<li>关于<em>SYN Flood</em> 攻击。一些恶意的人就为此制造了 <strong>SYN Flood攻击</strong>——给服务器发了一个<code>SYN</code>后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的<code>SYN</code>连接的队列耗尽，让正常的连接请求不能处理。于是，Linux 下给了一个叫 <code>tcp_syncookies</code> 的参数来应对这个事——当<code>SYN</code>队列满了后，TCP 会通过源地址端口、目标地址端口和时间戳打造出一个特别的 <code>Sequence Number</code> 发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 <code>SYN Cookie</code>发回来，然后服务端可以通过 cookie 建连接（即使你不在<code>SYN</code>队列中）。请注意，请先千万别用 <code>tcp_syncookies</code>来处理正常的大负载的连接的情况。因为，<code>SYN Cookies</code>是妥协版的 TCP 协议，并不严谨。对于正常的请求，你应该调整三个 TCP 参数可供你选择:<ol>
<li><code>tcp_synack_retries</code> 可以用他来减少重试次数；</li>
<li><code>tcp_max_syn_backlog</code>，可以增大SYN连接数；</li>
<li><code>tcp_abort_on_overflow</code> 处理不过来干脆就直接拒绝连接了。</li>
</ol>
</li>
<li>关于<code>ISN</code>的初始化。<code>ISN</code>是不能 hard code(硬编码)，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果 client 发了30个 segment 过去，但是网络断了，于是 client 重连，又用了1做<code>ISN</code>，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client 的Sequence Number 可能是3，而 Server 端认为client 端的这个号是30了。全乱了。RFC793中说，<code>ISN</code>会和一个假的时钟绑在一起，这个时钟会在每4微秒对<code>ISN</code>做加一操作，直到超过2^32，又从0开始。这样，一个<code>ISN</code>的周期大约是4.55个小时。因为，我们假设我们的 TCP Segment 在网络上的存活时间不会超过<em>Maximum Segment Lifetime</em>（缩写为<code>MSL</code> - Wikipedia语条），所以，只要<code>MSL</code>的值小于4.55小时，那么，我们就不会重用到<code>ISN</code>。</li>
<li>关于<code>MSL</code>和<code>TIME_WAIT</code>。通过上面的<code>ISN</code>的描述，相信你也知道<code>MSL</code>是怎么来的了。我们注意到，在 TCP 的状态图中，从<code>TIME_WAIT</code>状态到<code>CLOSED</code>状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了<code>MSL</code>为2分钟，Linux 设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成<code>CLOSED</code>状态呢？主要有两个原因：<ol>
<li><code>TIME_WAIT</code>确保有足够的时间让对端收到了<code>ACK</code>，如果被动关闭的那方没有收到<code>ACK</code>，就会触发被动端重发<code>FIN</code>，一来一去正好2个<code>MSL</code>;</li>
<li>有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《TIME_WAIT and its design implications for protocols and scalable client server systems》</li>
</ol>
</li>
</ol>
<hr>
<p>参考链接：<br><a href="http://www.imooc.com/article/17411">http://www.imooc.com/article/17411</a> 作者：江户川秋风<br><a href="http://www.jellythink.com/archives/705">http://www.jellythink.com/archives/705</a> 作者：果冻想<br><a href="http://www.cnblogs.com/lshs/p/6038458.html">http://www.cnblogs.com/lshs/p/6038458.html</a> 作者：lshs</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL逻辑查询语句执行顺序</title>
    <url>/2017/12/19/execution_sequence_of_sql/</url>
    <content><![CDATA[<h3 id="SQL逻辑查询语句执行顺序"><a href="#SQL逻辑查询语句执行顺序" class="headerlink" title="SQL逻辑查询语句执行顺序"></a>SQL逻辑查询语句执行顺序</h3><blockquote>
<p>转载自 <a href="http://www.jellythink.com/archives/924">SQL逻辑查询语句执行顺序</a> - by 果冻想</p>
</blockquote>
<p>测试表结构：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">CREATE TABLE table1<br> (<br>     customer_id VARCHAR(10) NOT NULL,<br>     city VARCHAR(10) NOT NULL,<br>     PRIMARY KEY(customer_id)<br> )ENGINE=INNODB DEFAULT CHARSET=UTF8;<br><br> CREATE TABLE table2<br> (<br>     order_id INT NOT NULL auto_increment,<br>     customer_id VARCHAR(10),<br>     PRIMARY KEY(order_id)<br> )ENGINE=INNODB DEFAULT CHARSET=UTF8;<br></code></pre></td></tr></table></figure>
<p>测试数据：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">INSERT INTO table1(customer_id,city) VALUES(&#x27;163&#x27;,&#x27;hangzhou&#x27;);<br> INSERT INTO table1(customer_id,city) VALUES(&#x27;9you&#x27;,&#x27;shanghai&#x27;);<br> INSERT INTO table1(customer_id,city) VALUES(&#x27;tx&#x27;,&#x27;hangzhou&#x27;);<br> INSERT INTO table1(customer_id,city) VALUES(&#x27;baidu&#x27;,&#x27;hangzhou&#x27;);<br><br> INSERT INTO table2(customer_id) VALUES(&#x27;163&#x27;);<br> INSERT INTO table2(customer_id) VALUES(&#x27;163&#x27;);<br> INSERT INTO table2(customer_id) VALUES(&#x27;9you&#x27;);<br> INSERT INTO table2(customer_id) VALUES(&#x27;9you&#x27;);<br> INSERT INTO table2(customer_id) VALUES(&#x27;9you&#x27;);<br> INSERT INTO table2(customer_id) VALUES(&#x27;tx&#x27;);<br> INSERT INTO table2(customer_id) VALUES(NULL);<br></code></pre></td></tr></table></figure>
<p>SQL逻辑查询测试语句👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#使用上述SQL查询语句来获得来自杭州，并且订单数少于2的客户。<br>SELECT a.customer_id, COUNT(b.order_id) as total_orders<br> FROM table1 AS a<br> LEFT JOIN table2 AS b<br> ON a.customer_id = b.customer_id<br> WHERE a.city = &#x27;hangzhou&#x27;<br> GROUP BY a.customer_id<br> HAVING count(b.order_id) &lt; 2<br> ORDER BY total_orders DESC;<br></code></pre></td></tr></table></figure>
<h4 id="SQL逻辑查询语句执行顺序-1"><a href="#SQL逻辑查询语句执行顺序-1" class="headerlink" title="SQL逻辑查询语句执行顺序"></a>SQL逻辑查询语句执行顺序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(7)     SELECT <br>(8)     DISTINCT &lt;select_list&gt;<br>(1)     FROM &lt;left_table&gt;<br>(3)     &lt;join_type&gt; JOIN &lt;right_table&gt;<br>(2)     ON &lt;join_condition&gt;<br>(4)     WHERE &lt;where_condition&gt;<br>(5)     GROUP BY &lt;group_by_list&gt;<br>(6)     HAVING &lt;having_condition&gt;<br>(9)     ORDER BY &lt;order_by_condition&gt;<br>(10)    LIMIT &lt;limit_number&gt;<br></code></pre></td></tr></table></figure>
<p>👆上面在每条语句的前面都标明了执行顺序号，不要问我怎么知道这个顺序的。我也是读各种“武林秘籍”才得知的，如果你有功夫，去阅读一下MySQL的源码，也会得出这个结果的。</p>
<p>好了，上面我标出了各条查询规则的执行先后顺序，那么各条查询语句是如何执行的呢？这就是我今天这篇博文的重点内容。Go on…</p>
<h4 id="执行FROM语句"><a href="#执行FROM语句" class="headerlink" title="执行FROM语句"></a>执行<code>FROM</code>语句</h4><p>在这些SQL语句的执行过程中，都会产生一个虚拟表，用来保存SQL语句的执行结果（这是重点），我现在就来跟踪这个虚拟表的变化，得到最终的查询结果的过程，来分析整个SQL逻辑查询的执行顺序和过程。</p>
<p>第一步，执行<code>FROM</code>语句。我们首先需要知道最开始从哪个表开始的，这就是<code>FROM</code>告诉我们的。现在有了<code>&lt;left_table&gt;</code>和<code>&lt;right_table&gt;</code>两个表，我们到底从哪个表开始，还是从两个表进行某种联系以后再开始呢？它们之间如何产生联系呢？——笛卡尔积</p>
<p>关于什么是笛卡尔积，请自行Google补脑。经过<code>FROM</code>语句对两个表执行笛卡尔积，会得到一个虚拟表，暂且叫VT1（vitual table 1），内容如下：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+----------+----------+-------------+<br>| customer_id | city     | order_id | customer_id |<br>+-------------+----------+----------+-------------+<br>| 163         | hangzhou |        1 | 163         |<br>| 9you        | shanghai |        1 | 163         |<br>| baidu       | hangzhou |        1 | 163         |<br>| tx          | hangzhou |        1 | 163         |<br>| 163         | hangzhou |        2 | 163         |<br>| 9you        | shanghai |        2 | 163         |<br>| baidu       | hangzhou |        2 | 163         |<br>| tx          | hangzhou |        2 | 163         |<br>| 163         | hangzhou |        3 | 9you        |<br>| 9you        | shanghai |        3 | 9you        |<br>| baidu       | hangzhou |        3 | 9you        |<br>| tx          | hangzhou |        3 | 9you        |<br>| 163         | hangzhou |        4 | 9you        |<br>| 9you        | shanghai |        4 | 9you        |<br>| baidu       | hangzhou |        4 | 9you        |<br>| tx          | hangzhou |        4 | 9you        |<br>| 163         | hangzhou |        5 | 9you        |<br>| 9you        | shanghai |        5 | 9you        |<br>| baidu       | hangzhou |        5 | 9you        |<br>| tx          | hangzhou |        5 | 9you        |<br>| 163         | hangzhou |        6 | tx          |<br>| 9you        | shanghai |        6 | tx          |<br>| baidu       | hangzhou |        6 | tx          |<br>| tx          | hangzhou |        6 | tx          |<br>| 163         | hangzhou |        7 | NULL        |<br>| 9you        | shanghai |        7 | NULL        |<br>| baidu       | hangzhou |        7 | NULL        |<br>| tx          | hangzhou |        7 | NULL        |<br>+-------------+----------+----------+-------------+<br></code></pre></td></tr></table></figure>
<p>总共有28（<code>table1</code>的记录条数 * <code>table2</code>的记录条数）条记录。这就是VT1👆的结果，接下来的操作就在VT1👆的基础上进行。</p>
<h4 id="执行ON过滤"><a href="#执行ON过滤" class="headerlink" title="执行ON过滤"></a>执行<code>ON</code>过滤</h4><p>执行完笛卡尔积以后，接着就进行<code>ON a.customer_id = b.customer_id</code>条件过滤，根据<code>ON</code>中指定的条件，去掉那些不符合条件的数据，得到VT2表👇，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+----------+----------+-------------+<br>| customer_id | city     | order_id | customer_id |<br>+-------------+----------+----------+-------------+<br>| 163         | hangzhou |        1 | 163         |<br>| 163         | hangzhou |        2 | 163         |<br>| 9you        | shanghai |        3 | 9you        |<br>| 9you        | shanghai |        4 | 9you        |<br>| 9you        | shanghai |        5 | 9you        |<br>| tx          | hangzhou |        6 | tx          |<br>+-------------+----------+----------+-------------+<br></code></pre></td></tr></table></figure>
<p>👆VT2就是经过<code>ON</code>条件筛选以后得到的有用数据，而接下来的操作将在VT2👆的基础上继续进行。</p>
<h4 id="添加外部行"><a href="#添加外部行" class="headerlink" title="添加外部行"></a>添加外部行</h4><p>这一步只有在连接类型为<code>OUTER JOIN</code>时才发生，如<code>LEFT OUTER JOIN</code>、<code>RIGHT OUTER JOIN</code>和<code>FULL OUTER JOIN</code>。在大多数的时候，我们都是会省略掉<code>OUTER</code>关键字的，但<code>OUTER</code>表示的就是外部行的概念。</p>
<p><code>LEFT OUTER JOIN</code>把左表记为保留表，得到的结果为：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+----------+----------+-------------+<br>| customer_id | city     | order_id | customer_id |<br>+-------------+----------+----------+-------------+<br>| 163         | hangzhou |        1 | 163         |<br>| 163         | hangzhou |        2 | 163         |<br>| 9you        | shanghai |        3 | 9you        |<br>| 9you        | shanghai |        4 | 9you        |<br>| 9you        | shanghai |        5 | 9you        |<br>| tx          | hangzhou |        6 | tx          |<br>| baidu       | hangzhou |     NULL | NULL        |<br>+-------------+----------+----------+-------------+<br></code></pre></td></tr></table></figure>
<p><code>RIGHT OUTER JOIN</code>把右表记为保留表，得到的结果为：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+----------+----------+-------------+<br>| customer_id | city     | order_id | customer_id |<br>+-------------+----------+----------+-------------+<br>| 163         | hangzhou |        1 | 163         |<br>| 163         | hangzhou |        2 | 163         |<br>| 9you        | shanghai |        3 | 9you        |<br>| 9you        | shanghai |        4 | 9you        |<br>| 9you        | shanghai |        5 | 9you        |<br>| tx          | hangzhou |        6 | tx          |<br>| NULL        | NULL     |        7 | NULL        |<br>+-------------+----------+----------+-------------+<br></code></pre></td></tr></table></figure>
<p><code>FULL OUTER JOIN</code>把左右表都作为保留表，得到的结果为：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+----------+----------+-------------+<br>| customer_id | city     | order_id | customer_id |<br>+-------------+----------+----------+-------------+<br>| 163         | hangzhou |        1 | 163         |<br>| 163         | hangzhou |        2 | 163         |<br>| 9you        | shanghai |        3 | 9you        |<br>| 9you        | shanghai |        4 | 9you        |<br>| 9you        | shanghai |        5 | 9you        |<br>| tx          | hangzhou |        6 | tx          |<br>| baidu       | hangzhou |     NULL | NULL        |<br>| NULL        | NULL     |        7 | NULL        |<br>+-------------+----------+----------+-------------+<br></code></pre></td></tr></table></figure>
<p>添加外部行的工作就是在VT2表的基础上添加保留表中被过滤条件过滤掉的数据，非保留表中的数据被赋予NULL值，最后生成虚拟表VT3。</p>
<p>由于我在准备的测试SQL查询逻辑语句中使用的是<code>LEFT JOIN</code>，过滤掉了以下这条数据：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">| baidu       | hangzhou |     NULL | NULL        |<br></code></pre></td></tr></table></figure>
<p>现在就把这条数据添加到VT2表中，得到的VT3表如下：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+----------+----------+-------------+<br>| customer_id | city     | order_id | customer_id |<br>+-------------+----------+----------+-------------+<br>| 163         | hangzhou |        1 | 163         |<br>| 163         | hangzhou |        2 | 163         |<br>| 9you        | shanghai |        3 | 9you        |<br>| 9you        | shanghai |        4 | 9you        |<br>| 9you        | shanghai |        5 | 9you        |<br>| tx          | hangzhou |        6 | tx          |<br>| baidu       | hangzhou |     NULL | NULL        |<br>+-------------+----------+----------+-------------+<br></code></pre></td></tr></table></figure>
<p>接下来的操作都会在该VT3表上进行。</p>
<h4 id="执行WHERE过滤"><a href="#执行WHERE过滤" class="headerlink" title="执行WHERE过滤"></a>执行<code>WHERE</code>过滤</h4><p>对添加外部行得到的VT3进行<code>WHERE</code>过滤，只有符合<code>&lt;where_condition&gt;</code>的记录才会输出到虚拟表VT4中。当我们执行<code>WHERE a.city = &#39;hangzhou&#39;</code>的时候，就会得到以下内容，并存在虚拟表VT4中：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+----------+----------+-------------+<br>| customer_id | city     | order_id | customer_id |<br>+-------------+----------+----------+-------------+<br>| 163         | hangzhou |        1 | 163         |<br>| 163         | hangzhou |        2 | 163         |<br>| tx          | hangzhou |        6 | tx          |<br>| baidu       | hangzhou |     NULL | NULL        |<br>+-------------+----------+----------+-------------+<br></code></pre></td></tr></table></figure>
<p>但是在使用WHERE子句时，需要注意以下两点：</p>
<ol>
<li>由于数据还没有分组，因此现在还不能在<code>WHERE</code>过滤器中使用<code>where_condition=MIN(col)</code>这类对分组统计的过滤；</li>
<li>由于还没有进行列的选取操作，因此在<code>SELECT</code>中使用列的别名也是不被允许的，如：<code>SELECT city as c FROM t WHERE c=&#39;shanghai&#39;;</code>是不允许出现的。</li>
</ol>
<h4 id="执行GROUP-BY分组"><a href="#执行GROUP-BY分组" class="headerlink" title="执行GROUP BY分组"></a>执行<code>GROUP BY</code>分组</h4><p><code>GROUP BY</code>子句主要是对使用<code>WHERE</code>子句得到的虚拟表进行分组操作。我们执行测试语句中的<code>GROUP BY a.customer_id</code>，就会得到以下内容：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+----------+----------+-------------+<br>| customer_id | city     | order_id | customer_id |<br>+-------------+----------+----------+-------------+<br>| 163         | hangzhou |        1 | 163         |<br>| baidu       | hangzhou |     NULL | NULL        |<br>| tx          | hangzhou |        6 | tx          |<br>+-------------+----------+----------+-------------+<br></code></pre></td></tr></table></figure>
<p>得到的内容会存入虚拟表VT5👆中，此时，我们就得到了一个VT5👆虚拟表，接下来的操作都会在该表上完成。</p>
<h4 id="执行HAVING过滤"><a href="#执行HAVING过滤" class="headerlink" title="执行HAVING过滤"></a>执行<code>HAVING</code>过滤</h4><p><code>HAVING</code>子句主要和<code>GROUP BY</code>子句配合使用，对分组得到的VT5虚拟表进行条件过滤。当我执行测试语句中的<code>HAVING count(b.order_id) &lt; 2</code>时，将得到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+----------+----------+-------------+<br>| customer_id | city     | order_id | customer_id |<br>+-------------+----------+----------+-------------+<br>| baidu       | hangzhou |     NULL | NULL        |<br>| tx          | hangzhou |        6 | tx          |<br>+-------------+----------+----------+-------------+<br></code></pre></td></tr></table></figure>
<p>👆这就是虚拟表VT6。</p>
<h4 id="SELECT列表"><a href="#SELECT列表" class="headerlink" title="SELECT列表"></a><code>SELECT</code>列表</h4><p>现在才会执行到<code>SELECT</code>子句，不要以为<code>SELECT</code>子句被写在第一行，就是第一个被执行的。</p>
<p>我们执行测试语句中的<code>SELECT a.customer_id, COUNT(b.order_id) as total_orders</code>，从虚拟表VT6中选择出我们需要的内容。我们将得到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+--------------+<br>| customer_id | total_orders |<br>+-------------+--------------+<br>| baidu       |            0 |<br>| tx          |            1 |<br>+-------------+--------------+<br></code></pre></td></tr></table></figure>
<p>不，还没有完，👆这只是虚拟表VT7。</p>
<h4 id="执行DISTINCT子句"><a href="#执行DISTINCT子句" class="headerlink" title="执行DISTINCT子句"></a>执行<code>DISTINCT</code>子句</h4><p>如果在查询中指定了<code>DISTINCT</code>子句，则会创建一张内存临时表（如果内存放不下，就需要存放在硬盘了）。这张临时表的表结构和上一步产生的虚拟表VT7是一样的，不同的是对进行<code>DISTINCT</code>操作的列增加了一个唯一索引，以此来除重复数据。<br>由于我的测试SQL语句中并没有使用DISTINCT，所以，在该查询中，这一步不会生成一个虚拟表。</p>
<h4 id="执行ORDER-BY子句"><a href="#执行ORDER-BY子句" class="headerlink" title="执行ORDER BY子句"></a>执行<code>ORDER BY</code>子句</h4><p>对虚拟表中的内容按照指定的列进行排序，然后返回一个新的虚拟表，我们执行测试SQL语句中的<code>ORDER BY total_orders DESC</code>，就会得到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">+-------------+--------------+<br>| customer_id | total_orders |<br>+-------------+--------------+<br>| tx          |            1 |<br>| baidu       |            0 |<br>+-------------+--------------+<br></code></pre></td></tr></table></figure>
<p>可以看到这是对<code>total_orders</code>列进行降序排列的。上述结果会存储在VT8👆中。</p>
<h4 id="执行LIMIT子句"><a href="#执行LIMIT子句" class="headerlink" title="执行LIMIT子句"></a>执行<code>LIMIT</code>子句</h4><p><code>LIMIT</code>子句从上一步得到的VT8虚拟表中选出从指定位置开始的指定行数据。对于没有应用<code>ORDER BY</code>的<code>LIMIT</code>子句，得到的结果同样是无序的，所以，很多时候，我们都会看到<code>LIMIT</code>子句会和<code>ORDER BY</code>子句一起使用。</p>
<p>MySQL数据库的LIMIT支持如下形式的选择：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">LIMIT n, m<br></code></pre></td></tr></table></figure>
<p>表示从第n条记录开始选择m条记录。而很多开发人员喜欢使用该语句来解决分页问题。对于小数据，使用LIMIT子句没有任何问题，当数据量非常大的时候，使用<code>LIMIT n, m</code>是非常低效的。因为LIMIT的机制是每次都是从头开始扫描，如果需要从第60万行开始，读取3条数据，就需要先扫描定位到60万行，然后再进行读取，而扫描的过程是一个非常低效的过程。所以，对于大数据处理时，是非常有必要在应用层建立一定的缓存机制（貌似现在的大数据处理，都有缓存哦）。各位，请期待我的缓存方面的文章哦。</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript执行顺序</title>
    <url>/2017/12/02/execution_sequence_of_javascript/</url>
    <content><![CDATA[<h3 id="JavaScript执行顺序"><a href="#JavaScript执行顺序" class="headerlink" title="JavaScript执行顺序"></a>JavaScript执行顺序</h3><p>JavaScript(以下简称js) 是一种<strong>描述型脚本语言</strong>，由浏览器进行动态的解析与执行。由于js编写位置比较灵活，所以处在不同位置的js代码执行顺序也是不同的。js和其他编程语言相比比较随意，所以js代码中充满各种奇葩的写法。苦逼的公司造就<del>苦逼程序员</del>全栈工程师，工作中总是经常自己写些简单的前端页面，经常被js的执行顺序袭扰，索性找个大块儿时间好好学习总结下，理解各型各色的写法，希望能对js的语言特性有深入的理解。</p>
<h4 id="函数的声明和调用"><a href="#函数的声明和调用" class="headerlink" title="函数的声明和调用"></a>函数的声明和调用</h4><p>函数的定义方式大体有以下两种，浏览器对于不同的方式有不同的解析顺序。 </p>
<ol>
<li>使用<code>function</code>关键字声明一个函数，再指定一个函数名，叫<strong>函数声明</strong>。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Fn1()&#123; <br>    alert(&quot;Hello World!&quot;); <br>&#125; <br></code></pre></td></tr></table></figure></li>
<li>使用<code>function</code>关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫<strong>函数表达式</strong>，这是最常见的函数表达式语法形式。<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var Fn2 = function()&#123; <br>    alert(&quot;Hello World!&quot;); <br>&#125; <br></code></pre></td></tr></table></figure>
如果遇到函数声明，则进行预处理(类似C语言的编译)；如果遇到函数表达式，则只是将函数赋值给一个变量，不进行预处理，待调用的时候再进行处理。<br>@(#函数声明)<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Fn1();<br>function Fn1()&#123;<br>    alert(&quot;Hello World!&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
👆↑ 这段代码()可以正常运行，弹出”Hello World!”警告对话框。浏览器对Fn1()进行了预处理，再从Fn1()；开始运行。</li>
</ol>
<p>再如：<br>@(#函数表达式)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Fn2();<br>var Fn2 = function()&#123;<br>    alert(&quot;Hello World!&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>👆↑ 这段代码会在Chrome浏览器报错，DevTools会提示<code> Uncaught TypeError: Fn2 is not a function</code>。浏览器未对Fn2进行预处理，依序执行，所以报错Fn2不是函数。</p>
<h4 id="js代码块及引用的外部js文件的处理"><a href="#js代码块及引用的外部js文件的处理" class="headerlink" title="js代码块及引用的外部js文件的处理"></a>js代码块及引用的外部js文件的处理</h4><p>这里js代码块指的是一对<code>&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;some js code&lt;/script&gt;</code>标签中间包裹着的js代码；外部引用的文件指的是<code>&lt;script src=&quot;/javascripts/application.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; async defer&gt;&lt;/script&gt;</code>中src属性中路径下的js文件中的代码。</p>
<p>页面加载过程中，浏览器会对每个js代码块或文件进行独立扫描。所以在一个块或文件中，函数可以先调用，再进行函数声明(<code>#函数声明</code>)；但两个块中，函数声明所在的块必须在函数调用所在的块之前。略绕，，看例子👇↓</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script type=&quot;text/javascript&quot;&gt;<br>    Fn();<br>&lt;/script&gt;<br><br>&lt;script type=&quot;text/javascript&quot;&gt;<br>function Fn()&#123;<br>    alert(&#x27;Hello World!&#x27;);<br>&#125;<br>&lt;/script&gt;<br>---------------------<br>//Uncaught ReferenceError: Fn is not defined<br>//报错 Fn 未被定义<br>//两个script代码块换下位置就可以正常运行了~<br>---------------------<br></code></pre></td></tr></table></figure>
<p>需要注意的是，外部引用的js文件也存在这种情况，，js文件中定义的变量和函数只能在之后引用。即js.js文件中以函数声明的方式定义了fn..👇↓</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script type=&#x27;text/javascript&#x27;&gt;<br>    fn();<br>&lt;/script&gt;<br>&lt;script scr=&#x27;tesTjs.js&#x27; type=&#x27;text/javascript&#x27;&gt;&lt;/script&gt;<br>---------------------<br>//Uncaught ReferenceError: fn is not defined<br>//报错 fn 未被定义<br>//两个script代码块换下位置就可以正常运行了<br>---------------------<br></code></pre></td></tr></table></figure>
<h4 id="重复定义函数会覆盖前面的定义"><a href="#重复定义函数会覆盖前面的定义" class="headerlink" title="重复定义函数会覆盖前面的定义"></a>重复定义函数会覆盖前面的定义</h4><p>这和变量的重复定义是一样的，，👇↓</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function fn()&#123; <br>    alert(1); <br>&#125; <br>function fn()&#123; <br>    alert(2); <br>&#125; <br>fn(); <br>// 弹出：“2”<br></code></pre></td></tr></table></figure>
<p>但如果是这样呢，，👇↓</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">fn(); <br>function fn()&#123; <br>    alert(1); <br>&#125; <br>function fn()&#123; <br>    alert(2); <br>&#125; <br>// 还是弹出：“2” <br></code></pre></td></tr></table></figure>
<h4 id="body标签内的onload属性与body标签之间函数的执行"><a href="#body标签内的onload属性与body标签之间函数的执行" class="headerlink" title="body标签内的onload属性与body标签之间函数的执行"></a>body标签内的onload属性与body标签之间函数的执行</h4><p>body内部的函数会先于onload的函数执行，测试代码：👇↓</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//html head... <br>&lt;script type=&quot;text/javascript&quot;&gt; <br>    function fnOnLoad()&#123; <br>        alert(&quot;I am outside the Wall!&quot;); <br>    &#125; <br>&lt;/script&gt; <br>&lt;body onload=&quot;fnOnLoad();&quot;&gt; <br>    &lt;script type=&quot;text/javascript&quot;&gt; <br>        alert(&quot;I am inside the Wall..&quot;); <br>    &lt;/script&gt; <br>&lt;/body&gt; <br>//先弹出“I am inside the Wall..”; <br>//后弹出“I am outside the Wall!” <br></code></pre></td></tr></table></figure>
<p><code>body</code>的<code>onload</code>事件触发条件是<code>body</code>内容加载完成，，所以在加载<code>body</code>内容的过程中执行了<code>&lt;script&gt;</code>标签中的<code>alert(&quot;I am inside the Wall..&quot;);</code>。至此<code>body</code>标签中的内容加载完成，触发<code>body</code>标签中<code>onload</code>函数，执行<code>fnOnLoad</code>方法。</p>
<h4 id="script标签放在什么位置"><a href="#script标签放在什么位置" class="headerlink" title="script标签放在什么位置"></a>script标签放在什么位置</h4><p>scripts会引发阻塞并行下载的问题。<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4">HTTP&#x2F;1.1 specification</a>建议每次不要同时从一个hostname下载超过两个的组件。如果你把网站上引用的图片放在不同hostname上，那么每次加载该网页时，可以下载同时两个以上的图片资源。然而，当引用的外部js文件正在下载时，无论其他资源是否与该js文件处于同一hostnamme，都不能(并行)下载。所以yahoo建议将script放在尾部，这样能加速网页加载。<a href="https://developer.yahoo.com/performance/rules.html#js_bottom">^1</a></p>
<p>将script放在尾部的缺点，是浏览器只能先解析完整个HTML页面，再下载JS。而对于一些高度依赖于JS的网页，就会显得慢了。所以将script放在尾部也不是最优解，最优解是一边解析页面，一边下载JS。<br>所以，出现了一种更modern的方式：使用async和defer。80%的现代浏览器都认识async和defer属性[3]，这两个属性能让浏览器做到一边下载JS(还是只能同时下载两个JS)，一边解析HTML。他的优点不是增加JS的并发下载数量，而是做到下载时不block解析HTML。<a href="https://stackoverflow.com/questions/436411/where-should-i-put-script-tags-in-html-markup">^2</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script type=&quot;text/javascript&quot; src=&quot;path/to/script1.js&quot; async&gt;&lt;/script&gt;  <br>&lt;script type=&quot;text/javascript&quot; src=&quot;path/to/script2.js&quot; async&gt;&lt;/script&gt;  <br></code></pre></td></tr></table></figure>
<p>带<code>async</code>属性的script会异步执行，只要下载完就执行，这会导致script2.js可能先于script1.js执行（如果script2.js比较大，下载慢）。<code>defer</code>就能保证script有序执行，script1.js先执行，script2.js后执行。</p>
<hr>
<p>参考链接：<br><a href="http://www.jb51.net/article/36755.htm">http://www.jb51.net/article/36755.htm</a><br><a href="https://developers.google.com/speed/docs/insights/BlockingJS">https://developers.google.com/speed/docs/insights/BlockingJS</a><br><a href="https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery">https://developers.google.com/speed/docs/insights/OptimizeCSSDelivery</a><br><a href="https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent">https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent</a></p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>存在主义心理动力学</title>
    <url>/2019/06/09/existential_psychodynamics/</url>
    <content><![CDATA[<p>以下内容节选自<a href="https://item.jd.com/11710889.html"><strong>『存在主义心理治疗』-欧文・D・亚隆</strong></a></p>
<hr>
<p>存在主义观点强调一种不同类型的基本冲突: 既不是与被压抑的本能抗争之间的冲突，也不是与内化了的成人之间的冲突。而是，<strong>在个体面对存在的既定事实时引发出来的冲突。而我所说的存在的“既定事实”，意指某些终极关怀、某些人之所以为人的必然特质。</strong></p>
<p><strong>怎样发现这些既定事实的性质？</strong>在某些意义上来说，这个任务并不困难。<strong>方法就是深度的个人反思。条件很简单：从充斥着我们每个人经验世界的日常琐事中抽离出来，给自己以独处、沉默、时间以及自由。</strong>如果我们能够清除或者“囊括”日常生活，如果我们对于自己在世界上的“处境”，对于我们的存在、我们的界限、我们的潜力进行深刻的反思，如果我们深入到所有层面的最底层，我们必然会面对存在的既定事实，面对“深度结构”，我之后将称之为“终极关怀”。这些反思过程常常为某些紧急体验所催化。这些常被称作“边缘”或者“临界”状态，包括如下体验：面对自己的死亡、面临某些重大不可逆转的决定或者某些深具意义的图式在眼前坍缩。</p>
<p>本书<strong>涉及四个终极关怀：死亡、自由、孤独和无意义。个体与这些生命真相的正面交锋，构成了存在主义动力性冲突的内容。</strong></p>
<p><strong>死亡。</strong>最显而易见的、最容易理解的终极关怀就是死亡。我们现在存在，但是总有一天，这种存在会终止。死亡将如期而至，没有逃脱之路。这是一个恐怖的真相，能引发我们巨大的恐惧。<strong>用斯宾诺莎的话来说，“每一事物都在尽力维持自身的存在”；而存在的一个核心冲突就是，对死亡必然性的意识与继续生存下去的愿望之间的张力。</strong></p>
<p><strong>自由。</strong>另一个相对来说不太容易理解的终极关怀是自由。一般来说我们都认为自由是一个毋庸置疑的积极概念。有史以来，人类不是一直都在渴望并为自由而奋斗吗？然而从终极层面来看，自由是与忧惧偶联在一起的。在存在的意义上，“自由”意味着外部结构的空白。与日常经验相反的是，人类并不是进入(和离开)一个拥有内在设计、高度结构化的宇宙。实际上，个体对他自己的世界、生活设计、选择以及行为负有全部责任–也就是说，个体是自己世界的创造者。“自由”在这种含义上，带有一种可怕的暗示：它意味着在我们所站立的地方并不坚实–什么都没有，是空的，无底深渊。所以，<strong>存在主义一个关键的动力性冲突就是，我们无根基的处境与我们对根基与结构的渴望之间的冲突。</strong></p>
<p><strong>存在性孤独。</strong>第三个种终极关怀是孤独–不是伴随着寂寞的人际性孤独，也不是个人内心的孤独(与自身的其他部分隔离)，而是一种根本性孤独–既与生命隔绝，也与世界隔绝–隔绝在所有其他孤独之下。<strong>无论我们之间变得有多么亲密无间，仍然存在一个最终无法逾越的鸿沟；我们每个人都是独自一人进入这种存在，同时也注定要独自离开。一方面是我们对自身绝对孤独的意识，另一方面是对接触、保护的渴望，以及成为一个更大整体的一部分的愿望，存在性冲突就是这两个方面之间的张力</strong>。</p>
<p><strong>无意义。</strong>第四个终极关怀或存在的既定事实是无意义。<strong>如果我们注定得死，如果我们构建我们自己的世界，如果每一个人最终都是独自一人深处于一个无关紧要的世界之中，那么生命有什么意义？我们为什么要活着？我们应该怎样活着？</strong>如果并不存在为我们预先设计的蓝图，那么我们每个人就必须构建自己的生命意义。然而，一个人自己创造出来的意义能否坚强到令其容忍生活？人类这种寻找意义的生物，却被投入到本身无意义的宇宙之中，于是，存在的动力性冲突便从进退维谷的境地中滋生出来。</p>
<hr>
<p>不止听一个人说过，哲学要浅尝辄止。好像的确是这样，，浅尝辄止，哲学帮我们构建更独立的思考方式，而这种思考方式让我们保持自我，不会流于众人。然而，哲学再往深处，便是深渊。这深渊便是虚无主义，像上面提到的『无意义』。无数个周末午休的后醒来，惊讶于周末的无所事事与时间的悄然流逝–周末午后的贤者模式。唯有读书、写代码、看电影或者其他的沉浸式活动让人暂时从虚无主义中回过头来，沾沾烟火气，我还活着，接地气的活着。</p>
<p>这四个终极关怀中，，死亡于我，并不可怕。只希望 <strong>骄傲的人应该死于一场意外，让一切都猝不及防</strong>。事实上，在某种程度，我甚至有些期待：死亡是多么难得的一次经历！难得到一生只能经历一次。上面也有提到『反思过程常常被某些紧急体验所催化』，死亡便是其中之一。我想，在哪个临界点，我们一定『会像放电影一样，人生过往历历在目』。那一刻，完美的人生应该说出一句话，，『这辈子，没遇到一个坏人』。</p>
<p>自由于我，，接触到哲学之后，便认识到完美的自由是相对的。所以，很能理解为什么要有文化审查，为什么要在互联网世界中修建长城，，诸如此类。当然，也有痛苦：我还有好多欲望，欲望让人变得不那么自由。</p>
<p>孤独于我，，已经试验性的独自生活了一年多。一天中，有16h+的时间，我是满意的。唯有独自下班到回家这期间会有些，，孤独。也不是不能忍受，毕竟只有那么一小段。我还可以通过哪些沉浸式的活动，让自己活在自己的世界中，活在云端。偶尔，偶尔也会有那么一个念头：来块儿黑客帝国中的牛排也不错喔~(这块牛排真的太诱人了，满足了我对牛排的所有美好想象[彪眼泪])。</p>
<p>无意义，，呐，这个就可怕多了。深渊，我害怕的深渊。如果有一天我决定结束自己的生命(短期内应该预见不到这一天)，那一定是因为这个原因。之所以，读这本书，也是因为不想放弃治疗。周末午后的贤者模式还是回来，希望能从这本书当中，找到一些答案。第十五页中有提到：</p>
<blockquote>
<p>要处理生命中无情存在的事实，只有两种方法–对真相感到焦虑，或者否认–而两者都令人不快。塞万提斯借着不朽的堂吉诃德之口说出了这个问题：“你要做疯狂的智者，还是健全的蠢货？”<br>存在主义的治疗立场拒绝这种两难，托马斯・哈代说：“如果有变得更好的方法，就是彻底看一看最坏的情形。”这句话对我将要描述的治疗方法是个很好的写照。</p>
</blockquote>
<blockquote>
<p>– 有删改</p>
</blockquote>
<p>至此，，好期待呢~</p>
]]></content>
      <categories>
        <category>Quote</category>
      </categories>
      <tags>
        <tag>存在主义心理治疗</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析MySQL中exists与in的使用</title>
    <url>/2017/12/19/exists-and-in_in_MySQL/</url>
    <content><![CDATA[<h3 id="浅析MySQL中exists与in的使用"><a href="#浅析MySQL中exists与in的使用" class="headerlink" title="浅析MySQL中exists与in的使用"></a>浅析MySQL中exists与in的使用</h3><blockquote>
<p>转载自 <a href="http://sunxiaqw.blog.163.com/blog/static/990654382013430105130443/">浅析MySQL中exists与in的使用</a> - by Franklin</p>
</blockquote>
<h4 id="exists"><a href="#exists" class="headerlink" title="exists"></a><code>exists</code></h4><p><code>exists</code>对外表用loop逐条查询，每次查询都会查看<code>exists</code>的条件语句，当<code>exists</code>里的条件语句能够返回记录行时(无论记录行是的多少，只要能返回)，条件就为真，返回当前loop到的这条记录;反之如果<code>exists</code>里的条 件语句不能返回记录行，则当前loop到的这条记录被丢弃，<code>exists</code>的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为 false</p>
<p>如下：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from user where exists (select 1);<br></code></pre></td></tr></table></figure>
<p>对user表的记录逐条取出，由于子条件中的<code>select 1</code>永远能返回记录行，那么user表的所有记录都将被加入结果集，所以与 <code>select * from user;</code>是一样的。</p>
<p>又如下👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from user where exists (select * from user where userId = 0);<br></code></pre></td></tr></table></figure>
<p>可以知道对user表进行loop时，检查条件语句<code>(select * from user where userId = 0)</code>,由于userId永远不为0[^1]，所以条件语句永远返回空集，条件永远为false，那么user表的所有记录都将被丢弃。</p>
<p><code>not exists</code>与<code>exists</code>相反，也就是当<code>exists</code>条件有结果集返回时，loop到的记录将被丢弃，否则将loop到的记录加入结果集。</p>
<p>总的来说，如果A表有n条记录，那么exists查询就是将这n条记录逐条取出，然后判断n遍<code>exists</code>条件。</p>
<h4 id="in"><a href="#in" class="headerlink" title="in"></a><code>in</code></h4><p><code>in</code>查询相当于多个or条件的叠加，这个比较好理解，比如下面的查询👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from user where userId in (1, 2, 3);<br><br>等效于👇<br>select * from user where userId = 1 or userId = 2 or userId = 3;<br></code></pre></td></tr></table></figure>
<p><code>not in</code>与<code>in</code>相反，如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from user where userId not in (1, 2, 3);<br><br>等效于👇<br>select * from user where userId != 1 and userId != 2 and userId != 3;<br></code></pre></td></tr></table></figure>
<p>总的来说，<code>in</code>查询就是先将子查询条件的记录全都查出来，假设结果集为B，共有m条记录，然后在将子查询条件的结果集分解成m个，再进行m次查询。</p>
<p>值得一提的是，**<code>in</code>查询的子条件返回结果必须只有一个字段**，例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from user where userId in (select id from B);<br></code></pre></td></tr></table></figure>
<p>而不能是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from user where userId in (select id, age from B);<br></code></pre></td></tr></table></figure>
<p>而exists就没有这个限制。</p>
<h4 id="exists和in的性能"><a href="#exists和in的性能" class="headerlink" title="exists和in的性能"></a><code>exists</code>和<code>in</code>的性能</h4><p>考虑如下SQL语句:👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1: select * from A where exists (select * from B where B.id = A.id);<br><br>2: select * from A where A.id in (select id from B);<br></code></pre></td></tr></table></figure>
<p>查询1.可以转化以下伪代码，便于理解👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">for ($i = 0; $i &lt; count(A); $i++) &#123;<br>　　$a = get_record(A, $i); #从A表逐条获取记录<br>　　if (B.id = $a[id])&#123; #如果子条件成立<br>　　　　$result[] = $a;<br>　　&#125;<br>&#125;<br>return $result;<br></code></pre></td></tr></table></figure>
<p>大概就是这么个意思，其实可以看到,查询1主要是用到了B表的索引，A表如何对查询的效率影响应该不大。</p>
<p>假设B表的所有id为1,2,3,查询2可以转换为👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from A where A.id = 1 or A.id = 2 or A.id = 3;<br></code></pre></td></tr></table></figure>
<p>这个好理解了，这里主要是用到了A的索引，B表如何对查询影响不大。</p>
<p>下面再看<code>not exists</code> 和 <code>not in</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1. select * from A where not exists (select * from B where B.id = A.id);<br><br>2. select * from A where A.id not in (select id from B);<br></code></pre></td></tr></table></figure>
<p>看查询1，还是和上面一样，用了B的索引。而对于查询2，可以转化成如下语句👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select * from A where A.id != 1 and A.id != 2 and A.id != 3;<br></code></pre></td></tr></table></figure>
<p>可以知道<code>not in</code>是个范围查询，这种!&#x3D;的范围查询无法使用任何索引,等于说A表的每条记录，都要在B表里遍历一次，查看B表里是否存在这条记录,<br>故<code>not exists</code>比<code>not in</code>效率高。</p>
<p>mysql中的in语句是把外表和内表作<code>hash</code>连接，而<code>exists</code>语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为<code>exists</code>比<code>in</code>语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p>
<p>如果查询的两个表大小相当，那么用in和exists差别不大; 如果两个表中一个较小，一个是大表，则<strong>子查询表大的用exists，子查询表小的用in</strong>:<br>例如：表A（小表），表B（大表）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 效率低，用到了A表上cc列的索引；<br>select * from A where cc in (select cc from B);<br><br># 效率高，用到了B表上cc列的索引;<br>select * from A where exists(select cc from B where cc=A.cc);<br><br># 效率高，用到了B表上cc列的索引； <br>select * from B where cc in (select cc from A);<br><br># 效率低，用到了A表上cc列的索引。<br>select * from B where exists(select cc from A where cc=B.cc);<br></code></pre></td></tr></table></figure>

<p><code>not in</code>和<code>not exists</code>如果查询语句使用了<code>not in</code>那么内外表都进行全表扫描，没有用到索引；而<code>not extsts</code>的子查询依然能用到表上的索引。所以<strong>无论哪个表大，用<code>not exists</code>都比<code>not in</code>要快</strong>。 </p>
<h5 id="in与-的区别"><a href="#in与-的区别" class="headerlink" title="in与=的区别"></a><code>in</code>与<code>=</code>的区别</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">select name from student where name in (&#x27;zhang&#x27;,&#x27;wang&#x27;,&#x27;li&#x27;,&#x27;zhao&#x27;);<br><br>等效于👇<br>select name from student where name=&#x27;zhang&#x27; or name=&#x27;li&#x27; or name=&#x27;wang&#x27; or name=&#x27;zhao&#x27;;<br></code></pre></td></tr></table></figure>

<p>[^1]: 其实user_id是可以为0的。在 Mysql <code>sql_mode</code> 中 添加 <code>NO_AUTO_VALUE_ON_ZERO</code>。</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>exist</tag>
        <tag>in</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/10/02/hello_world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>diary</tag>
      </tags>
  </entry>
  <entry>
    <title>立即执行函数表达式(IIFE)</title>
    <url>/2017/12/10/immediately-invoked_function_expression(IIFE)/</url>
    <content><![CDATA[<h3 id="立即执行函数表达式-IIFE"><a href="#立即执行函数表达式-IIFE" class="headerlink" title="立即执行函数表达式(IIFE)"></a>立即执行函数表达式(IIFE)</h3><blockquote>
<p>原文：<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression (IIFE)</a> by Ben Alman</p>
</blockquote>
<p>以防你没有注意到，(事先声明)我是一个对于专业术语有些坚持的人。所以，当我多次听到流行却易产生误解的术语「自执行匿名函数」，最终决定将的想法总结到这篇文章中。</p>
<p>除此之外，为了提供一些更深入更彻底的关于这种模式是如何工作的，事实上我还建议了我们应该怎样称呼这种模式。另外，如果你想跳过这里，你可以直接阅读<a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/#iife">立即调用函数表达式</a>，但是我建议你读完整篇文章。</p>
<p>你需要知道的是，这篇文章不是想说「我是对了，你是错的」之类的。我发自真心地想帮助人们理解这有点儿复杂的概念，并且我认为使用前后一致的精确术语是有助于人们理解的最简单的方式之一。</p>
<h4 id="所以，它到底是什么"><a href="#所以，它到底是什么" class="headerlink" title="所以，它到底是什么"></a>所以，它到底是什么</h4><p>在JavaScript里，每个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">函数</a>，当被调用时，都会创建一个新的执行环境。因为在函数里定义的变量和函数只能在函数内部被访问，外部无法获取；这种情况下，调用函数提供了一个非常简单的方法创建私有变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 因为这个函数的返回值是另一个能通过i访问私有变量的函数，(privileged)？</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeCounter</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//i只能从`makeConuter`内部访问</span><br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(++i);<br>    &#125;;   <br>&#125;<br><span class="hljs-comment">// `counter`和`counter2`都有自己作用域中的变量 `i`</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-title function_">makeCounter</span>();<br><span class="hljs-title function_">counter</span>(); <span class="hljs-comment">//1</span><br><span class="hljs-title function_">counter</span>(); <span class="hljs-comment">//2</span><br><br><span class="hljs-keyword">var</span> counter2 = <span class="hljs-title function_">makeCounter</span>();<br><span class="hljs-title function_">counter2</span>(); <span class="hljs-comment">//1</span><br><span class="hljs-title function_">counter2</span>(); <span class="hljs-comment">//2</span><br><br><span class="hljs-comment">// ReferenceError: i is not defined(它只存在于makeCounter里)</span><br></code></pre></td></tr></table></figure>
<p>在许多情况下，你可能并不需要由<code>makeWhatever</code>返回的多个实例，使用单例模式就可以实现。或者在其他情况中，你甚至不需要返回值。</p>
<h4 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h4><p>现在，无论你以<code>function foo()&#123;&#125;</code>的方式，还是<code>var foo = function()&#123;&#125;</code>的方式声明函数，你都可以在后边加上括号(圆括号,())来调用它们，，比如<code>foo();</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 像下面这样定义的函数可以通过在函数名后加一对括号进行调用，像这样`foo()`，因为foo只是函数表达式`function()&#123;/* code */&#125;`的一个引用变量；</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;<br><br><span class="hljs-comment">//那这说明函数表达式可以通过在它自己后面加上一对括号就可以自己调用自己了吗？</span><br><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">/* code */</span>&#125;();<span class="hljs-comment">//SyntaxError: Unexpected token (</span><br></code></pre></td></tr></table></figure>
<p>正如你所看到的，这里捕获了一个异常。当圆括号在全局环境或函数内部遇到<code>function</code>关键字，它会被默认当作一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/function">函数声明</a>，而不是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError">语法错误</a>，因为函数声明需要一个名字。</p>
<h4 id="题外话：函数、圆括号和错误"><a href="#题外话：函数、圆括号和错误" class="headerlink" title="题外话：函数、圆括号和错误"></a>题外话：函数、圆括号和错误</h4><p>有趣的是，如果你为一个函数指定一个名字并在它后面放一对圆括号，同样的也会抛出错误，但这次是因为另外一个原因。当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个(组?)运算符(用来控制运算优先级)。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">/* code */</span> &#125;();<br><span class="hljs-comment">//👆SyntaxError: Unexpected token</span><br><br><span class="hljs-comment">// 现在，你把一个表达式放在圆括号里，没有抛出错误...但是函数也并没有执行，因为：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 它等同于如下，一个函数声明跟着一个完全没有关系的表达式:</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;<br>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>关于这个细节，你可以阅读Dmitry A. Soshnikov的文章：<a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#question-about-surrounding-parentheses">ECMA-262-3 in detail. Chapter 5. Functions</a></p>
</blockquote>
<h4 id="立即执行函数表达式-IIFE-1"><a href="#立即执行函数表达式-IIFE-1" class="headerlink" title="立即执行函数表达式(IIFE)"></a>立即执行函数表达式(IIFE)</h4><p>幸运的是，修正语法错误很简单。最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在JavaScript里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了 <code>function</code>关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。注意理解这里的圆括号和上面的圆括号遇到函数时的表现是不一样的，也就是说。</p>
<ul>
<li>当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。</li>
<li>当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;());<br><span class="hljs-comment">//👆Crockford recommends this one</span><br><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;)();<br><span class="hljs-comment">//👆But this one works just as well</span><br><br><span class="hljs-comment">// 因为括号的作用就是为了消除函数表达式和函数声明之间的差异</span><br><span class="hljs-comment">// 如果解释器能预料到这是一个表达式，括号可以被省略</span><br><span class="hljs-comment">// 不过请参见下面的「重要笔记」</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;&#125;();<br><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/*code*/</span>&#125;();<br><span class="hljs-number">0</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;();<br><br><span class="hljs-comment">//如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节</span><br>!<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;();<br>~<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;();<br>-<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;();<br>+<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;();<br><br><span class="hljs-comment">// 这里是另外一种方法</span><br><span class="hljs-comment">// 我（原文作者）不清楚new方法是否会影响性能</span><br><span class="hljs-comment">// 但它却是奏效，参见http://twitter.com/kuvos/status/18209252090847232</span><br><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">/* code */</span> &#125;<br><span class="hljs-keyword">new</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">/* code */</span> &#125;() <br><span class="hljs-comment">// 👆只有当传入参数时才需要加括号</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="关于括号的重要须知"><a href="#关于括号的重要须知" class="headerlink" title="关于括号的重要须知"></a>关于括号的重要须知</h4><p>在一些情况下，当围绕在函数表达式周围的额外用来消除歧义的括号是没必要的（因为这时候的括号已经将其作为一个表达式去表达了），但它被当做约定俗成习惯时，仍然是一个好主意。</p>
<p>这样的括号指明函数表达式将会被立即调用，并且变量将会储存函数的结果，而不是函数本身。当这是一个非常长的函数表达式时，这可以节约其他人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。</p>
<p>作为规则，当你书写没有歧义的代码时候，有必要阻止JavaScript解释器抛出错误；这同样很公平，可以避免让其他开发者写出抛出异常<code>WTFError</code>的代码影响到你!</p>
<h4 id="保存闭包的状态"><a href="#保存闭包的状态" class="headerlink" title="保存闭包的状态"></a><span id='iife'>保存闭包的状态</h4><p>就像当函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被传递。一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为<strong>任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量（这种关系被叫做闭包）</strong>。</p>
<blockquote>
<p>关于闭包的更多信息，参见 <a href="http://skilldrick.co.uk/2011/04/closures-explained-with-javascript/">Closures explained with JavaScript</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/ /它的运行原理可能并不像你想的那样，因为`i`的值从来没有被锁定。相反的，每个链接，当被点击时(for循经执行完毕之后)，因此会弹出所有元素的总数(elems.length)，因为这是`i`此时的真实值。<br>var elems = document.getElementsByTagName(&#x27;a&#x27;);<br>for(var i = 0;i &lt; elems.length; i++ ) &#123;<br>    elems[i].addEventListener(&#x27;click&#x27;,function(e)&#123;<br>        e.preventDefault();<br>        alert(&#x27;I am link #&#x27; + i)<br>    &#125;,false);<br>&#125;<br>// 2018-01-27 更，编者按，，简单点说，因为在ES5中，只有(用var声明的变量)在函数中才有作用域。所以在for循环中用变量i属于for循环外，而不是for循环的&#123;&#125;中。同时，for循环又是一个同步事件，循环体中的监听事件是异步事件，异步事件处于 event loop 中，要等到所有同步事件执行完成之后，才会执行event loop 中的事件，，而那个时候，i 已然等于elems.length了。<br><br>// 而像下面这样改写就可以了，，因为在IIFE里，`i`值被锁定在了`lockedInIndex`里。在循环执行结束后，尽管`i`值的数值是所有元素的总和(elems.length)，但每一次函数表达式被调用时，IIFE里的`lockedInIndex`值都是`i`传给它的值,所以当链接被点击时，正确的值被弹出。<br>var elems = document.getElementsByTagName(&#x27;a&#x27;);<br>for(var i = 0;i &lt; elems.length;i++) &#123;<br>    (function(lockedInIndex)&#123;<br>        elems[i].addEventListener(&#x27;click&#x27;,function(e)&#123;<br>            e.preventDefault();<br>            alert(&#x27;I am link #&#x27; + lockedInIndex);<br>        &#125;,false)<br>    &#125;)(i);<br>    // 2018-01-27 更，编者按，，在上边我们说了，在javascript中只有函数才有作用域，所以，，要想把 i 的作用于独立出来，需要用函数的方式，所以，用闭包。<br>&#125;<br><br>//你同样可以像下面这样使用IIFE，仅仅只用括号包裹点击处理函数，并不包含整个`addEventListener`。无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子可读性更好些<br>var elems = document.getElementsByTagName( &#x27;a&#x27; );<br>for ( var i = 0; i &lt; elems.length; i++ ) &#123;<br>    elems[ i ].addEventListener( &#x27;click&#x27;, (function( lockedInIndex )&#123;<br>        return function(e)&#123;<br>            e.preventDefault();<br>            alert( &#x27;I am link #&#x27; + lockedInIndex );<br>        &#125;;<br>    &#125;)( i ),false);<br>&#125;<br><br>// 2018-01-27 更，编者按，，另外，在ES5 中只有一种声明变量的方式，就是使用 var 关键字，然而用它声明的字面量只有在函数中才有作用域概念。然而在 ES6 中，有了 let 关键字，，let 关键字声明的变量没有变量提升，不能在同一个作用域中用let关键字声明同意个变量两次，而且有了明确的作用域概念！！！所以，在上边的例子中，我们可以把 for 循环中的 var 关键字直接改为 let，闭包什么的不需要！完美解决。<br></code></pre></td></tr></table></figure>

<p>记住，在这最后两个例子里，<code>lockedInIndex</code>可以没有任何问题的访问i,但是作为函数的参数使用一个不同的命名标识符可以使概念更加容易的被解释。</p>
<p>立即执行函数一个最显著的优势是就算它没有命名或者说是匿名，函数表达式也可以在没有使用标识符的情况下被立即调用，一个闭包也可以在没有当前变量污染的情况下被使用。</p>
<h4 id="「自执行匿名函数-Self-executing-anonymous-function-」有什么问题呢？"><a href="#「自执行匿名函数-Self-executing-anonymous-function-」有什么问题呢？" class="headerlink" title="「自执行匿名函数(Self-executing anonymous function)」有什么问题呢？"></a>「自执行匿名函数(Self-executing anonymous function)」有什么问题呢？</h4><p>你看到它已经被提到好几次了，但它仍未被清楚地解释，我提议将术语改成”<strong>Immediately-Invoked Function Expression</strong>“，或者，<strong>IIFE</strong>，如果你喜欢缩写的话（发音类似“iffy”）。The pronunciation “<a href="https://forvo.com/word/iffy/">iffy</a>“ was suggested to me, and I like it, so let’s go with that.</p>
<p>什么是<strong>Immediately-Invoked Function Expression</strong>呢？顾名思义，它就是一个被立即调用的函数表达式。Just like the name would lead you to believe.</p>
<p>我想JavaScript社区的成员应该可以在他们的文章里或者陈述里接受术语<strong>Immediately-Invoked Function Expression</strong>和<strong>IIFE</strong>，因为我感觉这样更容易让这个概念被理解，并且<strong>self-executing anonymous function</strong>真的也的确不够准确。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 下面是个自执行函数，递归调用自己本身</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title function_">foo</span>();&#125;;<br><br><span class="hljs-comment">// 这是一个自执行匿名函数。因为它没有标识符，它必须是使用`arguments.callee`(which specifies the currently executing function 特指刚刚执行过的函数)属性来调用它自己</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>();&#125;;<br><br><span class="hljs-comment">// 这也许算是一个自执行匿名函数，但是仅仅当`foo`标识符作为它的引用时，如果你将foo换成用其他的什么名字(something else),你会获得一个 &quot;used-to-self-execute&quot; 匿名函数.</span><br><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title function_">foo</span>();&#125;;<br><br><span class="hljs-comment">// 有些人像这样叫&#x27;self-executing anonymous function&#x27;下面的函数,即使它不是自执行的，因为它并没有调用它自己。然后，它只是被立即调用了而已。</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-comment">/*code*/</span> &#125;());<br><br><span class="hljs-comment">// 为函数表达式增加标识符(也就是说创造一个命名函数)对我们的调试会有很大帮助。一旦命名，函数将不再匿名。</span><br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-comment">/* code */</span>&#125;());<br><br><span class="hljs-comment">// IIFEs同样也可以自执行，尽管，也许他不是最有用的模式</span><br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>();&#125;())<br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-title function_">foo</span>();&#125;())<br><br><span class="hljs-comment">// 另外，下面这个表达式竟会在黑莓5上抛出错误，在一个被命名的函数中，该函数名是undefined。Awesome, huh?</span><br>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <span class="hljs-title function_">foo</span>(); &#125;());<br></code></pre></td></tr></table></figure>
<p>希望上面的例子可以让你更加清楚的知道’self-executing’这个说法是有些误导性的，因为它并不是执行自己的函数，即使函数已经被执行。同样的，匿名属性也没用必要特别指出，因为，<strong>Immediately Invoked Function<br>Expression</strong>，既可以是命名函数也可以匿名函数。</p>
<blockquote>
<p>有趣的是：因为arguments.callee在ECMAScript 5 strict mode中被deprecated了，所以在ES5的<code>strict mode</code>中实际上不可能创建一个<code>self-executing anonymous function</code></p>
</blockquote>
<h4 id="最后-模块模式"><a href="#最后-模块模式" class="headerlink" title="最后:模块模式"></a>最后:模块模式</h4><p>当我调用函数表达式时，如果我不至少提醒自己一次关于模块模式，我很可能会忽略它。如果你并不熟悉JavaScript里的构建模式，它和我第一个例子很像，但是返回值用对象代替了函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Create an anonymous function expression that gets invoked immediately,and assign its *return value* to a variable. This approach &quot;cuts out the middleman&quot; of the named `makeWhatever` function reference.</span><br><br><span class="hljs-comment">// As explained in the above &quot;important note,&quot; even though parens are not required around this function expression, they should still be used as a matter of convention to help clarify that the variable is being set to the function&#x27;s *result* and not the function itself.</span><br><span class="hljs-comment">//正如上面的『重要须知』解释的一样，，，即使包围函数表达式的括号不是必须时，它们也应该被很当回事的当做约定俗成的习惯保留着，用来清晰的表明变量是函数的结果，而不是变量本身。</span><br><br><span class="hljs-keyword">var</span> counter = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;,<br>        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123;<br>            i = val;<br>        &#125;,<br>        <span class="hljs-attr">increment</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">return</span> ++i;<br>        &#125;<br>    &#125;<br>    &#125;());<br>    counter.<span class="hljs-title function_">get</span>();<span class="hljs-comment">//0</span><br>    counter.<span class="hljs-title function_">set</span>(<span class="hljs-number">3</span>);<br>    counter.<span class="hljs-title function_">increment</span>();<span class="hljs-comment">//4</span><br>    counter.<span class="hljs-title function_">increment</span>();<span class="hljs-comment">//5</span><br><br>    conuter.<span class="hljs-property">i</span>;<span class="hljs-comment">//undefined (`i` is not a property of the returned object)</span><br>    i;<span class="hljs-comment">//ReferenceError: i is not defined (it only exists inside the closure)</span><br></code></pre></td></tr></table></figure>
<p>模块模式方法不仅相当的厉害而且简单。非常少的代码，你可以有效的利用与方法和属性相关的命名，在一个对象里，组织全部的模块代码即最小化了全局变量的污染也创造了私人变量。</p>
<h4 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h4><p>希望这篇文章能够为你提供些有用的信息，并且解答了一些问题。当然，如果你现在比之前的问题更多了，你可以通过阅读以下文章来更深入的了解函数和构建模式。</p>
<hr>
<p>2018-01-27 更，编者按，，最后希望大家了解下ES6，还是阮一峰老师 &#x3D;&gt; <a href="http://es6.ruanyifeng.com/#docs/intro">ECMAScript 6 简介</a></p>
<ol>
<li><a href="http://dmitrysoshnikov.com/ecmascript/chapter-5-functions/#question-about-surrounding-parentheses">ECMA-262-3 in detail. Chapter 5. Functions</a>. - Dmitry A. Soshnikov</li>
<li><a href="https://developer.mozilla.org/en/JavaScript/Reference/Functions_and_function_scope">Functions and function scope</a> - Mozilla Developer Network</li>
<li><a href="http://kangax.github.io/nfe/">Named function expressions</a> - Juriy “kangax” Zaytsev</li>
<li><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html">JavaScript Module Pattern</a>: In-Depth - Ben Cherry</li>
<li><a href="http://skilldrick.co.uk/2011/04/closures-explained-with-javascript/">Closures explained with JavaScript</a> - Nick Morgan</li>
</ol>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>理想的生活</title>
    <url>/2018/07/27/ideal_life/</url>
    <content><![CDATA[<p>今天在小龙女的微博中发现这样一段转发的话，，<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901134706-choose_my_birth.jpg" alt="choose_my_birth | 200*400"></p>
<p>关于亦舒的『理想的生活』我是完全同意的，，毕竟理想的生活嘛，也是向往的生活。只是看到小猫咪的评论，我能理解 TA 为什么做出这样的评论，但不能完全认同。点开评论想稍微分(反)享(驳)下自己的看法。但写到一半，意识到一个很严重问题。。分(反)享(驳)的前半截是这样的👇</p>
<blockquote>
<p>我们实在没有办法让孩子选择自己的出身，但是假如可以选择话，，</p>
</blockquote>
<p>我后边还想写一些<strong>体验世界，体验未知</strong>之类的话(🤦‍♀️)，但是写到<strong>但是</strong>的时候，发现这个『假如』实在有太多东西可以讲，脑洞大开，，放弃评论了，三言两语实在无法准确表达出自己想表述的东西。买完吃的，赶紧回到公司试着把自己想到的东西记下来，，就像现在。</p>
<h4 id="如果我们可以选择自己的出身-生"><a href="#如果我们可以选择自己的出身-生" class="headerlink" title="如果我们可以选择自己的出身(生)"></a>如果我们可以选择自己的出身(生)</h4><p>首先，，如果我们可以选择自己的出身(生)，那么这意味着，在我们出生之前，我们的意识已然存在了。那么问题来了，这个先验的不依靠<em>人间</em>(目前想不到更好词..)存在的意识是怎样产生的？？这算不算某种程度上的 <em>意识不灭论</em> ？？？肉身会枯萎 化作泥土，意识却永远存在某个独立的空间(这个空间内有没有时间的概念?时间对意识会产生怎样的影响？？)。这些意识会不会『意识』到其他意识的存在，如果可以『意识』到，那这些意识存在的空间内会不会也有类似人类的『社会』的概念，他们可以互相交流，做信息交换。他们怎么做信息交换？像三体人一样，靠思维直接对话？？我甚至想象不出『思维』对『意识』来说是怎样一种存在…</p>
<p>其次，，如果可以选择，那么肯定应该有某种机制高于他们做出的选择，类似人类社会中的『法律』、『规范』、『道德』之类的存在，我们姑且叫做『规约』。『规约』之所以存在，是为了解决意识之间争夺『出身选择』的解决机制。且先不考虑『规约』是怎样产生的，，意识是怎样做出『出身选择』的？靠某种更高力量的存在分配(类似于之前的高校负责就业分配)，还是靠意识个体的能力去抢夺资源(出身选择)？如果是分配的话，，如何保证『意识社会』的公平正义？？如果是靠个体能力抢夺资源的话，如果解决抢夺过程中存在的选择权争议？靠类似人类社会法庭一样的存在？会不会太低效。。那像程序中的锁问题？新的出身选择出现，某个意识抢到读取这个选择权的权利，，然后了解这个选择，然后做出选择要不要做这对夫妻孩子，，这期间其他意识个体是不能重复争夺这个出身选择的。等之前抢到的那个意识做出决定，，如果选择『投胎』(怪怪的..)，那么这个选择消失。如果放弃这个出身选择，那么其他意识才可以再去争夺这个选择权的读取权利。</p>
<p>再其次，，如果有的意识个体能力很弱，总是抢不到『出身选择』，TA会不会被『规约』淘汰，强制『报废』？如果有的意识能力并不弱，只是一直不能做出投胎的选择，，那TA会不会『变老』？？TA的能力会不会随做出选择次数的增长而衰减？？？如果意识在意识的世界不会消亡，那么意识世界会不会像人类一样面临『人口问题』(『资源问题』)，不会也有灭霸吧？！！</p>
<p>OK，，别的都特么不管了。如果意识做出投胎的选择之后，来到『人间』，那 TA 能为自己的选择负责么？TA 会不会后悔做出当初的选择？父母还有必要对这个『意识』负责么？哎呦，当初是你做出的选择要做我们的孩子，我们又没有逼你诶。。怎么又有点像自动驾驶发生事故时的伦理问题。。。<br>日，，又想到一个严重的问题！自杀会不会变成一种权利(从某种程度上讲，一直都是)？每当有意识不满现状的时候，就会做出自杀的选择 来达到重新选择出身的目的。那这样，，『人间』会不会变成『地狱』。。那频繁『自杀』的意识会不会被拉黑，某段时间内禁止投胎(🤦‍♀️)？？<br>丫丫，，午休的时候又想到一个严重的后果！！这个世界会因此变得无趣，严重破坏了人类基因库的多样性！！试想一下，全世界只剩下几大家族以及他们的亲戚、朋友。。倒是没穷人了，大家都那么有钱，对我们而言，壹佰亿和一亿又有什么区别呢，反正一个人能同时占用的资源也就那么多。。</p>
<p>诶？？意识投胎之前应该会忘记自己『意识社会』中的生活吧？？？<br>诶，，那这样，现在再说自己当初没得选择好像不太合理诶。。。</p>
<h4 id="关于无知之幕"><a href="#关于无知之幕" class="headerlink" title="关于无知之幕"></a>关于无知之幕</h4><p><a href="https://baike.baidu.com/item/%E6%97%A0%E7%9F%A5%E4%B9%8B%E5%B9%95/8888696?fr=aladdin">无知之幕</a>最早是在迈克尔∙桑德尔的『公正-该如何做是好』(中信出版社)看到的一个概念。它出现在&lt;设想完美的契约&gt;中，，</p>
<blockquote>
<p>让我们来想象一种在那些拥有平等的，而非不平等的权利和知识的人们之间所达成的协议：他们处于同样的境况，而并非不同的境况。同时也设想一下，这份契约的对象并不是管道铺设或其他的普通交易，而是那些治理我们的生活的、分配我们作为公民所具有的权利与义务的各种原则。在这样的各方中所达成的这样一个契约，就不会有压迫、欺骗或其他不公平的缺点。它的各项条款由于同意本身，就必然是公正的，而无论它们是什么。<br>…<br><strong>无知之幕通过保证没有人知道他在社会中的地位，他的优点或缺点，他的价值或目的，从而保证了没有人能够(即使是无意的)利用一种更好的交易地位。</strong></p>
</blockquote>
<p>如此，，我们不能选择自己的出身(生)，这不就是『<strong>无知之幕</strong>』么？</p>
<p>记得在之前的某一个冬天，和一个很要好的朋友去龙泉寺，半山腰休息的时候，讨论类似的话题。朋友提到『我觉的人这一生是不完整的，我们没办法决定自己的出生，也没办法清醒的经历自己的死亡。』。深以为然，掐头去尾，我们只能清醒的体验活着的这段时间。出生之前，包括出生这个过程，以及出生后的很长一段时间，我们并不能对外界的刺激做出合理的反应(大概就是『无知』『未开化』的那段时间，这里不知道怎么表述了..)，死亡亦是如此。但如果我们可以选择出身的话，那一切都不一样了，我们拥有了完整的人生，人生所有的阶段都有意识存在，甚至还有另外一个世界的体验，虽然我们可能会不记得，，这里有bug。。人类为什么要有刚出生那段时间的无知、未开化，记忆和认知能力为什么不可以遗传？！？这里也可以好好开下脑洞，，</p>
<p>以前也会因为自己不能选择出身而耿耿于怀，，请不要误会，我非常爱我的爸妈，我只是想不明白为什么不可以，而不是可以选择出身的话，我可能会拥有更好的人生。但是经过这个『思维游戏』后，我好像明白了，也庆幸无知之幕的存在。</p>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>读过的书的确会忘记，但冥冥中还是对会改变一些什么，，像『无知之幕』，若非读过『公正』，可能还不知道什么时候会意识到这样一种存在。书是13年寒假买的，在重庆待的那一个月，第一次在亚马逊买书。想来那时候就对这种东西感兴趣，书竟然也读下去了一半，冰糕棍儿还夹在203页🤦‍♀️。那时候还没接触哲学，书中的笔记也很幼稚，，想来现在该重读了。温故知新，，以前不是很明白这句话，书上的硬知识点就那些，跟什么时候看有什么关系。。现在想来，温故知新确是有道理的，，很多书读不懂，千万不要硬啃，放一放，再经历一些事情，回过头重读，总能读到新的感受。总之呢，读的书必须跟自己的阅历相匹配，每个人在书中，在电影中读到的大抵还是自己的故事。</p>
<p>晚安~</p>
]]></content>
      <tags>
        <tag>出身</tag>
        <tag>无知之幕</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的变量提升及作用域</title>
    <url>/2017/12/14/javascript_coping_and_hoisting/</url>
    <content><![CDATA[<h3 id="JavaScript的变量提升及作用域"><a href="#JavaScript的变量提升及作用域" class="headerlink" title="JavaScript的变量提升及作用域"></a>JavaScript的变量提升及作用域</h3><p>JavaScript的语法简直不要太灵活，灵活到导出是坑，甚至有人说JavaScript语言不够成熟。。</p>
<blockquote>
<p>Code once,debug everywhere.</p>
</blockquote>
<p>下面简单整理下常见的坑坑。</p>
<h4 id="变量提升-hoisting"><a href="#变量提升-hoisting" class="headerlink" title="变量提升(hoisting)"></a>变量提升(hoisting)</h4><p>javascript的变量声明具有<strong>hoisting</strong>机制，JavaScript引擎在执行的时候，会把所有变量的<strong>声明</strong>都提升到当前作用域的最前面：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var v = &quot;hello&quot;;<br>(function()&#123;<br>    console.log(v);<br>    var v = &quot;world&quot;;<br>&#125;)();<br></code></pre></td></tr></table></figure>
<p>倘若这是网页中的一部分，则第三行代码输出<code>undefined</code>,若是在浏览器DevTools的console中运行的话，则是两条<code>undefined</code>结果，第一条是<code>console.log()</code>输出的，第二条是执行(闭包)函数时返回的默认值(没有定义返回值时)<code>undefined</code>。<br>其实上边👆的代码等价于：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var v = &quot;hello&quot;;<br>(function()&#123;<br>    var v; //declaration hoisting 变量声明提升<br>    console.log(v);<br>    v = &quot;world&quot;;<br>&#125;)();<br>//第三行中，只重新声明了v，没有定义(初始化赋值),所以返回undefined。<br></code></pre></td></tr></table></figure>
<p>下面给我们稍加改动下，，👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var v = &quot;hello&quot;;<br>if(true)&#123;<br>    console.log(v);<br>    var v = &quot;world&quot;;<br>&#125;<br>// hello<br></code></pre></td></tr></table></figure>
<p>如果JavaScript有块作用域的话，应该会报错吧，，内容大概是第4行变量v已经被定义什么的。这样说不太明显，，看这个：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">for(var i = 0;i &lt; 10; i++)&#123;<br> console.log(i);<br>&#125;<br>console.log(i);//10<br>console.log(window.i);//10<br></code></pre></td></tr></table></figure>
<p>上边在<code>for</code>循环中声明的变量<code>i</code>应该只存在与<code>for</code>循环的代码块中，但是却可以在代码块外访问，外边声明的变量默认是window对象的属性。由此可见<strong>javascript是没有块级作用域的</strong>。但<strong>函数是JavaScript中唯一拥有自身作用域的结构</strong>。就像文章开头的第一个代码块一样，再小改下👇：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var v = &quot;hello&quot;;<br>(function()&#123;<br>    console.log(&quot;v inside:&quot;+v);<br>    var v = &quot;world&quot;;<br>&#125;)();<br>console.log(&quot;v outside:&quot;+v);<br><br>//v inside:undefined<br>//v outside:hello<br></code></pre></td></tr></table></figure>
<p>此时，闭包函数外是访问不到内部的变量<code>v = &quot;world&quot;</code>的，，所以，outside输出的值为hello。若是不死心，，我们再改：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var v = &quot;hello&quot;;<br>(function()&#123;<br>    var v = &quot;world&quot;;<br>    console.log(&quot;v inside:&quot;+v);<br>&#125;)();<br>console.log(&quot;v outside:&quot;+v);<br><br>//v inside:world<br>//v outside:hello<br>//此处不解释。<br></code></pre></td></tr></table></figure>
<p>还是关于函数内的块级作用域，，我再换种方式：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var i = function()&#123;<br>    var h = 9;<br>    console.log(&quot;inside h:&quot;+h);<br>&#125;<br>console.log(&quot;outside h:&quot;+h)<br><br>// 第5行直接报错：h is not defined。<br></code></pre></td></tr></table></figure>
<p>其实，我们还可以再改，，关于隐式声明的全局变量<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var">^1</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var i = function()&#123;<br>    h = 9;              //此处去掉关键字var<br>    console.log(&quot;inside h:&quot;+h);<br>&#125;<br>i();<br>console.log(&quot;outside h:&quot;+h);<br><br>// inside h:9<br>// outside h:9<br>// 在函数内部声明变量时省略var关键字，会默认当做全局变量。<br>// 另外，如果没有第五行的i()；函数i调用，则第六行还是会报错Uncaught ReferenceError: h is not defined<br></code></pre></td></tr></table></figure>

<h2 id="》》》2017-12-19-补充《《《"><a href="#》》》2017-12-19-补充《《《" class="headerlink" title="》》》2017-12-19-补充《《《"></a>》》》2017-12-19-补充《《《<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var x = 0;<br><br>function f()&#123;<br>  var x = y = 1; // x在函数内部声明，y不是！<br>&#125;<br>f();<br><br>console.log(x, y); // 0, 1<br>// x是全局变量。<br>// y是隐式声明的全局变量。<br>// 第4行可以近似理解为 y = 1;var x = y;<br></code></pre></td></tr></table></figure></h2><p>需要注意的是，提升的不光有变量，函数声明也会提升，但是通过函数字面量定义的函数不会被提升，详见[JavaScript执行顺序]。(<a href="https://someoneiscoding.github.io/2017/12/02/JavaScript%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">https://someoneiscoding.github.io/2017/12/02/JavaScript%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</a>)</p>
<h4 id="名字解析顺序"><a href="#名字解析顺序" class="headerlink" title="名字解析顺序"></a>名字解析顺序</h4><p>javascript中一个名字(name)以四种方式进入作用域(scope)，其优先级顺序如下：<br>1、语言内置：所有的作用域中都有 this 和 arguments 关键字<br>2、形式参数：函数的参数在函数作用域中都是有效的<br>3、函数声明：形如function foo() {}<br>4、变量声明：如 var;<br>名字<strong>声明</strong>的优先级如上👆所示，也就是说如果一个变量的名字与函数的名字相同，那么函数的名字会覆盖变量的名字，无论其在代码中的顺序如何。但名字的<strong>初始化</strong>却是按其在代码中书写的顺序进行的，不受以上优先级的影响。看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(function()&#123;<br>    function foo()&#123;&#125;<br>    console.log(typeof foo); //function<br>    var foo;     <br>    console.log(typeof foo); //function<br> <br>    foo = &quot;foo&quot;;<br>    console.log(typeof foo); //string<br>&#125;)();<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript 面向对象编程(一)：封装</title>
    <url>/2017/12/11/javascript_oop-encapsulation/</url>
    <content><![CDATA[<h3 id="Javascript-面向对象编程-一-：封装"><a href="#Javascript-面向对象编程-一-：封装" class="headerlink" title="Javascript 面向对象编程(一)：封装"></a>Javascript 面向对象编程(一)：封装</h3><p>最近一直在用百度的echarts做图表什么的，在配置项中的<code>option</code>是一个对象，，like this <code>var option = &#123;&#125;</code>，，有时需要多个<code>option</code>对象，复制来复制去，也只是复制的变量，指向的还是同一个引用。。得好好学习下，翻来覆去还是阮一峰老师的总结最友好~</p>
<hr>
<blockquote>
<p>原文链接：<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html">Javascript 面向对象编程（一）：封装</a> - by 阮一峰</p>
</blockquote>
<p>学习Javascript，最难的地方是什么？<br>我觉得，Object（对象）最难。因为Javascript的Object模型很独特，和其他语言都不一样，初学者不容易掌握。<br>下面就是我的学习笔记，希望对大家学习这个部分有所帮助。我主要参考了以下两本书籍：</p>
<ol>
<li><a href="https://www.packtpub.com/object-oriented-javascript-applications-libraries/book">《面向对象的Javascript》</a>（Object-Oriented JavaScript）</li>
<li><a href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-JavaScript-for-Web-Developers-2nd-Edition.productCd-047022780X.html">《Javascript高级程序设计（第二版）》</a>（Professional JavaScript for Web Developers, 2nd Edition)</li>
</ol>
<p>它们都是非常优秀的Javascript读物，推荐阅读。<br>笔记分成三部分。今天的第一部分是讨论”封装”（Encapsulation），后面的<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">第二部分</a>和<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html">第三部分</a>讨论”继承”（Inheritance）。</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D; &#x3D;&#x3D;&#x3D;&#x3D; </p>
<p>Javascript是一种基于对象（object-based）的语言，你遇到的所有东西几乎都是对象。但是，它又不是一种真正的面向对象编程（OOP）语言，因为它的语法中没有<code>class</code>（类）。</p>
<p>那么，如果我们要把”属性”（property）和”方法”（method），封装成一个对象，甚至要从原型对象生成一个实例对象，我们应该怎么做呢？</p>
<h4 id="一、生成实例对象的原始模式"><a href="#一、生成实例对象的原始模式" class="headerlink" title="一、生成实例对象的原始模式"></a><span id='实例对象原始模式'>一、生成实例对象的原始模式</h4><p>假定我们把猫看成一个对象，它有”名字”和”颜色”两个属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var Cat = &#123;<br>    name : &#x27;&#x27;,<br>    color : &#x27;&#x27;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>现在，我们需要根据这个原型对象的规格（schema），生成两个实例对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var cat1 = &#123;&#125;; // 创建一个空对象<br>cat1.name = &quot;大毛&quot;; // 按照原型对象的属性赋值<br>cat1.color = &quot;黄色&quot;;<br><br>var cat2 = &#123;&#125;;<br>cat2.name = &quot;二毛&quot;;<br>cat2.color = &quot;黑色&quot;;<br></code></pre></td></tr></table></figure>
<p>好了，这就是最简单的封装了，把两个属性封装在一个对象里面。但是，这样的写法有两个缺点，一是如果多生成几个实例，写起来就非常麻烦；二是<strong>实例与原型之间，没有任何办法，可以看出有什么联系。</strong></p>
<h4 id="二、原始模式的改进"><a href="#二、原始模式的改进" class="headerlink" title="二、原始模式的改进"></a>二、原始模式的改进</h4><p>我们可以写一个函数，解决代码重复的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Cat(name,color) &#123;<br>    return &#123;<br>        name:name,<br>        color:color<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>然后生成实例对象，就等于是在调用函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var cat1 = Cat(&quot;大毛&quot;,&quot;黄色&quot;);<br>var cat2 = Cat(&quot;二毛&quot;,&quot;黑色&quot;);<br></code></pre></td></tr></table></figure>
<p>这种方法的问题依然是，<code>cat1</code>和<code>cat2</code>之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h4 id="三、构造函数模式"><a href="#三、构造函数模式" class="headerlink" title="三、构造函数模式"></a>三、构造函数模式</h4><p>为了解决从原型对象生成实例的问题，Javascript提供了一个构造函数（<em>Constructor</em>）模式。</p>
<p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了<code>this</code>变量。对构造函数使用new运算符，就能生成实例，并且<code>this</code>变量会绑定在实例对象上。<br>比如，猫的原型对象现在可以这样写:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Cat(name,color)&#123;<br>    this.name=name;<br>    this.color=color;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们现在就可以生成实例对象了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);<br>var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);<br>alert(cat1.name); // 大毛<br>alert(cat1.color); // 黄色<br></code></pre></td></tr></table></figure>
<p>这时<code>cat1</code>和<code>cat2</code>会自动含有一个<code>constructor</code>属性，指向它们的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(cat1.constructor == Cat); //true<br>alert(cat2.constructor == Cat); //true<br></code></pre></td></tr></table></figure>
<p>Javascript还提供了一个<code>instanceof</code>运算符，验证原型对象与实例对象之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(cat1 instanceof Cat); //true<br>alert(cat2 instanceof Cat); //true<br></code></pre></td></tr></table></figure>
<blockquote>
<p><code>instanceof</code>不是驼峰命名，，类似的还有<code>typeof</code> ——来自someone</p>
</blockquote>
<h4 id="四、构造函数模式的问题"><a href="#四、构造函数模式的问题" class="headerlink" title="四、构造函数模式的问题"></a>四、构造函数模式的问题</h4><p>构造函数方法很好用，但是存在一个浪费内存的问题。<br>请看，我们现在为<code>Cat</code>对象添加一个不变的属性<code>type</code>（种类），再添加一个方法<code>eat</code>（吃）。那么，原型对象Cat就变成了下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Cat(name,color)&#123;<br>    this.name = name;<br>    this.color = color;<br>    this.type = &quot;猫科动物&quot;;<br>    this.eat = function()&#123;alert(&quot;吃老鼠&quot;);&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还是采用同样的方法，生成实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);<br>var cat2 = new Cat (&quot;二毛&quot;,&quot;黑色&quot;);<br>alert(cat1.type); // 猫科动物<br>cat1.eat(); // 吃老鼠<br></code></pre></td></tr></table></figure>
<p>表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，<code>type</code>属性和<code>eat()</code>方法都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存。这样既不环保，也缺乏效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(cat1.eat == cat2.eat); //false<br></code></pre></td></tr></table></figure>
<h4 id="五、Prototype模式"><a href="#五、Prototype模式" class="headerlink" title="五、Prototype模式"></a>五、Prototype模式</h4><p>Javascript规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。<br>这意味着，我们<strong>可以把那些不变的属性和方法，直接定义在<code>prototype</code>对象上。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Cat(name,color)&#123;<br>    this.name = name;<br>    this.color = color;<br>&#125;<br><br>//存储公共的属性和方法，达到所有实例共享的目的，永久不变；<br>Cat.prototype.type = &quot;猫科动物&quot;;<br>Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;<br></code></pre></td></tr></table></figure>
<p>然后，生成实例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);<br>var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);<br>alert(cat1.type); // 猫科动物<br>cat1.eat(); // 吃老鼠<br></code></pre></td></tr></table></figure>
<p>这时所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(cat1.eat == cat2.eat); //true<br></code></pre></td></tr></table></figure>
<h4 id="六、Prototype模式的验证方法"><a href="#六、Prototype模式的验证方法" class="headerlink" title="六、Prototype模式的验证方法"></a>六、Prototype模式的验证方法</h4><p>为了配合prototype属性，Javascript定义了一些辅助方法，帮助我们使用它。</p>
<h5 id="6-1-isPrototypeOf"><a href="#6-1-isPrototypeOf" class="headerlink" title="6.1 isPrototypeOf()"></a>6.1 <code>isPrototypeOf()</code></h5><p>这个方法用来判断，某个<code>proptotype</code>对象和某个实例之间的关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(Cat.prototype.isPrototypeOf(cat1)); //true<br>alert(Cat.prototype.isPrototypeOf(cat2)); //true<br></code></pre></td></tr></table></figure>
<h5 id="6-2-hasOwnProperty"><a href="#6-2-hasOwnProperty" class="headerlink" title="6.2 hasOwnProperty()"></a>6.2 <code>hasOwnProperty()</code></h5><p>每个实例对象都有一个<code>hasOwnProperty()</code>方法，用来判断某一个属性到底是本地属性，还是继承自<code>prototype</code>对象的属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(cat1.hasOwnProperty(&quot;name&quot;)); // true<br>alert(cat1.hasOwnProperty(&quot;type&quot;)); // false<br></code></pre></td></tr></table></figure>
<h5 id="6-3-in运算符"><a href="#6-3-in运算符" class="headerlink" title="6.3 in运算符"></a>6.3 in运算符</h5><p><code>in</code>运算符可以用来判断，某个实例是否含有某个属性，不管是不是本地属性。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(&quot;name&quot; in cat1); // true<br>alert(&quot;type&quot; in cat1); // true<br></code></pre></td></tr></table></figure>
<p><code>in</code>运算符还可以用来遍历某个对象的所有属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">for(var prop in cat1) &#123; alert(&quot;cat1[&quot;+prop+&quot;]=&quot;+cat1[prop]); &#125;<br></code></pre></td></tr></table></figure>
<p>未完，请继续阅读这个系列的第二部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">《构造函数的继承》</a>和第三部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html">《非构造函数的继承》</a>。<br>（完）</p>
<hr>
<p>补充：</p>
<ol>
<li>函数声明与函数字面量<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Cat(name,color)&#123;<br>    this.name = name;<br>    this.color = color;<br>&#125;<br></code></pre></td></tr></table></figure>
与<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var Cat = function (name,color)&#123;<br>    this.name = name;<br>    this.color = color;<br>&#125;<br></code></pre></td></tr></table></figure>
在实例化及使用时，用法相同。</li>
<li>Json方式访问对象属性<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var cat = new Cat(&#x27;Command&#x27;,&#x27;black&#x27;);<br><br>//下面两种使用方式效果相同<br>alert(cat.name);<br>alert(cat[&#x27;name&#x27;]);<br></code></pre></td></tr></table></figure></li>
<li>在第一种方式<a href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E5%8E%9F%E5%A7%8B%E6%A8%A1%E5%BC%8F">实例对象原始模式</a>中，其实实例与原型之间没有什么关系，如果非要扯上关系的话，，只能说『原型』和『实例』之间的格式比较相像。『实例』之间也没什么关系。。这种方式生成的对象是一次性的，无法复用，，在某种程度上，『原型』也是一个『实例』。</li>
<li>有的博客上说<code>new</code>关键字可以省略，后来又查阅了些资料才知道，，原来真的是<del>可以省略</del>的:<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var cat = Cat(&#x27;cmd&#x27;,&#x27;black&#x27;);<br>console.log(cat);          //undefined<br>console.log(cat.name);     //Cannot read property &#x27;name&#x27; of undefined<br>console.log(window.name);  //cmd<br></code></pre></td></tr></table></figure>
<blockquote>
<p>对于js的new关键字，大家可以这样理解：<br><code>new</code>就是将函数内部的<code>this</code>的值，赋值给当前对象的<code>this</code>，如：<code>this.name（实例对象） = this.name（构造函数）</code><br>当没有<code>new</code>的时候，<code>this</code>就变为了<code>window</code>，也就解释了。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>—— <a href="http://blog.csdn.net/xi_2130/article/details/50110493">js创建对象之设计模式</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript面向对象编程(二):构造函数的继承</title>
    <url>/2023/12/16/javascript_oop-inheritance_of_constructor/</url>
    <content><![CDATA[<h3 id="Javascript面向对象编程（二）：构造函数的继承"><a href="#Javascript面向对象编程（二）：构造函数的继承" class="headerlink" title="Javascript面向对象编程（二）：构造函数的继承"></a>Javascript面向对象编程（二）：构造函数的继承</h3><blockquote>
<p>转载自<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">Javascript面向对象编程（二）：构造函数的继承</a> - by 阮一峰</p>
</blockquote>
<p>这个系列的<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html">第一部分</a>，主要介绍了如何“封装”数据和方法，以及如何从原型对象生成实例。<br>今天要介绍的是，对象之间的“继承”的五种方法。<br>比如，现在有一个“动物”👇对象的构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Animal()&#123;<br>    this.species = &quot;动物&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>还有一个“猫”👇对象的构造函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Cat(name,color)&#123;<br>    this.name = name;<br>    this.color = color;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>怎样才能使“猫”继承“动物”呢？</p>
<h4 id="一、-构造函数绑定"><a href="#一、-构造函数绑定" class="headerlink" title="一、 构造函数绑定"></a>一、 构造函数绑定</h4><p>第一种方法也是最简单的方法，使用<code>call</code>或<code>apply</code>方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Cat(name,color)&#123;<br>    Animal.apply(this, arguments);<br>    this.name = name;<br>    this.color = color;<br>&#125;<br>var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);<br>alert(cat1.species); // 动物<br></code></pre></td></tr></table></figure>

<h4 id="二、-prototype模式"><a href="#二、-prototype模式" class="headerlink" title="二、 prototype模式"></a>二、 prototype模式</h4><p>第二种方法更常见，使用<code>prototype</code>属性。<br>如果“猫”的<code>prototype</code>对象，指向一个<code>Animal</code>的实例，那么所有”猫”的实例，就能继承<code>Animal</code>了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Cat.prototype = new Animal();<br>Cat.prototype.constructor = Cat;<br>var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);<br>alert(cat1.species); // 动物<br></code></pre></td></tr></table></figure>
<p>代码的第一行，我们将<code>Cat</code>的<code>prototype</code>对象指向一个<code>Animal</code>的实例。它相当于完全删除了<code>prototype</code>对象原先的值，然后赋予一个新值。但是，第二行又是什么意思呢？<br><span id="edit">原来，任何一个prototype对象都有一个constructor属性，指向它的构造函数。如果没有<code>Cat.prototype = new Animal();</code>这一行，<code>Cat.prototype.constructor</code>是指向<code>Cat</code>的；加了这一行以后，<code>Cat.prototype.constructor</code>指向<code>Animal</code>。每一个实例也有一个<code>constructor</code>属性，默认调用<code>prototype</code>对象的<code>constructor</code>属性。<br>因此，在运行<code>&quot;Cat.prototype = new Animal();&quot;</code>这一行之后，<code>cat1.constructor</code>也指向<code>Animal</code>(如果没有第二行代码)！这显然会导致继承链的紊乱（<code>cat1</code>明明是用构造函数<code>Cat</code>生成的），因此我们必须手动纠正，将<code>Cat.prototype</code>对象的c<code>onstructor</code>值改为<code>Cat</code>。这就是第二行的意思。<br>这是很重要的一点，编程时务必要遵守。下文都遵循这一点，即如果替换了prototype对象,那么，下一步必然是为新的prototype对象加上constructor属性，并将这个属性指回原来的构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">o.prototype = &#123;&#125;;<br>o.prototype.constructor = o;<br></code></pre></td></tr></table></figure>
<h4 id="三、-直接继承prototype"><a href="#三、-直接继承prototype" class="headerlink" title="三、 直接继承prototype"></a>三、 直接继承prototype</h4><p>第三种方法是对第二种方法的改进。由于<code>Animal</code>对象中，不变的属性都可以直接写入<code>Animal.prototype</code>。所以，我们也可以让<code>Cat()</code>跳过 <code>Animal()</code>，直接继承<code>Animal.prototype</code>。<br>现在，我们先将<code>Animal</code>对象改写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Animal()&#123; &#125;<br>Animal.prototype.species = &quot;动物&quot;;<br></code></pre></td></tr></table></figure>
<p>然后，将Cat的prototype对象，然后指向Animal的prototype对象，这样就完成了继承。👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Cat.prototype = Animal.prototype;<br>Cat.prototype.constructor = Cat;<br>var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);<br>alert(cat1.species); // 动物<br></code></pre></td></tr></table></figure>
<p>与前一种方法相比，这样做的优点是效率比较高（不用执行和建立<code>Animal</code>的实例了），比较省内存。缺点是 <code>Cat.prototype</code>和<code>Animal.prototype</code>现在指向了同一个对象，那么任何对<code>Cat.prototype</code>的修改，都会反映到<code>Animal.prototype</code>。<br>所以，上面这一段代码其实是有问题的，，请看第二行👆。这一句实际上把<code>Animal.prototype</code>对象的<code>constructor</code>属性也改掉了！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(Animal.prototype.constructor); // Cat<br></code></pre></td></tr></table></figure>
<h4 id="四、-利用空对象作为中介"><a href="#四、-利用空对象作为中介" class="headerlink" title="四、 利用空对象作为中介"></a>四、 利用空对象作为中介</h4><p>由于”直接继承prototype”存在上述的缺点，所以就有第四种方法，利用一个空对象作为中介：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var F = function()&#123;&#125;;<br>F.prototype = Animal.prototype;<br>Cat.prototype = new F();<br>Cat.prototype.constructor = Cat;<br></code></pre></td></tr></table></figure>
<p><code>F</code>是空对象，所以几乎不占内存。这时，修改<code>Cat</code>的<code>prototype</code>对象，就不会影响到<code>Animal</code>的<code>prototype</code>对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">alert(Animal.prototype.constructor); // Animal<br></code></pre></td></tr></table></figure>
<p>我们将上面的方法，封装成一个函数，便于使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function extend(Child, Parent) &#123;<br>    var F = function()&#123;&#125;;<br>    F.prototype = Parent.prototype;<br>    Child.prototype = new F();<br>    Child.prototype.constructor = Child;<br>    Child.uber = Parent.prototype;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用的时候，方法如下:👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">extend(Cat,Animal);<br>var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);<br>alert(cat1.species); // 动物<br></code></pre></td></tr></table></figure>
<p>这个<code>extend</code>函数，就是YUI库如何实现继承的方法。</p>
<p>另外，说明一点，函数体最后一行<code>Child.uber = Parent.prototype;</code>意思是为子对象设一个uber属性，这个属性直接指向父对象的prototype属性。（uber是一个德语词，意思是”向上”、”上一层”。）这等于在子对象上打开一条通道，可以直接调用父对象的方法。这一行放在这里，只是为了实现继承的完备性，纯属备用性质。</p>
<h4 id="五、-拷贝继承"><a href="#五、-拷贝继承" class="headerlink" title="五、 拷贝继承"></a>五、 拷贝继承</h4><p>上面是采用<code>prototype</code>对象，实现继承。我们也可以换一种思路，纯粹采用”拷贝”方法实现继承。简单说，如果把父对象的所有属性和方法，拷贝进子对象，不也能够实现继承吗？这样我们就有了第五种方法。</p>
<p>首先，还是把Animal的所有不变属性，都放到它的prototype对象上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Animal()&#123;&#125;<br>Animal.prototype.species = &quot;动物&quot;;<br></code></pre></td></tr></table></figure>
<p>然后，再写一个函数，实现属性拷贝的目的：👇<span id="extend2"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function extend2(Child, Parent) &#123;<br>    var p = Parent.prototype;<br>    var c = Child.prototype;<br>    for (var i in p) &#123;<br>        c[i] = p[i];<br>    &#125;<br>    c.uber = p;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个函数的作用，就是将父对象的<code>prototype</code>对象中的属性，一一拷贝给<code>Child</code>对象的<code>prototype</code>对象。<br>使用的时候，这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">extend2(Cat, Animal);<br>var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);<br>alert(cat1.species); // 动物<br></code></pre></td></tr></table></figure>
<p>本系列未完，请继续阅读第三部分<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance_continued.html">《非构造函数的继承》</a>。<br>（完）</p>
<hr>
<ol>
<li>在 <strong>二、 prototype模式</strong> <a href="#edit">第三段</a>中删除了示例代码，当初读的时候上下语义之间有些割裂，理解起来有点麻烦。。</li>
<li>在 <strong>五、 拷贝继承</strong> <a href="#extend2">extend2</a>函数中，<code>for</code>循环中的代码<code>c[i] = p[i];</code>是采用了json格式的调用了对象的方法，与平时我们一般习惯中的instance.method效果一样。</li>
</ol>
]]></content>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript面向对象编程(三):非构造函数的继承</title>
    <url>/2023/12/16/javascript_oop-inheritance_of_non-constructor/</url>
    <content><![CDATA[<h3 id="Javascript面向对象编程（三）：非构造函数的继承"><a href="#Javascript面向对象编程（三）：非构造函数的继承" class="headerlink" title="Javascript面向对象编程（三）：非构造函数的继承"></a>Javascript面向对象编程（三）：非构造函数的继承</h3><p>这个系列的<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html">第一部分</a>介绍了”封装”，<a href="http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_inheritance.html">第二部分</a>介绍了使用构造函数实现”继承”。<br>今天是最后一个部分，介绍不使用构造函数实现”继承”。</p>
<h4 id="一、什么是”非构造函数”的继承？"><a href="#一、什么是”非构造函数”的继承？" class="headerlink" title="一、什么是”非构造函数”的继承？"></a>一、什么是”非构造函数”的继承？</h4><p>比如，现在有一个对象，叫做”中国人”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var Chinese = &#123;<br>    nation:&#x27;中国&#x27;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>还有一个对象，叫做”医生”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var Doctor =&#123;<br>    career:&#x27;医生&#x27;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>请问怎样才能让”医生”去继承”中国人”，也就是说，我怎样才能生成一个”中国医生”的对象？<br>这里要注意，这两个对象都是普通对象，不是构造函数，无法使用构造函数方法实现”继承”。</p>
<h4 id="二、object-方法"><a href="#二、object-方法" class="headerlink" title="二、object()方法"></a>二、object()方法</h4><p>json格式的发明人Douglas Crockford，提出了一个object()函数，可以做到这一点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function object(o) &#123;<br>    function F() &#123;&#125;<br>    F.prototype = o;<br>    return new F();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个<code>object()</code>函数，其实只做一件事，就是把子对象的<code>prototype</code>属性，指向父对象，从而使得子对象与父对象连在一起。<br>使用的时候，第一步先在父对象的基础上，生成子对象，然后，再加上子对象本身的属性，这时，子对象已经继承了父对象的属性了：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var Doctor = object(Chinese);<br>Doctor.career = &#x27;医生&#x27;;<br>alert(Doctor.nation); //中国<br></code></pre></td></tr></table></figure>

<h4 id="三、浅拷贝"><a href="#三、浅拷贝" class="headerlink" title="三、浅拷贝"></a>三、浅拷贝</h4><p>除了使用”prototype链”以外，还有另一种思路：把父对象的属性，全部拷贝给子对象，也能实现继承。<br>下面这个函数，就是在做拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function extendCopy(p) &#123;<br>    var c = &#123;&#125;;<br>    for (var i in p) &#123; <br>        c[i] = p[i];<br>    &#125;<br>    c.uber = p;<br>    return c;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用的时候，这样写：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var Doctor = extendCopy(Chinese);<br>Doctor.career = &#x27;医生&#x27;;<br>alert(Doctor.nation); // 中国<br></code></pre></td></tr></table></figure>
<p>但是，这样的拷贝有一个问题。那就是，如果父对象的属性等于数组或另一个对象，那么实际上，子对象获得的只是一个内存地址，而不是真正拷贝，因此存在父对象被篡改的可能。<br>请看，现在给Chinese添加一个”出生地”属性，它的值是一个数组，通过extendCopy()函数，Doctor继承了Chinese。然后，我们为Doctor的”出生地”添加一个城市，然后，我们为Doctor的”出生地”添加一个城市：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Chinese.birthPlaces = [&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;香港&#x27;];<br>var Doctor = extendCopy(Chinese);<br>Doctor.birthPlaces.push(&#x27;厦门&#x27;);<br><br>alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门<br>alert(Chinese.birthPlaces); //北京, 上海, 香港, 厦门<br></code></pre></td></tr></table></figure>
<p>👆发生了什么事？Chinese的”出生地”也被改掉了！</p>
<p>所以，extendCopy()只是拷贝基本类型的数据，我们把这种拷贝叫做”浅拷贝”。这是早期jQuery实现继承的方式。</p>
<h4 id="四、深拷贝"><a href="#四、深拷贝" class="headerlink" title="四、深拷贝"></a>四、深拷贝</h4><p>所谓”深拷贝”，就是能够实现真正意义上的数组和对象的拷贝。它的实现并不难，只要递归调用”浅拷贝”就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function deepCopy(p, c) &#123;<br>    var c = c || &#123;&#125;;<br>    for (var i in p) &#123;<br>    if (typeof p[i] === &#x27;object&#x27;) &#123;<br>        c[i] = (p[i].constructor === Array) ? [] : &#123;&#125;;<br>            deepCopy(p[i], c[i]);<br>        &#125; else &#123;<br>                c[i] = p[i];<br>        &#125;<br>    &#125;<br>    return c;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用的时候这样写，给父对象加一个属性，值为数组。然后，在子对象上修改这个属性，这时，父对象就不会受到影响了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var Doctor = deepCopy(Chinese);<br>Chinese.birthPlaces = [&#x27;北京&#x27;,&#x27;上海&#x27;,&#x27;香港&#x27;];<br>Doctor.birthPlaces.push(&#x27;厦门&#x27;);<br>alert(Doctor.birthPlaces); //北京, 上海, 香港, 厦门<br>alert(Chinese.birthPlaces); //北京, 上海, 香港<br></code></pre></td></tr></table></figure>
<p>目前，jQuery库使用的就是这种继承方法。<br>（完）</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底理解JavaScript同步|异步|事件循环(EventLoop)</title>
    <url>/2017/12/06/javascript_sync_async_event-loop/</url>
    <content><![CDATA[<h3 id="JavaScript：彻底理解同步、异步和事件循环-Event-Loop"><a href="#JavaScript：彻底理解同步、异步和事件循环-Event-Loop" class="headerlink" title="JavaScript：彻底理解同步、异步和事件循环(Event Loop)"></a>JavaScript：彻底理解同步、异步和事件循环(Event Loop)</h3><h4 id="为什么JavaScript是单线程？"><a href="#为什么JavaScript是单线程？" class="headerlink" title="为什么JavaScript是单线程？"></a>为什么JavaScript是单线程？</h4><p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？</p>
<p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，渲染DOM的线程和JavaScript执行的线程一定是互斥的。<br>　<br>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。<br>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
<p>虽然JS是单线程的但是浏览器的内核是多线程的，在浏览器的内核中不同的异步操作由不同的浏览器内核模块调度执行，异步操作会将相关回调添加到任务队列中。而不同的异步操作添加到任务队列的时机也不同，如 onclick, setTimeout, ajax 处理的方式都不同，这些异步操作是由浏览器内核的 webcore 来执行的，webcore 包含上图中的3种 webAPI，分别是 DOM Binding、network、timer模块。</p>
<blockquote>
<ul>
<li><code>onclick</code>由浏览器内核的<code>DOM Binding</code>模块来处理，当事件触发的时候，回调函数会立即添加到任务队列中。</li>
</ul>
</blockquote>
<ul>
<li><code>setTimeout</code>会由浏览器内核的<code>timer</code>模块来进行延时处理，当时间到达的时候，才会将回调函数添加到任务队列中。</li>
<li><code>ajax</code>则会由浏览器内核的<code>network</code>模块来处理，在网络请求完成返回之后，才将回调添加到任务队列中。</li>
</ul>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>假设存在一个函数A：<br><code>A(args...);</code><br><strong>同步</strong>：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。例如：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Math.sqrt(2);<br>console.log(&#x27;Hi&#x27;);<br></code></pre></td></tr></table></figure>
<ul>
<li>第一个函数返回时，就拿到了预期的返回值：2的平方根。</li>
<li>第二个函数返回时，就看到了预期的效果：在控制台打印了一个字符串。</li>
</ul>
<p>所以这两个函数都是同步的。</p>
<p><strong>异步</strong>：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。例如：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">fs.readFile(&#x27;foo.txt&#x27;, &#x27;utf8&#x27;, function(err, data) &#123;<br>    console.log(data);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>在上面的代码中，我们希望通过fs.readFile函数读取文件foo.txt中的内容，并打印出来。<br>但是在fs.readFile函数返回时，我们期望的结果并不会发生，而是要等到文件全部读取完成之后。如果文件很大的话可能要很长时间。</p>
<p>下面以AJAX请求为例，来看一下同步和异步的区别：</p>
<ul>
<li><p>异步AJAX：</p>
<blockquote>
<ul>
<li>主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。”</li>
</ul>
</blockquote>
</li>
<li><p>AJAX线程：“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。”</p>
</li>
<li><p>主线程：：“谢谢，你拿到响应后告诉我一声啊。”<br>(接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。)</p>
</li>
<li><p>同步AJAX：</p>
<blockquote>
<ul>
<li>主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。”</li>
</ul>
</blockquote>
</li>
<li><p>AJAX线程：“……”</p>
</li>
<li><p>主线程：：“喂，AJAX线程，你怎么不说话？”</p>
</li>
<li><p>AJAX线程：“……”</p>
</li>
<li><p>主线程：：“喂！喂喂喂！”</p>
</li>
<li><p>AJAX线程：“……”</p>
</li>
</ul>
<ul>
<li>(一炷香的时间后…)</li>
</ul>
<ul>
<li>主线程：：“喂！求你说句话吧！”</li>
<li>AJAX线程：“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。”</li>
</ul>
<p>正是由于JavaScript是单线程的，而异步容易实现非阻塞，所以在JavaScript中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。</p>
<h4 id="异步过程的构成要素"><a href="#异步过程的构成要素" class="headerlink" title="异步过程的构成要素"></a>异步过程的构成要素</h4><p>从上文可以看出，异步函数实际上很快就调用完成了。但是后面还有工作线程执行异步任务、通知主线程、主线程调用回调函数等很多步骤。我们把整个过程叫做异步过程。异步函数的调用在整个异步过程中，只是一小部分。</p>
<p>总结一下，一个异步过程通常是这样的：</p>
<blockquote>
<p>主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p>
</blockquote>
<p>异步函数通常是这样的形式：<code>A(args..., callbackFn)</code>。<br>它可以叫做异步过程的发起函数，或者叫做异步任务注册函数。<code>args</code>是这个函数需要的参数。<code>callbackFn</code>也是这个函数的参数，但是它比较特殊所以单独列出来。</p>
<p>所以，从主线程的角度看，一个异步过程包括下面两个要素：</p>
<ul>
<li>发起函数(或叫注册函数)A</li>
<li>回调函数callbackFn</li>
</ul>
<p>它们都是在主线程上调用的，其中注册函数用来发起异步过程，回调函数用来处理结果。</p>
<p>举个具体的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">setTimeout(fn, 1000);<br></code></pre></td></tr></table></figure>
<p>其中的<code>setTimeout</code>就是异步过程的发起函数，<code>fn</code>是回调函数。<br><strong>注意</strong>：前面说的形式<code>A(args..., callbackFn)</code>只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var xhr = new XMLHttpRequest();<br>xhr.open(&#x27;GET&#x27;, url);<br>xhr.onload = xxx; // 添加回调函数<br>xhr.onerror = xxx; // 添加回调函数<br>xhr.send(); // 发起函数<br></code></pre></td></tr></table></figure>
<p>发起函数和回调函数就是分离的，发起函数和回调函数位置互换也是不影响的。也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取“任务队列”。</p>
<h4 id="消息队列和事件循环"><a href="#消息队列和事件循环" class="headerlink" title="消息队列和事件循环"></a>消息队列和事件循环</h4><p>上文讲到，异步过程中，工作线程在异步操作完成后需要通知主线程。那么这个通知机制是怎样实现的呢？答案是利用消息队列和事件循环。用一句话概括：</p>
<blockquote>
<p>工作线程将消息放到消息队列，主线程通过事件循环过程去取消息。</p>
</blockquote>
<ul>
<li>消息队列：消息队列是一个先进先出的队列，它里面存放着各种消息。</li>
<li>事件循环：事件循环是指主线程重复从消息队列中取消息、执行的过程。</li>
</ul>
<p>实际上，主线程只会做一件事情，就是从消息队列里面取消息、执行消息，再取消息、再执行。当消息队列为空时，就会等待直到消息队列变成非空。而且主线程只有在将当前的消息执行完成后，才会去取下一个消息。这种机制就叫做事件循环机制，取一个消息并执行的过程叫做一次循环。伪代码表示类似</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">while (queue.waitForMessage()) &#123;<br>  queue.processNextMessage();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果当前没有任何消息queue.waitForMessage 会等待同步消息到达。<sapn id='异步机制'>执行机制如下：</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li>
<li>主线程之外，还存在一个“任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li>
<li>一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li>
<li>主线程不断重复上面的第三步。<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131839-js%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97.jpg" alt="processEvent&amp;eventQueue"></li>
</ol>
<h5 id="执行至完成"><a href="#执行至完成" class="headerlink" title="执行至完成"></a>执行至完成</h5><p>每一个消息完整的执行后，其它消息才会被执行。当你分析你的程序时，这点提供了一些优秀的特性，包括每当一个函数运行时，该函数占用的(线程)资源不能被抢占，并且在其他代码运行之前完全运行（且可以修改此函数操作的数据）。这与C语言不同，例如，如果函数在线程中运行，则可以在任何位置终止然后在另一个线程中运行其他代码。<br>　<br>这个模型的一个缺点在于当一个消息需要太长时间才能完成，Web应用无法处理用户的交互，例如点击或滚动。一个很好的做法是使消息处理缩短，如果可能，将一个消息裁剪成几个消息。</p>
<h4 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a>添加消息</h4><p>在浏览器里，当一个事件出现且该对象(<code>this</code>)绑定了事件监听器，消息可能随时被添加。如果没有事件监听器，事件该会丢失。所以点击一个附带点击事件处理函数的元素会添加一个消息。其它事件亦然。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var button = document.getElement(&#x27;#btn&#x27;);<br>button.addEventListener(&#x27;click&#x27;, function(e) &#123;<br>    console.log();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>从事件的角度来看，上述代码表示：<strong>在按钮上添加了一个鼠标单击事件的事件监听器；当用户点击按钮时，鼠标单击事件触发，事件监听器函数被调用</strong>。</p>
<p>从异步过程的角度看，**<code>addEventListener</code>函数就是异步过程的发起函数，事件监听器函数就是异步过程的回调函数。事件触发时，表示异步任务完成，会将事件监听器函数封装成一条消息放到消息队列中，等待主线程执行**。</p>
<p>从生产者与消费者的角度看，异步过程是这样的：<strong>工作线程是生产者，主线程是消费者(只有一个消费者)。工作线程执行异步任务，执行完成后把对应的回调函数封装成一条消息放到消息队列中；主线程不断地从消息队列中取消息并执行，当消息队列空时主线程阻塞，直到消息队列再次非空</strong>。</p>
<p>事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。我觉得它的存在是为了编程接口对开发者更友好。</p>
<p>另一方面，所有的异步过程也都可以用事件来描述。例如：<code>setTimeout</code>可以看成对应一个<code>时间到了！</code>的事件。前文的<code>setTimeout(fn, 1000);</code>可以看成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">timer.addEventListener(&#x27;timeout&#x27;, 1000, fn);<br></code></pre></td></tr></table></figure>
<p>调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout消息必须等待其它消息处理完。因此第二个参数仅仅表示需要等待的最小时间,而非确切的时间。</p>
<h5 id="零延迟"><a href="#零延迟" class="headerlink" title="零延迟"></a>零延迟</h5><p>零延迟并不是意味着回调会立即执行。在零延迟调用 setTimeout 时，并不是过了给定的时间间隔后就马上执行回调函数。其等待的时间基于队列里正在等待的消息数量。在下面的例子中，”this is just a message” 将会在回调 (callback) 获得处理之前输出到控制台，这是因为延迟是要求运行时 (runtime) 处理请求所需的最小时间，但不是有所保证的时间。👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">(function () &#123;<br><br>    console.log(&#x27;this is the start&#x27;);<br>    setTimeout(function cb() &#123;<br>        console.log(&#x27;this is a msg from call back&#x27;);<br>    &#125;);<br>    console.log(&#x27;this is just a message&#x27;);<br>    setTimeout(function cb1() &#123;<br>        console.log(&#x27;this is a msg from call back1&#x27;);<br>    &#125;, 0);<br>    console.log(&#x27;this is the  end&#x27;);<br><br>&#125;)();<br><br>// &quot;this is the start&quot;<br>// &quot;this is just a message&quot;<br>// &quot;this is the end&quot;<br>// &quot;this is a msg from call back&quot;<br>// &quot;this is a msg from call back1&quot;<br></code></pre></td></tr></table></figure>
<p>…<br>扯远了，，那么，消息队列中放的消息具体是什么东西？消息的具体结构当然跟具体的实现有关，但是为了简单起见，我们可以认为：</p>
<blockquote>
<p>消息就是注册异步任务时添加的回调函数。</p>
</blockquote>
<p>再次以异步AJAX为例，假设存在如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$.ajax(&#x27;http://segmentfault.com&#x27;, function(resp) &#123;<br>    console.log(&#x27;我是响应：&#x27;, resp);<br>&#125;);<br><br>// 其他代码<br>...<br>...<br>...<br></code></pre></td></tr></table></figure>
<p>主线程在发起AJAX请求后，会继续执行其他代码。AJAX线程负责请求segmentfault.com，拿到响应后，它会把响应封装成一个JavaScript对象，然后构造一条消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// 消息队列中的消息就长这个样子<br>var message = function () &#123;<br>    callbackFn(response);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中的<code>callbackFn</code>就是前面代码中得到成功响应时的回调函数。<br>　<br>主线程在执行完当前循环中的所有代码后，就会到消息队列取出这条消息(也就是message函数)，并执行它。到此为止，就完成了工作线程对主线程的通知，回调函数也就得到了执行。如果一开始主线程就没有提供回调函数，AJAX线程在收到HTTP响应后，也就没必要通知主线程，从而也没必要往消息队列放消息。如图👇<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131839-event-loop.png" alt="event-loop"></p>
<p>主线程从任务队列中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。<br>为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲<a href="http://vimeo.com/96425312">《Help, I’m stuck in an event-loop》</a>）。<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131839-eventLoop.png" alt="eventLoop"><br>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些事件所对应的回调函数。</p>
<h4 id="永不阻塞"><a href="#永不阻塞" class="headerlink" title="永不阻塞"></a>永不阻塞</h4><p>事件循环模型的一个非常有趣的特性是 JavaScript，与许多其他语言不同，它永不阻塞。 处理 I&#x2F;O 通常通过事件和回调来执行，所以当一个应用正等待IndexedDB查询返回或者一个 XHR 请求返回时，它仍然可以处理其它事情，如用户输入。<br>　Rime<br>例外是存在的，如 alert或者同步 XHR，但应该尽量避免使用它们。注意，<a href="https://stackoverflow.com/questions/2734025/is-javascript-guaranteed-to-be-single-threaded/2734311#2734311">例外的例外也是存在的</a>（但通常是实现错误而非其它原因）。</p>
<hr>
<p>文章引自：</p>
<ol>
<li><a href="https://segmentfault.com/a/1190000004322358">https://segmentfault.com/a/1190000004322358</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop</a></li>
</ol>
<p>　
　</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>认知&amp;赚钱</title>
    <url>/2023/12/16/knowledge&amp;make-money/</url>
    <content><![CDATA[<p><strong>你永远赚不到</strong></p>
<p><strong>超出你认知范围外的钱</strong></p>
<p>除非你靠运气</p>
<p>但是靠运气赚到的钱</p>
<p>最好往往又会靠实力亏掉</p>
<p>这是一种必然</p>
<p>你所赚的每一分钱</p>
<p>都是你对这个世界的认知的变现</p>
<p>你所亏的每一分钱</p>
<p>都是因为对这个世界认知有缺陷</p>
<p>这个世界最大的公平在于</p>
<p>当一个人的财富大于自己认知的时候</p>
<p>这个社会有100种方法收割你</p>
<p>直到你的认知和财富相匹配为止</p>
]]></content>
      <categories>
        <category>摘</category>
      </categories>
      <tags>
        <tag>认知</tag>
      </tags>
  </entry>
  <entry>
    <title>关于『该公众号提供的服务出现故障，请稍后再试』</title>
    <url>/2018/10/11/mistake_in_Wechat-public-account_passvely_reply_text_message/</url>
    <content><![CDATA[<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>按照惯例先说上下文环境，，<br>是这样，，公司需要做个功能:</p>
<blockquote>
<p>对ERP用户和公司公众号用户做映射，然后向该用户推送相应角色的经营日报模板消息。</p>
<p>实现流程:<br>1.<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1443433542">通过微信接口生成带参二维码</a>;<br>2.用户用微信扫一扫功能扫描生成的带参二维码;<br>3.获取二维码中的客户识别码和用户的openid;<br>4.被动<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140543">回复用户文本消息</a>(附超链接),引导用户完成绑定过程。</p>
</blockquote>
<h4 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h4><p>总的来说是没啥难度的，，过程还算顺利。有两点值得一提，，</p>
<h5 id="关于授权流程"><a href="#关于授权流程" class="headerlink" title="关于授权流程"></a>关于授权流程</h5><p>最开始的时候，是想让用户扫码之后直接跳转到绑定页面，完美~<br>然鹅，事实并非这样，，正常我们用浏览器、相机等APP扫描二维码的时候，如果二维码内容是链接的话，有的会直接访问，有的会提示是否访问这个链接。然而，<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141013">在微信中扫描二维码分为两种情况</a>，，</p>
<blockquote>
<ol>
<li><strong>scancode_push</strong>：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。</li>
<li><strong>scancode_waitmsg</strong>：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。</li>
</ol>
</blockquote>
<h6 id="scancode-push"><a href="#scancode-push" class="headerlink" title="scancode_push"></a>scancode_push</h6><p>倘若我们使用 scancode_push 的方式，，OK，如果二维码内容是URL的话，可以直接访问。但如此，，我们就不能使用微信生成带参二维码的接口生成二维码了，，因为，这种方式生成的二维码内容本质上是微信的链接:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ticket&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;gQH47joAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2taZ2Z3TVRtNzJXV1Brb3ZhYmJJAAIEZ23sUwMEmm</span><br><span class="hljs-string">3sUw==&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;expire_seconds&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://weixin.qq.com/q/kZgfwMTm72WWPkovabbI&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>ticket: 获取的二维码ticket，凭借此ticket可以在有效时间内换取二维码。<br>expire_seconds: 该二维码有效时间，以秒为单位。 最大不超过2592000（即30天）。<br><strong>url: 二维码图片解析后的地址，开发者可根据该地址自行生成需要的二维码图片</strong></p>
</blockquote>
<p>访问 URL 的链接无论如何是不能指向我们的绑定页面的。PASS！<br>那如果用其他工具把指向绑定页面的链接做成二维码呢？如此就可以访问页面了，，但是！！我们就获取不到用户的OpenID了。。因为，亲测这种方式是用户先访问页面(页面已然渲染好了)，然后下发通知(获取到openid)，，这样，页面还是无法获取到openid。。</p>
<h6 id="scancode-waitmsg"><a href="#scancode-waitmsg" class="headerlink" title="scancode_waitmsg"></a>scancode_waitmsg</h6><p>看样子只能使用 scancode_waitmsg，这种方式既可以获取客户识别码，又可以获取到用户openid，，然鹅，之后只能下发消息，不能直接跳转到指定页面。在一堆汉字文本中显示链接真的好吗？！<br>就在这时，，【花点时间】给我推送消息了(其实我更喜欢『花加』,笑哭)。同样是文本消息，但是有超链接！！</p>
<h5 id="文本消息中的链接优雅的显示方式"><a href="#文本消息中的链接优雅的显示方式" class="headerlink" title="文本消息中的链接优雅的显示方式"></a>文本消息中的链接优雅的显示方式</h5><p>对，，就是超链接，而不是赤果果的将网址堆在一堆汉字中。</p>
<p>实现起来很简单，，就是把链接放在 a 标签的 href 属性中，剩下的就是拼接字符串儿了。。</p>
<h4 id="终于到正题儿了"><a href="#终于到正题儿了" class="headerlink" title="终于到正题儿了"></a>终于到正题儿了</h4><p>终于，，然而，为什么每次收到文本消息前总是报错？<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131835-%E8%A2%AB%E5%8A%A8%E5%9B%9E%E5%A4%8D%E6%96%87%E6%9C%AC%E6%B6%88%E6%81%AF%E6%8A%A5%E9%94%99.jpeg" alt="被动回复文本消息"></p>
<p>本以为是ngrok不稳定的原因，，但报错问题出现的太规律了，应该不是它(事实上它太稳定了，感谢开源！)。<br>直到看到了<a href="https://blog.csdn.net/buoll/article/details/54150865">微信开发出现“该公众号暂时无法提供服务，请稍后再试”的坑</a>，虽然最终遇到的问题不一样，但还是收到启发了，，那就是『第三方平台授权』的问题。因为我司之前做模板小程序的时候真的有将『北京众阳软件』公众号授权给『众阳宜商信息技术有限公司』第三方平台，，做授权测试嘛。但我记得后来改为只授权公众号的『开放平台账号管理权限』，其他权限都取消了呀？！咦，，登陆公众号微信后台之后，在『功能』-&gt;『自动回复』&gt;&gt;『被关注回复』中看到有第三方平台授权管理。哦，原来还有其他第三方平台，，唤作『魔盒』什么的。其中就将公众号的『消息回复』权限。怪不得，，每次被动回复前，先向『魔盒』服务器下发消息，失败后再向公众号服务器地址下发消息。所以，，每次所谓的服务器出现故障，是魔盒的问题！</p>
<p>Binggo！！取消授权之后，一切都那么清净~</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>微信公众号</tag>
        <tag>被动回复用户消息</tag>
      </tags>
  </entry>
  <entry>
    <title>my first shot</title>
    <url>/2017/10/02/my_first_shot/</url>
    <content><![CDATA[<p>hello world!<br>from Shang.</p>
]]></content>
      <categories>
        <category>呓语</category>
      </categories>
  </entry>
  <entry>
    <title>邮件报警的简单实现</title>
    <url>/2018/09/20/simple_implementation_of_email_early_warning/</url>
    <content><![CDATA[<p>其实，log4j就可以实现邮件报警功能，只需要简单的配置即可。其实，不光可以发邮件，还可以通过sockets将日志文件发送到网络中的指定地址。具体查看log4j的各个appender就好啦。error级别的日志发送邮件配置👇</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># Error级别的日志发送邮件<br>log4j.appender.MAIL=org.apache.log4j.net.SMTPAppender<br>log4j.appender.MAIL.Threshold=ERROR<br>log4j.appender.MAIL.BufferSize=10<br>log4j.appender.MAIL.From=189********@163.com<br>log4j.appender.MAIL.SMTPHost=smtp.163.com<br>log4j.appender.MAIL.Subject=Error Message from *** Project<br># 可以发送多个用户中间用,去分隔<br>log4j.appender.MAIL.To=destination0@qq.com,destination1@qq.com<br># 邮箱帐号<br>log4j.appender.MAIL.SMTPUsername=189********@163.com<br># 邮箱密码<br>log4j.appender.MAIL.SMTPPassword=authcode<br>log4j.appender.MAIL.layout=org.apache.log4j.PatternLayout<br>log4j.appender.MAIL.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH\:mm\:ss&#125; [%c]-[%p] [%t] (%F\:%L) %X&#123;merchant_id&#125; -&gt;%m %n<br></code></pre></td></tr></table></figure>


<p><strong>(PS：本篇内容无具体实现，只有实现思路)</strong></p>
<p>(PPS: PS 是 postscript 的缩写，笑哭)</p>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>我司主力项目托管在阿里云服务器，有些业务需要调用客户服务器的一些接口(以HTTP请求的方式，，理论上效率并不是非常好，传说使用netty会好一些，挖坑待实现)。主力项目主要做统筹工作，类似微信开放平台中的第三方平台，然后客户授权相关权限给我司，然后我司代实现其业务逻辑，，但商品数据存放在用户服务器的数据库中，倘若将所有用户的商品数据同步到阿里云线上，一则是没必要，二则所有客户的商品数据也是不小的体量，三则也可能会有客户不希望将自己的数据代托管，，种种。所以采用的这种方式。</p>
<p>于是，需求出现了，，为了保证阿里云服务器中的项目与客户服务器通讯的可靠性，需保证调用出现异常时，开发人员及时知晓并fix bug。所以异常报警势在必行。</p>
<p>有点意思，，让我来~</p>
<h4 id="开头难"><a href="#开头难" class="headerlink" title="开头难"></a>开头难</h4><p>于是，开始网上了解相关解决方案，，得到的大部分都服务器状态监测相关，比如<em>zabbix</em>、<em>nagios</em>(虽然不知道这俩货具体是啥。。待我用自己的服务器练练手先)。看上去比较『重』，，因为我目前只需要邮件报警的功能，，主要是我司服务器是 Windows 的。。</p>
<p>好吧，这条路暂时走不通了。</p>
<h4 id="想想其他办法"><a href="#想想其他办法" class="headerlink" title="想想其他办法"></a>想想其他办法</h4><p>异常报警，，那肯定是捕捉到异常之后的处理，所以应该在 catch 块儿中实现相关报警代码就行。按照<a href="https://blog.csdn.net/weixin_36751895/article/details/79411780">java 使用JavaMail 做异常邮件报警 ，支持163邮箱、outlook邮箱</a>中代码实现即可。后来发现项目框架中有相关的 MailUtil 工具类，倒是省事儿。虽然上面博客中的代码并未复用，但至少让我看到了成功的希望。然而，，实现<em>RuntimeException</em>，然后捕捉到异常后抛出新实现的异常类，，真的有必要么??我在捕捉到异常之后，为什么不直接发送邮件，反而继续向上层抛异常？上层还有未捕获异常的处理？？至少我的项目中没有；另外，，如果在每个方法中去<code>try&#123;&#125;catch(e)&#123;&#125;</code>，需要改动每个相关接口代码，太不优雅了。。</p>
<p>有没有一种一劳永逸的方法，，一处设置，处处生效？？我首先想到的是过滤器，，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>   doFilter();<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  e.printStackTrace();<br>  <span class="hljs-comment">// 邮件报警</span><br>  <span class="hljs-comment">// 短信报警</span><br>  <span class="hljs-comment">// bulabula</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>但实现之后，发现异常并没有被抛出到过滤器中，，直接被其他逻辑catch捕捉处理了，，额。那就在 Route(或Controller) 级别的拦截器中处理，，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  invocation.invoke();<br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  <span class="hljs-comment">// 报警bulabula</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>完美！！然鹅，，业务中调用客户服务器中的接口需返回值，丫的！！<br>　<br>另外，所有与客户服务器交互的方法全被写在了 API.java 中，，其他业务中直接静态调用相应的方法即可。所以，用 Controller 级别的拦截器还不行。。</p>
<p>权衡之下，最终以 action 为单位，自定义 catch 逻辑，返回相应的错误代码调用封装好的发送报警邮件的方法。同理，短信报警及其他报警形式。具体实现其实没什么难的，这里梳理下思路。</p>
<hr>
<p>参考链接：<a href="https://blog.csdn.net/weixin_36751895/article/details/79411780">java 使用JavaMail 做异常邮件报警 ，支持163邮箱、outlook邮箱</a></p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>邮件预警</tag>
      </tags>
  </entry>
  <entry>
    <title>关于java中的序列化</title>
    <url>/2018/01/13/serialization_and_deserialization_of_java/</url>
    <content><![CDATA[<h3 id="关于java中的序列化"><a href="#关于java中的序列化" class="headerlink" title="关于java中的序列化"></a>关于java中的序列化</h3><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>最近在精简项目代码，去除无用的依赖以及没有没有使用的模块。这其中免不了删除实体类中的无效字段。于是，，问题来了：<span id="context"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java.io.InvalidClassException: entity.User; local <span class="hljs-keyword">class</span> <span class="hljs-title class_">incompatible</span>: stream <span class="hljs-type">classdesc</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8550471390860600205</span>, local <span class="hljs-keyword">class</span> <span class="hljs-title class_">serialVersionUID</span> = -<span class="hljs-number">7433272285406297333</span><br></code></pre></td></tr></table></figure>

<h4 id="用户未登录？"><a href="#用户未登录？" class="headerlink" title="用户未登录？"></a>用户未登录？</h4><p>改完之后，在测试某接口的时候，只是返回用户未登录的信息，没想太多，，于是调用模拟测试账号登录行为的接口，然后重新测试刚才的接口，但还是返回用户未登录的信息。。</p>
<p>这就怪了，，正常来说，用户在正常登陆时，通过SQL查到用户信息后，保存部分字段到Redis中，之后每次用户发送请求时直接通过用户ID从Redis中获取用户相关信息。所以，，首先怀疑的是用户在登陆后发送其他请求时，通过Redis获取用户信息时出问题了，然后一点点看代码。调试到这儿的时候发生问题了👇</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bais</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 反序列化</span><br>    bais = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>    <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bais);<br>    <span class="hljs-keyword">return</span> ois.readObject();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">//Tools.error(e);</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure>
<p>👆这是从Redis中获取用户信息后的反序列化时的部分代码，，正常来说，应该是返回从流中反序列化后得到的User实例。但实际调试过程中，运行到第6行之后，又跳到第10行，，咦，什么鬼？？两个<code>return</code>？？嗯，，当然不是，肯定是在<code>ois.readObject()</code>报错了，再看第8行，妈蛋，，打印报错信息的代码被注释了！OK，反注释之后就出现了<a href="#context">Context</a>中的报错信息。</p>
<h4 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h4><p>报错信息大意为，，entity.User中本地类文件冲突，流中的类描述serialVersionUID与本地相应类的描述serialVersionUID不一致。出于安全考虑，反序列化失败。<br>关于序列化，之前不甚了解，，正好借此机会好好了解下~</p>
<h5 id="什么时候使用序列化"><a href="#什么时候使用序列化" class="headerlink" title="什么时候使用序列化"></a>什么时候使用序列化</h5><ol>
<li>把的内存中的对象持久化到一个文件中或者数据库中时候；</li>
<li>套接字在网络上传送对象的时候；</li>
</ol>
<p><code>serialVersionUID</code>适用于Java的序列化机制。简单来说，Java 的序列化机制是通过判断类的<code>serialVersionUID</code>来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的<code>serialVersionUID</code>与本地相应实体类的<code>serialVersionUID</code>进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是<code>InvalidCastException</code>。</p>
<p>serialVersionUID有两种显示的生成方式：        </p>
<ol>
<li>默认的1L，比如：<code>private static final long serialVersionUID = 1L</code>;        </li>
<li>根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如：<br><code>private static final long serialVersionUID = xxxxL</code>;</li>
</ol>
<p>当一个类实现了<code>Serializable</code>接口，如果没有显示的定义<code>serialVersionUID</code>，Eclipse 会提供相应的提醒。面对这种情况，我们只需要在 Eclipse 中点击类中 warning 图标一下，Eclipse就会自动给定两种生成的方式。</p>
<p>当实现 java.io.Serializable 接口的类没有显式地定义一个<code>serialVersionUID</code>变量时候，Java序列化机制会根据编译的 Class 自动生成一个<code>serialVersionUID</code>作序列化版本比较用，这种情况下，如果 Class 文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，<code>serialVersionUID</code>也不会变化的。</p>
<p>所以，在项目中 User 类中并没有显式的定义<code>serialVersionUID</code>。所以，在我精简代码后，<code>serialVersionUID</code>发生变化，导致反序列化失败。解决方法也很简单，，显式声明与流中相同的<code>serialVersionUID</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8550471390860600205L</span>;<br></code></pre></td></tr></table></figure>

<h4 id="静态变量序列化"><a href="#静态变量序列化" class="headerlink" title="静态变量序列化"></a>静态变量序列化</h4><p>下面代码中<code>Test</code>实体类实现了<code>Serializable</code>接口，并初始化了一个静态变量<code>staticVar</code>。将对象序列化后，修改静态变量的数值，再将序列化对象读取出来，然后通过读取出来的对象获得静态变量的数值并打印出来那么结果是 10 还是 5 呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//初始时staticVar为5</span><br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;result.obj&quot;</span>));<br>            out.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>());<br>            out.close();<br><br>            <span class="hljs-comment">//序列化后修改为10</span><br>            Test.staticVar = <span class="hljs-number">10</span>;<br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">oin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;result.obj&quot;</span>));<br>            <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (Test) oin.readObject();<br>            oin.close();<br>            <br>            <span class="hljs-comment">//再读取，通过t.staticVar打印新的值</span><br>            System.out.println(t.staticVar);<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最后的输出是 10，对于无法理解的读者认为，打印的 staticVar 是从读取的对象里获得的，应该是保存时的状态才对。之所以打印 10 的原因在于序列化时，并不保存静态变量，这其实比较容易理解，<strong>序列化保存的是对象的状态，静态变量属于类的状态</strong>，因此序列化并不保存静态变量。</p>
<p>但是，<code>serialVersionUID</code>也是<code>static</code>的，那它是怎么被保存的呢？在jdk_7中，，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java.io.ObjectOutputStream<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Writes class descriptor representing a standard (i.e., not a dynamic</span><br><span class="hljs-comment"> * proxy) class to stream.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeNonProxyDesc</span><span class="hljs-params">(ObjectStreamClass desc, <span class="hljs-type">boolean</span> unshared)</span><br>    <span class="hljs-keyword">throws</span> IOException<br>&#123;<br>    bout.writeByte(TC_CLASSDESC);<br>    handles.assign(unshared ? <span class="hljs-literal">null</span> : desc);<br><br>    <span class="hljs-keyword">if</span> (protocol == PROTOCOL_VERSION_1) &#123;<br>        <span class="hljs-comment">// do not invoke class descriptor write hook with old protocol</span><br>        desc.writeNonProxy(<span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        writeClassDescriptor(desc);<br>    &#125;<br><br>    <span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> desc.forClass();<br>    bout.setBlockDataMode(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (cl != <span class="hljs-literal">null</span> &amp;&amp; isCustomSubclass()) &#123;<br>        ReflectUtil.checkPackageAccess(cl);<br>    &#125;<br>    annotateClass(cl);<br>    bout.setBlockDataMode(<span class="hljs-literal">false</span>);<br>    bout.writeByte(TC_ENDBLOCKDATA);<br><br>    writeClassDesc(desc.getSuperDesc(), <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-comment">/*将指定的类描述符写入 ObjectOutputStream。类描述符用于标识写入流中的对象的类。ObjectOutputStream 的子类可以重写此方法，从而定制将类描述符写入序列化流中的方式。然后，应该重写 ObjectInputStream 中的相应方法（ readClassDescriptor），以便根据其定制的流表示形式来重构类描述符。默认情况下，此方法根据 Object Serialization 规范中定义的格式写入类描述符。*/</span><br><span class="hljs-comment">/*注意，仅当 ObjectOutputStream 没有使用旧的序列化流格式（通过调用 ObjectOutputStream 的 useProtocolVersion 方法设置）时才调用此方法。如果此序列化流在使用旧的格式（即 PROTOCOL_VERSION_1），则以不可重写或自定义的方式在内部写入类描述符。*/</span><br><br>java.io.ObjectStreamClass<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Writes non-proxy class descriptor information to given output stream.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">writeNonProxy</span><span class="hljs-params">(ObjectOutputStream out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    out.writeUTF(name);<br>    out.writeLong(getSerialVersionUID());<span class="hljs-comment">//写入获取的serialVersionUID</span><br><br>    <span class="hljs-type">byte</span> <span class="hljs-variable">flags</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (externalizable) &#123;<br>        flags |= ObjectStreamConstants.SC_EXTERNALIZABLE;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">protocol</span> <span class="hljs-operator">=</span> out.getProtocolVersion();<br>        <span class="hljs-keyword">if</span> (protocol != ObjectStreamConstants.PROTOCOL_VERSION_1) &#123;<br>            flags |= ObjectStreamConstants.SC_BLOCK_DATA;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (serializable) &#123;<br>        flags |= ObjectStreamConstants.SC_SERIALIZABLE;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (hasWriteObjectData) &#123;<br>        flags |= ObjectStreamConstants.SC_WRITE_METHOD;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isEnum) &#123;<br>        flags |= ObjectStreamConstants.SC_ENUM;<br>    &#125;<br>    out.writeByte(flags);<br><br>    out.writeShort(fields.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; fields.length; i++) &#123;<br>        <span class="hljs-type">ObjectStreamField</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> fields[i];<br>        out.writeByte(f.getTypeCode());<br>        out.writeUTF(f.getName());<br>        <span class="hljs-keyword">if</span> (!f.isPrimitive()) &#123;<br>            out.writeTypeString(f.getTypeString());<br>        &#125;<br>    &#125;<br>&#125;<br><br>java.io.ObjectStreamClass<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return the serialVersionUID for this class.  The serialVersionUID</span><br><span class="hljs-comment"> * defines a set of classes all with the same name that have evolved from a</span><br><span class="hljs-comment"> * common root class and agree to be serialized and deserialized using a</span><br><span class="hljs-comment"> * common format.  NonSerializable classes have a serialVersionUID of 0L.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  the SUID of the class described by this descriptor</span><br><span class="hljs-comment"> * 回此类的 serialVersionUID。serialVersionUID 定义了一组具有相同名称的类，它们的名称都是从公共根类演化而来的，并且能够使用公共格式进行序列化和反序列化。NonSerializable 类的 serialVersionUID 为 0L。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getSerialVersionUID</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// REMIND: synchronize instead of relying on volatile?</span><br>    <span class="hljs-keyword">if</span> (suid == <span class="hljs-literal">null</span>) &#123;<br>        suid = AccessController.doPrivileged(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Long&gt;() &#123;<br>                <span class="hljs-keyword">public</span> Long <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-keyword">return</span> computeDefaultSUID(cl);<br>                &#125;<br>            &#125;<br>        );<br>    &#125;<br>    <span class="hljs-keyword">return</span> suid.longValue();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除此之外，，<code>transient</code>关键字修饰的变量也不会被序列化。</p>
<h4 id="父类的序列化"><a href="#父类的序列化" class="headerlink" title="父类的序列化"></a>父类的序列化</h4><p>context：一个子类实现了<code>Serializable</code>接口，它的父类都没有实现<code>Serializable</code>接口，序列化该子类对象，然后反序列化后输出父类定义的某变量的数值，该变量数值与序列化时的数值不同。</p>
<p>解决：要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code>接口。如果父类不实现的话的，就需要有默认的无参的构造函数。在父类没有实现<code>Serializable</code>接口时，虚拟机是不会序列化父对象的，而一个 Java 对象的构造必须先有父对象，才有子对象，反序列化也不例外。所以反序列化时，为了构造父对象，只能调用父类的无参构造函数作为默认的父对象。因此当我们取父对象的变量值时，它的值是调用父类无参构造函数后的值。如果你考虑到这种序列化的情况，在父类无参构造函数中对变量进行初始化，否则的话，父类变量值都是默认声明的值，如 int 型的默认是 0，string 型的默认是 null。</p>
<p>另外，，如果父类已经实现<code>Serializable</code>接口，其子类就无需再显式的实现<code>Serializable</code>接口了。</p>
<hr>
<p>参考链接：<a href="https://www.cnblogs.com/duanxz/p/3511695.html">https://www.cnblogs.com/duanxz/p/3511695.html</a> - 学无止境</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>2018-01 小结</title>
    <url>/2018/01/30/summary_of_2018_1st/</url>
    <content><![CDATA[<h3 id="2018年1月份小结"><a href="#2018年1月份小结" class="headerlink" title="2018年1月份小结"></a>2018年1月份小结</h3><p>最近一直在忙小程序的事情，也是公司的新项目。因为之前小程序的入口一直很深，使用起来比较麻烦，所以也没重视起来，，但是今年1月份，微信突然更新之后，有了『社交』小游戏–跳一跳，在朋友圈好一波刷屏。但对于我们来说，，最惹眼球的莫过于微信首页下拉呼出recent小程序。如此一来，小程序的使用场景顿时多了起来，公司也开始重视起来。</p>
<p>其实之前自己也一直想做一个小程序的，用来收集自己的位置信息，，当然位置数据是自己主动提交的。如此，就可以做阶段性的总结了，比如生成个全年范围内的热力图什么的，看看自己过去一年中都在什么地方消耗时间了~</p>
<p>其实，还想用小程序做另外一个项目的，关于LBS的，，已经把后台框架搭起来了，使用的Spring + Spring MVC + Mongodb；Spring 和 Spring MVC已经好久没用过(<del>好吧，，Spring和Spring MVC第一次用，在学校时老师还没教，就出来找工作了</del>)了，Mongodb更是从来没有接触过，所以一切从头开始。做完上个用纯Servlet搭的项目，感觉思维已经被禁锢了。。<br>不过，这个框架也挺有意思的，好像做游戏开发的都这样做，，整个项目只有一个Servlet，每个请求都带有一个messageId参数，不同的 messageId 代表不同的 Controler (中的不同的业务)，message中包含了所有的请求信息和用户的session，然后将message实例注入到相应messageId对应的接口所在的Controler中进行操作。</p>
<blockquote>
<p>用户请求 -》装配message -》将message以动态代理的方式注入相应的Controler -》根据message中的messageId，找到对应的接口 -》执行业务逻辑代码</p>
</blockquote>
<p>第一次见到这种『框架』，还是蛮受启发的。因为是某前辈程序员自己搭的，就是坑多了点儿，耦合也比较严重。。</p>
<p>关于Mongodb，，当初学 MySQL 的时候，老师提到这是一种关系型数据库，与之相对的还有『非关系型数据库』，即NoSQL(全称Not Only SQL)。当时提到了Mongodb，觉得这个数据库名字特别好听，印象还挺深刻。。但具体它是什么，完全没概念。本来计划继续用 MySQL 的，但是中间想到一个问题，，怎么用 MySQL 在一个字段中存储未知数量的经纬度信息呢？？直接用逗号拼接？觉得不够优雅。。然后在网上看到有网友说可以尝试 Mongodb，而且 Mongodb 中还有原生的地理位置索引，相当方便。于是，就想尝试一下，，欧耶！新的训练集~刷了一遍Mongodb的入门视频，又刷了一遍SSM(Spring + Spring MVC + Mongodb)框架整合视频，然后开始依样画葫芦。有几点记录下：</p>
<ol>
<li>用@Autowried注入，但在调用相关实例的时候总是报错，具体报错信息记不得了，类似<code>org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#39;locationController&#39;: Unsatisfied dependency expressed through field &#39;locationDao&#39;;</code>网上几乎所有的方法都试了，还是不行，各种心灰意冷，，最后在一篇博客中得到启发，，那篇博客好像在讲注入什么的，还通过控制台的日志信息验证自己的想法。噢？然后我也去盯控制台，发现项目启动的时候没有关于Beans注入成功的信息，，丫丫！然后继续往上捣，发现applicationContext.xml没有被正确载入。。。。。重新修改web.xml配置文件路径，搞定！<br><code>Loading XML bean definitions from class path resource [applicationContext.xml]</code><br>…<br><code>Root WebApplicationContext: initialization completed in 1684 ms</code></li>
<li>配置文件中关于 Mongodb 数据库连接的地方，同样，，网上的方法几乎都试了，还是不行。主要是配置文件中提示<code>cvc-complex-type.2.4.c: The matching wildcard is strict, but no declaration can be found for element &#39;mongo:mongo&#39;.</code>最后实在没辙，去 Mongodb 官网翻doc，，<strong>找到相应jar包的版本</strong>，发现人家用的<code>&lt;mongo:mongo-client&gt;</code>标签，不是<code>&lt;mongo:mongo&gt;</code>。。因为这段配置是在网上找的，而且都用的这个标签。。但我一般都会用最新版本的jar包，，好吧。</li>
</ol>
<p>别的还算顺利，，从搭环境到我把第一条位置信息持久化的Mongodb中已经两天了。。。但收获也是满满~</p>
<p>关于微信小程序，，最近好像一直都在做关于前端的东西，博客中最近也分享的大多也是js的内容，但我明明是Java工程师。。。在上面的项目中遇到一个问题，，假如我想定时向数据库中插入位置信息，那常规实现起来可能是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  wx.<span class="hljs-title function_">getLocation</span>(&#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;wgs84&#x27;</span>,<br>      <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>        wx.<span class="hljs-title function_">getLocation</span>(&#123;<br>          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>          <span class="hljs-attr">data</span>: &#123;<br>            ...<br>          &#125;,<br>          <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>          <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>          <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-property">data</span>);<br>          &#125;<br>        &#125;);<br>      &#125;<br>    &#125;);<br>&#125;,<span class="hljs-number">10000</span>);<br></code></pre></td></tr></table></figure>
<p>这样的代码还是很可怕的，很容易陷入回调深渊。。想用<code>Promise</code>或者<code>async</code>和<code>await</code>，又怕某些手机支持到了ES5，于是想着有没有什么很好的解决办法，最好微信小程序也有个框架什么的。在网上做了做功课，发现了腾讯官方在Github上开源的一个框架<code>wepy</code>(<a href="https://tencent.github.io/wepy/document.html#/">微信小程序组件化开发框架WePY官方文档</a>)。然后又开始做功课，看到文档上说是基于<a href="https://cn.vuejs.org/">Vue.js</a>框架，OK，，又去刷Vue的视频。在讲到Vue中的v-model的时候，好像明白一点什么是<a href="https://baike.baidu.com/item/MVVM/96310?fr=aladdin">MVVM</a>框架了。回过头再学wepy，，它像一个框架，又像一个翻译器。说到这儿，感觉又有点像本站所用<a href="https://hexo.io/zh-cn/docs/">Hexo</a>，是一个博客框架。前者将.wyp文件翻译成<code>[.wxml,.wxss,.js,.json]</code>，后者将.md文件翻译成.html文件。这两者应该都是基于node.js。想想以前做前端项目时，完全不是一样的感觉。到目前为止，因为不了解node.js，，我只能说，嗯，有点意思~</p>
<p>另外，，因为小程序代码包不能超过2M，所以今天尝试将目录中的静态资源文件放到服务器中，以节省空间。首先想到的是nginx，公司用的坑爹windows server 2008。事实证明的确坑爹，，已经可以在浏览器中访问本地图片列表了，但是点到某个具体的文件时就开始缓慢请求，最后报504错误。在自己Mac上的nginx模拟了下，虽然中间出了些问题，但最终还是解决了。只能将静态资源放到了tomcat中，不够优雅。。得改。<br>关于在mac中遇到问题，location中alias和root的区别，，</p>
<blockquote>
<p><strong>alias</strong></p>
<hr>
<p>syntax: alias file-path|directory-path;<br>default: no &#x2F;&#x2F; 无默认值<br>context: location &#x2F;&#x2F; 上下文环境，处于location配置项中<br>This directive assigns a path to be used for the indicated location. Note that it may look similar to the</p>
<blockquote>
<p><em><strong>root</strong></em></p>
</blockquote>
<p>&#x2F;&#x2F; 这条命令为表明的位置分配了一个路径。需要注意的是，alias看起来有些像root<br>directive, but the document root doesn’t change, just the file system path used for the request.<br>&#x2F;&#x2F; ？？？，但是文档根路径不会变，仅仅用来响应请求要访问的文件系统路径<br>For example:<br>location &#x2F;i&#x2F; {<br>  alias &#x2F;spool&#x2F;w3&#x2F;images&#x2F;;<br>}<br>The request “&#x2F;i&#x2F;top.gif” will return the file “&#x2F;spool&#x2F;w3&#x2F;images&#x2F;top.gif”.<br>&#x2F;&#x2F; “&#x2F;i&#x2F;top.gif”的请求实际得到的是”&#x2F;spool&#x2F;w3&#x2F;images&#x2F;top.gif”</p>
</blockquote>
<hr>
<blockquote>
<p><strong>root</strong></p>
<hr>
<p>syntax: root path<br>default: root html<br>context: http, server, location, if in location<br>root specifies the document root for the requests. For example, with this configuration<br>location  &#x2F;i&#x2F; {<br>  root  &#x2F;spool&#x2F;w3;<br>}<br>A request for “&#x2F;i&#x2F;top.gif” will return the file “&#x2F;spool&#x2F;w3&#x2F;i&#x2F;top.gif”. You can use variables in the argument.<br>note: Keep in mind that the root will still append the directory to the request so that a request for “&#x2F;i&#x2F;top.gif” will not look in “&#x2F;spool&#x2F;w3&#x2F;top.gif” like might happen in an Apache-like alias configuration where the location match itself is dropped. Use the</p>
<blockquote>
<p>alias</p>
</blockquote>
<p>directive to achieve the Apache-like functionality.　<br>&#x2F;&#x2F; 记住，请求路径仍然会拼接在root所代指的路径后，所以请求”&#x2F;i&#x2F;top.gif”不会在”&#x2F;spool&#x2F;w3&#x2F;top.gif”路径下寻找；类似的像类Apache服务器中的配置???😂???,在类Apache服务器中使用alias来实现类似的功能。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP重传机制</title>
    <url>/2017/11/14/tcp_retransmission_mechanism/</url>
    <content><![CDATA[<h3 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h3><p>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的<code>ACK</code>只会确认最后一个连续的包。比如，发送端发了#1,#2,#3,#4,#5一共五份数据，接收端收到了#1，#2，于是返回<code>ACK</code>&#x3D;3，然后收到了#4（#3未收到），此时的TCP会怎么办？我们要知道，<code>seq</code>和<code>ACK</code>是以字节数为单位，所以返回<code>ack</code>的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。</p>
<h5 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h5><p>一种是不返回<code>ack</code>，死等#3，当发送方发现收不到#3的<code>ack</code>超时后，会重传#3。一旦接收方收到#3后，会<code>ack</code>返回4——意味着#3和#4都收到了。</p>
<p>但是，这种方式会有比较严重的问题，那就是因为要死等#3，所以会导致#4和#5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到<code>ACK</code>，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4#和#5的重传。</p>
<p>对此有两种选择：</p>
<ol>
<li>仅重传 timeout 的包。也就是第3份数据。</li>
<li>重传 timeout 后所有的数据，也就是#3，#4，#5这三份数据。</li>
</ol>
<p>第一种会节省带宽，但是慢；第二种会快一点，但是会浪费带宽，也可能会做无用功。但总体来说都不好。因为都在等 timeout，timeout 可能会很长。</p>
<h4 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h4><p>于是，TCP引入了一种叫 <em>Fast Retransmit</em> 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果包没有连续到达，就<code>ack</code>最后那个可能被丢了的包，如果发送方连续收到3次相同的<code>ack</code>，就重传。<em>Fast Retransmit</em> 的好处是不用等 timeout 了再重传。</p>
<p>比如：如果发送方发出了#1，#2，#3，#4，#5份数据，第一份先到送了，于是就<code>ack</code>回2，结果#2因为某些原因没收到，3到达了，于是还是<code>ack</code>回2，后面的#4和#5都到了，但是还是<code>ack</code>回#2，因为2还是没有收到，于是发送端收到了三个<code>ack</code>&#x3D;2的确认，知道了#2还没有到，于是就马上重传#2。然后，接收端收到了#2，此时因为#3，#4，#5都收到了，于是<code>ack</code>回6。示意图如下：<img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131859-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6.png" alt="快速重传机制"></p>
<p><em>Fast Retransmit</em> 只解决了一个问题，就是timeout 的问题，它依然面临一个艰难的选择，就是重传之前的一个，还是重传所有的问题。对于上面的示例来说，是重传#2呢,还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个<code>ack</code>(#2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从#2到#20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p>
<h4 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h4><p>另外一种更好的方式叫：<em>Selective Acknowledgment</em> (SACK)（参看RFC 2018），这种方式需要在TCP头里加一个<code>SACK</code>的东西，<code>ACK</code>还是<em>Fast Retransmit</em>的	<code>ACK</code>，SACK则是汇报收到的数据碎版。参看下图：<img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131859-SACK.jpg" alt="SACK"></p>
<p>这样，在发送端就可以根据回传的<code>SACK</code>来知道哪些数据到了，哪些没有到。于是就优化了<em>Fast Retransmit</em> 的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p>
<p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端<code>SACK</code>里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖<code>SACK</code>，还是要依赖<code>ACK</code>，并维护Timeout，如果后续的<code>ack</code>没有增长，那么还是要把<code>SACK</code>的东西重传，另外，接收端这边永远不能把<code>SACK</code>的包标记为<code>ACK</code>。</p>
<p>注意：<code>SACK</code>会消费发送方的资源，,试想，如果一个攻击者给数据发送方发一堆<code>SACK</code>的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《TCP SACK的性能权衡》</p>
<h4 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h4><p>Duplicate SACK又称D-SACK，其主要使用了	<code>SACK</code>来告诉发送方有哪些数据被重复接收了。RFC-2833 里有详细描述和示例。下面举几个例子（来源于RFC-2833）</p>
<p><code>D-SACK</code>使用了<code>SACK</code>的第一个段来做标志，如果<code>SACK</code>的第一个段的范围被<code>ACK</code>所覆盖，那么就是<code>D-SACK</code>;如果<code>SACK</code>的第一个段的范围被<code>SACK</code>的第二个段覆盖，那么就是<code>D-SACK</code>。</p>
<h5 id="示例一：ACK丢包"><a href="#示例一：ACK丢包" class="headerlink" title="示例一：ACK丢包"></a>示例一：ACK丢包</h5><p>下面的示例中，丢了两个<code>ACK</code>，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个<code>SACK</code>&#x3D;3000-3500，因为<code>ACK</code>都到了#4000意味着收到了#4000之前的所有数据，所以这个<code>SACK</code>就是<code>D-SACK</code>——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是<code>ACK</code>包。</p>
<blockquote>
<table>
<thead>
<tr>
<th align="center">Transmitted</th>
<th align="center">Received</th>
<th align="center">ACK Sent</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Segment</td>
<td align="center">Segment</td>
<td align="center">(Including SACK Blocks)</td>
</tr>
<tr>
<td align="center">3000-3499</td>
<td align="center">3000-3499</td>
<td align="center">3500 (ACK dropped)</td>
</tr>
<tr>
<td align="center">3500-3999</td>
<td align="center">3500-3999</td>
<td align="center">4000 (ACK dropped)</td>
</tr>
<tr>
<td align="center">3000-3499</td>
<td align="center">3000-3499</td>
<td align="center">4000, SACK&#x3D;3000-3500</td>
</tr>
</tbody></table>
</blockquote>
<h5 id="示例二：网络延误"><a href="#示例二：网络延误" class="headerlink" title="示例二：网络延误"></a>示例二：网络延误</h5><p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到<code>ACK</code>，而后面到达的三个包触发了<em>Fast Retransmit</em> 算法，所以重传，但重传时，被延误的包又到了，所以，回了一个<code>SACK</code>&#x3D;1000-1500，因为<code>ACK</code>已到了#3000，所以，这个<code>SACK</code>是<code>D-SACK</code>——标识收到了重复的包。</p>
<p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。</p>
<table>
<thead>
<tr>
<th align="center">Transmitted</th>
<th align="center">Received</th>
<th align="center">ACK Sent</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Segment</td>
<td align="center">Segment</td>
<td align="center">(Including SACK Blocks)</td>
</tr>
<tr>
<td align="center">500-999</td>
<td align="center">500-999</td>
<td align="center">1000</td>
</tr>
<tr>
<td align="center">1000-1499</td>
<td align="center">(delayed)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">1500-1999</td>
<td align="center">1500-1999</td>
<td align="center">1000, SACK&#x3D;1500-2000</td>
</tr>
<tr>
<td align="center">2000-2499</td>
<td align="center">2000-2499</td>
<td align="center">1000, SACK&#x3D;1500-2500</td>
</tr>
<tr>
<td align="center">2500-2999</td>
<td align="center">2500-2999</td>
<td align="center">1000, SACK&#x3D;1500-3000</td>
</tr>
<tr>
<td align="center">1000-1499</td>
<td align="center">1000-1499</td>
<td align="center">3000</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">1000-1499</td>
<td align="center">3000, SACK&#x3D;1000-1500</td>
</tr>
</tbody></table>
<p>可见，引入了<code>D-SACK</code>，有这么几个好处：</p>
<ol>
<li>可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</li>
<li>是不是自己的 timeout太小了，导致重传。</li>
<li>网络上出现了先发的包后到的情况（又称reordering）</li>
<li>网络上是不是把我的数据包给复制了。</li>
</ol>
<p>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控。<br>Linux下的<code>tcp_dsack</code>参数用于开启这个功能（Linux 2.4后默认打开）</p>
<hr>
<p>转载自：<a href="http://www.uml.org.cn/safe/201407041.asp?artid=2511">http://www.uml.org.cn/safe/201407041.asp?artid=2511</a> 作者：火龙果软件</p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>日记好像没有标题的吧？</title>
    <url>/2017/10/03/there_is_no_title_in_diary/</url>
    <content><![CDATA[<p>国庆休息8天，赋闲在家，也只有在老家的时候可以做到<strong>晚上八点上床睡觉</strong>。。<br>闲来无事，不记得之前在哪里看到的<em>hexo</em>博客搭建。昨天下午小事了一下，成就感满满。中途遇到访问<a href="https://someoneiscoding.github.io/">本站</a>总是跳转到 <em><a href="https://someiscoding.com/">https://someiscoding.com</a></em> ，但自己明明没有购买域名，导致每次DNS服务器无法解析地址。后来索性把GitHub上的账户名修改了下，重新配置了下_config文件，终于可以正常访问了。紧接着就是更换主题，选取比较稳妥的next主题，网上关于配置next的教程比较多，上手还快一些~因为中间一直使用终端，用的又是mac，不知道什么原因，终端中连<code>ls</code>命令都无法使用，总是提示命令无法找到什么的，一直以为是权限不够，需要开始ROOT权限。后来发现切换到bash中可以正常执行，默认启动的zsh不行。网上查了下，有的说是.zshrc文件中配置有问题，可能是PATH环境变量没有包括各种bin&amp;sbin。于是，在终端<code>echo $PATH</code>发现有bin和sbin。折腾了两个小时，还是误解，，罢了，索性备份了.zshrc文件，重新安装了oh-my-zsh。<br>嗯，，完美！高兴！</p>
<p>记第一篇流水账。</p>
]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>oh-my-zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>比尔盖茨</title>
    <url>/2018/01/20/time_flies/</url>
    <content><![CDATA[<h3 id="时光飞逝"><a href="#时光飞逝" class="headerlink" title="时光飞逝"></a>时光飞逝</h3><p>从未感觉时间的力量如此强大，，</p>
<p>今天下午，一边写项目文档，一边听<strong>极客公园创新大会 IF2018</strong>，，依然，张鹏的主持人，在讲到未来人工智能对现有传统行业的冲击时，提到让科技带有人文色彩，缓冲这种冲击。其中，用到了比尔盖茨的一段视频，，视频中 Bill Gates 阐述了一种观点：</p>
<blockquote>
<p><a href="https://qz.com/911968/bill-gates-the-robot-that-takes-your-job-should-pay-taxes/">原文链接</a><br>The robots that takes your job should pay taxes.<br>应当向拿走你工作的机器人征税。<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131838-robots_should_pay_taxes.png" alt="Robots shouled be taxed"></p>
</blockquote>
<p>这样，，机器人用来做那些重复且机械化的工作，而被解放的劳动力可以用来更好的从事其他只能由人类进行的工作，比如照顾老人，小班授课等等。</p>
<p>但是，今天我并不想讨论这些。。只是，看到视频的一瞬间，有些晶莹的小东西在眼眶里打转，，我知道比尔盖茨老了，但是没想到老成这样。<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901131835-Bill_Gates.png" alt="Bill Gates is old"></p>
<p>我也不知道自己为什么会如此激动，事实上，，我一直用的都是 Macbook Pro 15” 2013 early，虽然是ebay上淘的二手的，但这的确是我第一台个人电脑。我对Windows系统并不感冒，也不是微软的拥趸，，甚至有些厌恶。但看到视频中的比尔盖茨时，，就像看到了一个很熟悉很亲近但又许久未见的亲人(Or朋友)躺在医院的病床上，身上连满了仪器，还有各种侵入式的管子，，见到他那一刻要强忍泪水。。我想不到更好的语言去描述这种感觉，但震撼良久，，尤其是看到他的右视图镜头时。</p>
<p>我开始思考自己为什么会有这样的情绪，，想到<a href="http://someoneiscoding.com/2018/01/02/ProustQA_2017/">普鲁斯特问卷-2017</a>中关于『你最恐惧的是什么？』的回答，，大概明白了。我害怕的是<strong>时光飞逝</strong>，而时间在 Bill Gates 的脸上留下了让人无法忽视的痕迹。而我此时看到Bill，就像收到一条来自时间的警告，，警告我，『*listen~ ti ke ta ke, ti ke ta ke…The time is passing!*』看到『时光飞逝』四个字并不可怕，但是看到熟悉的人『突然』衰老，，这很可怕！！！Bill 将这种可怕具象化了。。突然感觉和他更加亲近，也许我厌恶的不是 Windows，而是 Windows 平台上各种国产杀毒软件，安全管家之类的流氓行为，还有各种弹框。我安装个搜狗输入法，搜狐新闻弹个毛线？！Shit! 不晓得国外的 Windows 生态是不是也是这样。。不可否认的是 Bill Gates 让计算机真正走入千家万户，，正所谓『旧时王谢堂前燕，飞入寻常百姓家』。计算机最初本是用来计算导弹弹道，之后开始流行于商业，排版啊，计算啊，，直到1995年的 win95 出现，图形化页面的操作体验对普通用户非常友好，同时也点亮了计算机技能树中的娱乐功能。正因为这一点，包括因特网在内的信息技术才会得到如此跨越式的发展，，倘若，计算机仅限于军事、商业、科学研究，那么现在地球肯定不能被称作『地球村』。单这一点来说，，Bill Gates 功不可没。采访中，视频结尾，，Bill Gates 不好意思的挠头了，眼神也没那么严肃了，甚至还飘向了周围，然后迅速收回，，不得不说，瞬间被实力圈粉。在这儿，我想说他很可爱，合适么？哈哈</p>
<hr>
<p>那么，，为什么当初选 Mac 呢？<br>一方面，因为从事过苹果产品销售的工作，对Mac比较熟悉，不夸张的说，，我接触 Mac 的时间比接触 Windows 的时间要长(扶额.jpg)，，不是因为接触 Mac 时间长，而是因为接触 Wondows 时间短，虽然从小学就开始接触 Windows。。这个可以算作 Context，真正原因只有两点，，</p>
<ol>
<li>Mac 上玩主流游戏成本比较高，，尤其是 LOL，虽然有也有 Mac 版，但是是美服，网络延迟也不可想象，，嗯，Mac 的显卡也是够呛。其他游戏就不说了。。</li>
<li>Macbook 的触控板简直不要太好用！！！</li>
</ol>
<p>毕竟买来是想当做生产力工具来用的，不能玩游戏是刚需，，虽然我也没那么大瘾，毕竟手残(再次扶额..)。而触控板就是纯用户体验了，2880×1800 的分辨率也是逆天，在加上流氓软件少之又少，，就它了~</p>
]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>比尔盖茨</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL分组取前N条记录</title>
    <url>/2018/01/17/top-n_after_sql_group/</url>
    <content><![CDATA[<h3 id="SQL分组取前N条记录"><a href="#SQL分组取前N条记录" class="headerlink" title="SQL分组取前N条记录"></a>SQL分组取前N条记录</h3><p>实际业务中有这样这样一个需求，，有6种不同的测试项目，每个项目对应很多小游戏(改善方案)，客户要求测试完成后，每周进行小游戏的循环推送，每种项目每次推送5个小游戏。</p>
<blockquote>
<p>假如A项目对应的小游戏有8个，，那么第一周则推送第1-5个，第二周则推送6、7、8、1、2,以此方式进行循环。</p>
</blockquote>
<p>单个项目还好说，但是6种项目怎么搞？！懵逼。。想不出来，，好吧，用存储过程搞定了。但是，在前期摸索的过程中，发现好多猿猿也有类似的需求，，只不过，我的需要循环。那么，，倘若不循环，值进行一次推送呢？6个项目一起，每种项目取前5项？可以学习下~</p>
<hr>
<p>以网上都能找到的例子来说：[^1]</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询每门课程的前2名成绩</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> StudentGrade(<br>    stuId <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>),    <span class="hljs-comment">--学号</span><br>    subId <span class="hljs-type">INT</span>,        <span class="hljs-comment">--课程号</span><br>    grade <span class="hljs-type">INT</span>,        <span class="hljs-comment">--成绩</span><br>    <span class="hljs-keyword">PRIMARY</span> KEY (stuId,subId)<br>)<br><br><span class="hljs-comment">-- 表中数据如下</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">97</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">50</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;001&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">70</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">92</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">80</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;002&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">30</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">93</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">95</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;003&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">85</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;004&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">73</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;004&#x27;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">78</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> StudentGrade(stuId,subId,grade) <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;004&#x27;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">87</span>);<br><br><span class="hljs-comment">-- 要查询每门课程的前2名成绩，即</span><br><span class="hljs-number">001</span> <span class="hljs-number">1</span> <span class="hljs-number">97</span><br><span class="hljs-number">003</span> <span class="hljs-number">1</span> <span class="hljs-number">93</span><br><span class="hljs-number">003</span> <span class="hljs-number">2</span> <span class="hljs-number">95</span><br><span class="hljs-number">002</span> <span class="hljs-number">2</span> <span class="hljs-number">80</span><br><span class="hljs-number">004</span> <span class="hljs-number">3</span> <span class="hljs-number">87</span><br><span class="hljs-number">003</span> <span class="hljs-number">3</span> <span class="hljs-number">85</span><br><span class="hljs-comment">-- 如何实现？</span><br></code></pre></td></tr></table></figure>

<p>查看表中所有数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> StudentGrade <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> subid <span class="hljs-keyword">asc</span>,grade <span class="hljs-keyword">desc</span><br><span class="hljs-operator">|</span>学号<span class="hljs-operator">|</span>科目<span class="hljs-operator">|</span>成绩<span class="hljs-operator">|</span><br><span class="hljs-number">001</span>     <span class="hljs-number">1</span>	<span class="hljs-number">97</span><br><span class="hljs-number">003</span>     <span class="hljs-number">1</span>	<span class="hljs-number">93</span><br><span class="hljs-number">002</span>     <span class="hljs-number">1</span>	<span class="hljs-number">92</span><br><span class="hljs-number">004</span>     <span class="hljs-number">1</span>	<span class="hljs-number">73</span><br><span class="hljs-number">003</span>     <span class="hljs-number">2</span>	<span class="hljs-number">95</span><br><span class="hljs-number">002</span>     <span class="hljs-number">2</span>	<span class="hljs-number">80</span><br><span class="hljs-number">004</span>     <span class="hljs-number">2</span>	<span class="hljs-number">78</span><br><span class="hljs-number">001</span>     <span class="hljs-number">2</span>	<span class="hljs-number">50</span><br><span class="hljs-number">004</span>     <span class="hljs-number">3</span>	<span class="hljs-number">87</span><br><span class="hljs-number">003</span>     <span class="hljs-number">3</span>	<span class="hljs-number">85</span><br><span class="hljs-number">001</span>     <span class="hljs-number">3</span>	<span class="hljs-number">70</span><br><span class="hljs-number">002</span>     <span class="hljs-number">3</span>	<span class="hljs-number">30</span><br></code></pre></td></tr></table></figure>
<p>两种解决方案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 第一种</span><br><span class="hljs-keyword">select</span><br>     <span class="hljs-operator">*</span> <br>    <span class="hljs-keyword">from</span> StudentGrade a <br>    <span class="hljs-keyword">where</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> studentGrade b <span class="hljs-keyword">where</span> b.subId<span class="hljs-operator">=</span>a.subId <span class="hljs-keyword">and</span> b.grade<span class="hljs-operator">&gt;</span>a.grade)<span class="hljs-operator">&lt;</span><span class="hljs-number">2</span> <br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> subId,grade <span class="hljs-keyword">desc</span><br><br><span class="hljs-comment">-- 第二种</span><br><span class="hljs-keyword">SELECT</span> <br>    a.<span class="hljs-operator">*</span> <br>    <span class="hljs-keyword">from</span> StudentGrade a <br>    <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> StudentGrade b <span class="hljs-keyword">on</span> a.subid<span class="hljs-operator">=</span>b.subid <span class="hljs-keyword">and</span> a.grade<span class="hljs-operator">&lt;</span>b.grade <br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a.stuid,a.subid,a.grade <br>    <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(b.stuid)<span class="hljs-operator">&lt;</span><span class="hljs-number">2</span> <br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a.subid,a.grade <span class="hljs-keyword">desc</span><br></code></pre></td></tr></table></figure>
<p>对于第一种方案我是这么理解的，，因为<code>b.subId=a.subId</code>,a、b两表相连，以subId进行区分，类似分组。以科目一为例，，</p>
<ul>
<li>若<code>a.grade=73</code>，则b表中的科目一中<code>&gt;73</code>分的共有3项，而条件要求<code>count(1)&lt;2</code>,这样显然是不符合要求的，所以科目一的73分不行；</li>
<li>同理92分。</li>
<li>若<code>a.grade=93</code>，<code>count(1)=1 &lt; 2</code>，符合要求~</li>
<li>若<code>a.grade=97</code>，<code>count(1)=0 &lt; 2</code>，符合要求~<br><strong>完美</strong>~</li>
</ul>
<p>本来也是有点想不明白的，但是看到下面这句，，诶，有点意思，，噢~了然！</p>
<blockquote>
<p>每取每一条记录，判断同一个班级，大于当前成绩的同学是不是小于2个人[^2]</p>
</blockquote>
<p>对于第二种方案，,有一种奇技淫巧，就是把a、b两表的数据都查询出来</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>    a.<span class="hljs-operator">*</span>,b.<span class="hljs-operator">*</span> <br>    <span class="hljs-keyword">from</span> StudentGrade a <br>    <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> StudentGrade b <span class="hljs-keyword">on</span> a.subid<span class="hljs-operator">=</span>b.subid <span class="hljs-keyword">and</span> a.grade<span class="hljs-operator">&lt;</span>b.grade <br>    <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> a.stuid,a.subid,a.grade <br>    <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(b.stuid)<span class="hljs-operator">&lt;</span><span class="hljs-number">2</span> <br>    <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> a.subid,a.grade <span class="hljs-keyword">desc</span><br>    <br><span class="hljs-comment">-- 结果如下</span><br><span class="hljs-number">001</span>     <span class="hljs-number">1</span>	<span class="hljs-number">97</span>	<span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span>	<br><span class="hljs-number">003</span>     <span class="hljs-number">1</span>	<span class="hljs-number">93</span>	<span class="hljs-number">001</span>	 <span class="hljs-number">1</span>	  <span class="hljs-number">97</span><br><span class="hljs-number">003</span>     <span class="hljs-number">2</span>	<span class="hljs-number">95</span>	<span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span>		<br><span class="hljs-number">002</span>     <span class="hljs-number">2</span>	<span class="hljs-number">80</span>	<span class="hljs-number">003</span>	 <span class="hljs-number">2</span>	  <span class="hljs-number">95</span><br><span class="hljs-number">004</span>     <span class="hljs-number">3</span>	<span class="hljs-number">87</span>	<span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">null</span>		<br><span class="hljs-number">003</span>     <span class="hljs-number">3</span>	<span class="hljs-number">85</span>	<span class="hljs-number">004</span>	 <span class="hljs-number">3</span>	  <span class="hljs-number">87</span><br><span class="hljs-comment">-- 前3列为a表，后3列为b表</span><br></code></pre></td></tr></table></figure>
<p>如此看来，清楚明了，，因为<code>a.subid=b.subid and a.grade&lt;b.grade</code>，所以第2行a表的93分和b表的97分相连了，又因为<code>count(b.stuid)&lt;2</code>，所以只取了a表每个科目的前2项。若我们只取a表的数据，后3列消失，，<strong>完美</strong>~</p>
<p>这个，，就这样吧，剩下的就是实操了，还是自己亲身<code>command+R</code>运行一下，体会更深~</p>
<p>[^1]: <a href="http://blog.163.com/jeson_lwj/blog/static/135761083201052411115783/">sql 用Group by分组后,取每组的前几条记录(转)</a></p>
<p>[^2]: <a href="http://www.jb51.net/article/87307.htm">mysql使用GROUP BY分组实现取前N条记录的方法</a></p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>事务隔离-高低水位</title>
    <url>/2021/06/11/transation-isolated/</url>
    <content><![CDATA[<h3 id="事务隔离-高低水位"><a href="#事务隔离-高低水位" class="headerlink" title="事务隔离-高低水位"></a>事务隔离-高低水位</h3><p>最近在复习丁奇大大<a href="https://time.geekbang.org/column/article/70562">MySQL实战45讲 - 08 | 事务到底是隔离的还是不隔离的？</a>中关于 RC 隔离级别的实现时，以前好像读懂的地方又读不懂了。尤其是对下👇图:<strong>数据版本可见性规则</strong> 中高低水位『当前事务』的理解。</p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><blockquote>
<p>在可重复读隔离级别下，事务在启动的时候就『拍了个快照』。</p>
</blockquote>
<blockquote>
<p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
</blockquote>
<p>按照定义来说，当该事务在启动的时候就『拍了个快照』。那么快照发生时，该事务应该是当前最新(latest)的事务，该快照中不应该包含该时候之后的事务了。即『当前事务』不应该在下图中『未提交事务集合』的最右侧么？为什么图片中体现的是『当前事务』右侧还有其他事务？</p>
<p><img src="https://static001.geekbang.org/resource/image/88/5e/882114aaf55861832b4270d44507695e.png" alt="数据版本可见性规则"></p>
<blockquote>
<p>InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在『活跃』的所有事务 ID。『活跃』指的就是，启动了但还没提交。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）</p>
</blockquote>
<blockquote>
<p>对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：</p>
<ol>
<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>
<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>
<li>如果落在黄色部分，那就包括两种情况：<ol>
<li>若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li>
<li>若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。</li>
</ol>
</li>
</ol>
</blockquote>
<p>还有上👆面分析中的 3.2 ，感觉前后矛盾。明明黄色部分是『未提交事务集合』，为什么又说『这个版本是已经提交了的事务生成的』？？</p>
<h4 id="求索"><a href="#求索" class="headerlink" title="求索"></a>求索</h4><p>在 MySql 的官方文档中，发现有这么一段话：</p>
<blockquote>
<p><code>InnoDB</code> can avoid the overhead associated with setting up the <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_transaction_id">transaction ID</a> (<code>TRX_ID</code> field) for transactions that are known to be read-only. A transaction ID is only needed for a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_transaction">transaction</a> that might perform write operations or <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_locking_read">locking reads</a> such as <code>SELECT ... FOR UPDATE</code>. Eliminating unnecessary transaction IDs reduces the size of internal data structures that are consulted each time a query or data change statement constructs a <a href="https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_read_view">read view</a>.[^1]</p>
<p>InnoD B可以避免为已知为只读的事务设置 trx_id 带来的开销。只有可能执行写操作或 locking read 的事务才需要（分配）trx_id 。避免分配不必要的 trx_id 可以减少每次查询或数据更改语句构造读视图时所查询的内部数据结构的大小。</p>
</blockquote>
<p>我的理解是，，如果事务开始后，执行第一条 [写操作 | locking reads ] sql 时才会分配 trx_id。</p>
<p>另外，丁奇大大原文中还提到的这样几句话：</p>
<blockquote>
<p>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p>
<ol>
<li><p>第一种启动方式，一致性视图是在执行第一个快照读语句时创建的；</p>
</li>
<li><p>第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</p>
</li>
</ol>
<p>关于『第一种启动方式，一致性视图是在执行第一个快照读语句时创建的』，MySql官方文档中是这样描述的：👇</p>
<blockquote>
<p>If the transaction isolation level is REPEATABLE READ (the default level), all consistent reads within the same transaction read the snapshot established by the first such read in that transaction…</p>
<p>With READ COMMITTED isolation level, each consistent read within a transaction sets and reads its own fresh snapshot.[^2]</p>
<p>RR 隔离级别下，同一事务中的所有一致读都将读取该事务中第一个此类读(一致性读)所建立的快照。</p>
<p>RC 隔离界别下，事务中的每个一致读都会设置并读取自己的新快照。</p>
</blockquote>
</blockquote>
<p>我们可以从中得出以下信息：</p>
<ol>
<li>事务启动时间 before 一致性视图创建时间；</li>
<li>事务启动时间 before trx_id 分配时间；</li>
<li>事务不一定会创建 read view，eg. 事务中只有一个 update 语句；</li>
<li>对于复杂事务，先执行 写操作 语句，则先分配 trx_id ；先执行 Consistent Reads 则先创建 read view。</li>
</ol>
<h4 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h4><p>所以，对于之前提到的『图片中体现的是<em>当前事务</em>右侧还有其他事务？』，这里可以做出解答了：</p>
<p>↓ 事务 A 启动；</p>
<p>↓ 事务 B 启动，并执行[写操作 | locking reads ]  ，得到 trx_id:B;</p>
<p>↓ 事务 A 执行 consistent read 操作，创建 read view;</p>
<p>↓ 事务 A 执行[写操作 | locking reads ] ，得到 trx_id:A;</p>
<p>trx_id:B &lt; trx_id:A</p>
<blockquote>
<p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的[^3]。</p>
</blockquote>
<p>对于第二个疑问，有如下场景：</p>
<p>↓ 事务 A 启动，并执行[写操作 | locking reads ] ，得到 trx_id:A;</p>
<p>↓ 事务 B 启动，并执行[写操作 | locking reads ] ，得到 trx_id:B;</p>
<p>↓ 事务 B 提交;</p>
<p>↓ 事务 C 启动，创建一致性视图，并执行[写操作 | locking reads ] ，此时事务 A 为活跃事务;</p>
<p>则 trx_id:B 大于低水位，小于高水位，但不在数组内。</p>
<hr>
<p>[^1]: <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-performance-ro-txn.html">Optimizing InnoDB Read-Only Transactions</a><br>[^2]: <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-consistent-read.html">Consistent Nonlocking Reads</a><br>[^3]: 没摘自课程原文，没有在官方文档中找到原文，知晓的同学还请告知下。</p>
<p><a href="http://blog.itpub.net/29654823/viewspace-2774598/">贺子_DBA时代: mysql XID和trx_id小结</a></p>
]]></content>
      <categories>
        <category>Java后时代</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>隔离</tag>
      </tags>
  </entry>
  <entry>
    <title>真随机</title>
    <url>/2018/07/08/truly_random/</url>
    <content><![CDATA[<p>是这样么？<br><img src="https://someoneiscoding-gallery-1257225696.cos.ap-guangzhou.myqcloud.com/blog/20190901133815-%E7%9C%9F%E9%9A%8F%E6%9C%BA.jpg" alt="随机"><br>@(2018-06-28 09:30)</p>
]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>随机</tag>
        <tag>自由意志</tag>
      </tags>
  </entry>
  <entry>
    <title>孔雀为什么开屏呢?</title>
    <url>/2017/12/07/why_does_the_peacock_spread_its_tail/</url>
    <content><![CDATA[<h3 id="孔雀为什么开屏呢？"><a href="#孔雀为什么开屏呢？" class="headerlink" title="孔雀为什么开屏呢？"></a>孔雀为什么开屏呢？</h3><p>好像突然明白了老祖宗强调的『成家立业』，成家在前，立业在后。稳定的伴侣对人类这种有性生殖的动物来说，无疑是重中之重。<br>宏观一点讲，人的一生可以分为这几个阶段：</p>
<ol>
<li>生长发育至性成熟</li>
<li>寻找配偶</li>
<li>交配产子</li>
<li>抚养后代至性成熟</li>
</ol>
<p>感情稳定的人儿可以将更多的精力放在家庭和事业上。而那些，那些单身<del>狗</del>呢？？不仅需要全局<code>tigger</code>去监听意中人的出现事件，还要<code>轮询</code>这个对象到底是不是意中人。前者是占用的资源是隐性的，是生理驱动的，，后者是显性的，甚至在某一时间段是同步且阻塞的。</p>
<p>试想一下，，你正在工作，忽然后客人来访，余光扫到这个对象，，</p>
<ul>
<li>如果是男性，<code>tigger</code>直接无视，头都不带抬的；</li>
<li>如果是女性，注意力『不自觉』被分散，抬头，，肤白貌美？？工作事件被中断，各种分析，在有限的上下文中尽可能获取该异性的信息。</li>
</ul>
<p>再试想下，，出现这样一个『意中人』，你在TA的朋友圈中添加了评论。接下来，有且仅有一种情况，，就是不停的解锁手机，打开微信，刷新朋友圈。</p>
<p>单身可能真的是一种非常规的生活状态吧，至少不是稳态。<strong>它像贫穷一样占用着我们有限的注意力资源，，都是生理饥渴，无暇顾及诗和远方，喂饱了再说。</strong></p>
]]></content>
      <categories>
        <category>呓语</category>
      </categories>
      <tags>
        <tag>成家立业</tag>
        <tag>单身</tag>
        <tag>注意力资源</tag>
      </tags>
  </entry>
  <entry>
    <title>普鲁斯特问卷-2024</title>
    <url>/2025/01/12/ProustQA_2024/</url>
    <content><![CDATA[<p>转眼间到 2025 年了，时间过得可真快。。</p>
<p>奶奶的情况在去年夏天突然恶化了，06-22 周末接到老爷子的视频，说奶奶精神不好，村里的医生给开了药一直沉睡，大部时间都是半昏迷的状态。刚刚醒过来，跟我视频连线下。我跟奶奶打招呼，她没有什么反应，只是半睁着眼，这着实让我有点吃惊。现在想想，更多的是后怕、后悔。没多久 06-25 早上 10 点多接到老父亲的消息，奶奶走了。意料之外。赶紧交接工作，订机票回家。</p>
<p>最终还是没有吃上我的这碗菜。</p>
<p>只能安慰自己，，还好，在 4 月份跟大象领证了；还好，在 2023 年国庆带大象回家见过了。</p>
<hr>
<ol>
<li>你认为最完美的快乐是怎样的？<br>
<strong>最完美的快乐，可能总是对应最极致的痛苦</strong>。希望痛苦在前，快乐在后。或者，平平淡淡，无意义的消磨时间也挺好</li>
<li>你最希望拥有哪种才华？<br>
系统的学习单片机，这对于一个想靠近 Geek 的人太重要了，，<strong>贴近硬件，贴近硬件，贴近硬件</strong></li>
<li>你最恐惧的是什么？<br>
<strong>乐极生悲，得意忘形</strong></li>
<li>你目前的心境怎样？<br>
很平静，只是近几年写问卷的时候都要再次面对失去亲人的痛苦</li>
<li>还在世的人中你最钦佩的是谁？<br>
<strong>离老马太远，离稚晖君太近</strong>。老马还是有点东西的，2024 年把身家性命 all in 川普，赢了。沉默的大多数。</li>
<li>你认为自己最伟大的成就是什么？<br>
<strong>少让家里人操心</strong></li>
<li>你自己的哪个特点让你最觉得痛恨？<br>
<strong>还是不够自律…</strong></li>
<li>你最喜欢的旅行是哪一次？<br>
2024 年，清明假期前后，跟周婶儿四人行，汕头，虽然有点赶</li>
<li>你最痛恨别人的什么特点？<br>
<strong>一条消息能说完的事情，请不要拆成 N 条消息，真的</strong></li>
<li>你最珍惜的财产是什么？<br>
<strong>个人信用</strong></li>
<li>你最奢侈的是什么？<br>
<strong>父母是如此爱我</strong></li>
<li>你认为程度最浅的痛苦是什么？<br>
<strong>浅的都不痛苦，痛苦都不浅</strong></li>
<li>你认为哪种美德是被过高的评估的？<br>
这个话题一两句说不清楚，，容易引战</li>
<li>你最喜欢的职业是什么？<br>
<strong>依然程序员</strong>(上边提到的『稚晖君』，奈斯！)</li>
<li>你对自己的外表哪一点不满意？<br>
<strong>右上眼皮可不可以不要内双</strong>，最近发现身上的痦子多了很多，脸上也是 好在都在侧面。。</li>
<li>你最后悔的事情是什么？<br>
<strong>大学混沌且不自知</strong></li>
<li>还在世的人中你最鄙视的是谁？<br>
<strong>每个人应该都不想被别人鄙视的…</strong></li>
<li>你最喜欢男性身上的什么品质？<br>
<strong>能为自己说过的话、做过的事负责</strong></li>
<li>你使用过的最多的单词或者是词语是什么？<br>
今年没有什么特别经常挂在嘴边的，，每天下班前在微信上跟大象在微信上说的『回家』？</li>
<li>你最喜欢女性身上的什么品质？<br>
<strong>理性的自恰、他恰</strong></li>
<li>你最伤痛的事是什么？<br>
<strong>远离家乡</strong></li>
<li>你最看重朋友的什么特点？<br>
<strong>靠谱儿</strong></li>
<li>你这一生中最爱的人或东西是什么？<br>
『<strong>眼前人</strong>』</li>
<li>你希望以什么样的方式死去？<br>
<strong>安乐死，或者一场猝不及防的意外</strong></li>
<li>何时何地让你感觉到最快乐？<br>
<strong>Eureka</strong></li>
<li>如果你可以改变你的家庭一件事，那会是什么？<br>
<strong>大家身体健康就好，别的不奢求，，一切都是有代价的</strong></li>
<li>如果你能选择的话，你希望让什么重现？<br>
<strong>小我：小时候，周末，早晨，听着 大花轿 醒来，，</strong></li>
<li>你的座右铭是什么？<br>
经历过就是财富，，2024 年有了更时髦的说法: <strong>踏上取经路比抵达灵山更重要</strong></li>
</ol>
<hr>
<p><strong>Extra…</strong><br>
2024 年还有什么想说的？？</p>
<ul>
<li>
<p>这一年你都做了些啥？？</p>
<ol>
<li>01 - 在给岭背西4巷5号的卫生间重新刷漆，加装洗手池，更新加压泵</li>
<li>03 - 到处看房踩盘</li>
<li>04 - 和周婶儿四人行汕头；04-yy 申购人才房；爸妈来深圳，双方家长见面；领证。05-zz 房贷审批通过。</li>
<li>07 - 和周婶儿四人行新疆，十天。真大。</li>
<li>08 - 黑神话悟空发售。</li>
<li>09 - 长沙，三天，真热。选配显卡、电源。A 股暴涨，挣了 300 多！</li>
<li>10 - 澳门，两天，故地重游。</li>
<li>11 - 珠海航展。</li>
<li>12 - 办理港卡；为 2025 元旦假期的东北五日游做攻略。</li>
</ol>
<p>2023 年 01-31 正式离职；02 复习 + 深马；03 入职。12 入深户。</p>
</li>
<li>
<p>明年有什么准备？</p>
<ol>
<li>看完宏观经济学 + 微观经济学 + 业务无线电通信</li>
<li>搭个 NAS</li>
<li>单片机选型</li>
<li>搞钱</li>
</ol>
</li>
<li>
<p>还有什么想说的没？？</p>
<ol>
<li>结婚之后最大的感受就是，，心往一块想，劲儿往一块使，零和博弈基本消失。</li>
<li>受过的教育，读过的书，认识的人，决定了你遇到什么样的事、什么样的烦恼，，可能会觉得自己太幸运、太不幸，其实是过往的每一个决定使然。</li>
<li>所有命运馈赠的礼物，暗中都标好了价格。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>ProustQA</category>
      </categories>
      <tags>
        <tag>普鲁斯特问卷</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/about/index.html</url>
    <content><![CDATA[<hr style="margin: 20px 0;">
<div style="display:flex;flex-direction: row;flex-wrap: wrap;justify-content: space-around;align-items: flex-start;"><ul style="width: 256px;"><li><strong>半路出家的初级程序员</strong></li><li><strong>全马PB324Finisher</strong></li><li><strong>信息收集爱好者</strong></li><li><strong>轻微数据洁癖</strong></li><li><strong>终生学习者</strong></li><strong>…</strong><li><strong>嗯，永远是人民的小学生~</strong></li></ul><iframe src='./photoDot/index.html' style="margin-top: 14px;border: 0;width:256px;height: 256px;" scrolling="no">
</div>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
